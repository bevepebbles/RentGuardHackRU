var db = Object.defineProperty, fb = (e, t, a) => t in e ? db(e, t, { enumerable: !0, configurable: !0, writable: !0, value: a }) : e[t] = a, cc = (e, t, a) => (fb(e, typeof t != "symbol" ? t + "" : t, a), a), ub = typeof global == "object" && global && global.Object === Object && global;
const lb = ub;
var bb = typeof self == "object" && self && self.Object === Object && self, hb = lb || bb || Function("return this")();
const Ai = hb;
var pb = Ai.Symbol;
const ts = pb;
var _f = Object.prototype, mb = _f.hasOwnProperty, yb = _f.toString, Er = ts ? ts.toStringTag : void 0;
function gb(e) {
  var t = mb.call(e, Er), a = e[Er];
  try {
    e[Er] = void 0;
    var r = !0;
  } catch {
  }
  var n = yb.call(e);
  return r && (t ? e[Er] = a : delete e[Er]), n;
}
var _b = Object.prototype, vb = _b.toString;
function wb(e) {
  return vb.call(e);
}
var Eb = "[object Null]", kb = "[object Undefined]", Mo = ts ? ts.toStringTag : void 0;
function xb(e) {
  return e == null ? e === void 0 ? kb : Eb : Mo && Mo in Object(e) ? gb(e) : wb(e);
}
function vf(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var Tb = "[object AsyncFunction]", Sb = "[object Function]", Cb = "[object GeneratorFunction]", Ab = "[object Proxy]";
function Ob(e) {
  if (!vf(e))
    return !1;
  var t = xb(e);
  return t == Sb || t == Cb || t == Tb || t == Ab;
}
var Ib = Ai["__core-js_shared__"];
const ic = Ib;
var Ho = function() {
  var e = /[^.]+$/.exec(ic && ic.keys && ic.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
}();
function Nb(e) {
  return !!Ho && Ho in e;
}
var Rb = Function.prototype, Pb = Rb.toString;
function Lb(e) {
  if (e != null) {
    try {
      return Pb.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
var jb = /[\\^$.*+?()[\]{}|]/g, Zb = /^\[object .+?Constructor\]$/, Db = Function.prototype, Bb = Object.prototype, Fb = Db.toString, Ub = Bb.hasOwnProperty, $b = RegExp(
  "^" + Fb.call(Ub).replace(jb, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function zb(e) {
  if (!vf(e) || Nb(e))
    return !1;
  var t = Ob(e) ? $b : Zb;
  return t.test(Lb(e));
}
function Mb(e, t) {
  return e?.[t];
}
function wf(e, t) {
  var a = Mb(e, t);
  return zb(a) ? a : void 0;
}
var Hb = wf(Object, "create");
const Br = Hb;
function Vb() {
  this.__data__ = Br ? Br(null) : {}, this.size = 0;
}
function qb(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
var Kb = "__lodash_hash_undefined__", Wb = Object.prototype, Gb = Wb.hasOwnProperty;
function Yb(e) {
  var t = this.__data__;
  if (Br) {
    var a = t[e];
    return a === Kb ? void 0 : a;
  }
  return Gb.call(t, e) ? t[e] : void 0;
}
var Jb = Object.prototype, Xb = Jb.hasOwnProperty;
function Qb(e) {
  var t = this.__data__;
  return Br ? t[e] !== void 0 : Xb.call(t, e);
}
var e1 = "__lodash_hash_undefined__";
function t1(e, t) {
  var a = this.__data__;
  return this.size += this.has(e) ? 0 : 1, a[e] = Br && t === void 0 ? e1 : t, this;
}
function ma(e) {
  var t = -1, a = e == null ? 0 : e.length;
  for (this.clear(); ++t < a; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
ma.prototype.clear = Vb;
ma.prototype.delete = qb;
ma.prototype.get = Yb;
ma.prototype.has = Qb;
ma.prototype.set = t1;
function a1() {
  this.__data__ = [], this.size = 0;
}
function r1(e, t) {
  return e === t || e !== e && t !== t;
}
function Ns(e, t) {
  for (var a = e.length; a--; )
    if (r1(e[a][0], t))
      return a;
  return -1;
}
var n1 = Array.prototype, s1 = n1.splice;
function c1(e) {
  var t = this.__data__, a = Ns(t, e);
  if (a < 0)
    return !1;
  var r = t.length - 1;
  return a == r ? t.pop() : s1.call(t, a, 1), --this.size, !0;
}
function i1(e) {
  var t = this.__data__, a = Ns(t, e);
  return a < 0 ? void 0 : t[a][1];
}
function o1(e) {
  return Ns(this.__data__, e) > -1;
}
function d1(e, t) {
  var a = this.__data__, r = Ns(a, e);
  return r < 0 ? (++this.size, a.push([e, t])) : a[r][1] = t, this;
}
function dr(e) {
  var t = -1, a = e == null ? 0 : e.length;
  for (this.clear(); ++t < a; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
dr.prototype.clear = a1;
dr.prototype.delete = c1;
dr.prototype.get = i1;
dr.prototype.has = o1;
dr.prototype.set = d1;
var f1 = wf(Ai, "Map");
const u1 = f1;
function l1() {
  this.size = 0, this.__data__ = {
    hash: new ma(),
    map: new (u1 || dr)(),
    string: new ma()
  };
}
function b1(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
function Rs(e, t) {
  var a = e.__data__;
  return b1(t) ? a[typeof t == "string" ? "string" : "hash"] : a.map;
}
function h1(e) {
  var t = Rs(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
function p1(e) {
  return Rs(this, e).get(e);
}
function m1(e) {
  return Rs(this, e).has(e);
}
function y1(e, t) {
  var a = Rs(this, e), r = a.size;
  return a.set(e, t), this.size += a.size == r ? 0 : 1, this;
}
function Aa(e) {
  var t = -1, a = e == null ? 0 : e.length;
  for (this.clear(); ++t < a; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
Aa.prototype.clear = l1;
Aa.prototype.delete = h1;
Aa.prototype.get = p1;
Aa.prototype.has = m1;
Aa.prototype.set = y1;
var g1 = "Expected a function";
function Oi(e, t) {
  if (typeof e != "function" || t != null && typeof t != "function")
    throw new TypeError(g1);
  var a = function() {
    var r = arguments, n = t ? t.apply(this, r) : r[0], s = a.cache;
    if (s.has(n))
      return s.get(n);
    var c = e.apply(this, r);
    return a.cache = s.set(n, c) || s, c;
  };
  return a.cache = new (Oi.Cache || Aa)(), a;
}
Oi.Cache = Aa;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Ef = BigInt(0), Ps = BigInt(1), _1 = BigInt(2), Ls = (e) => e instanceof Uint8Array, v1 = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function Mt(e) {
  if (!Ls(e))
    throw new Error("Uint8Array expected");
  let t = "";
  for (let a = 0; a < e.length; a++)
    t += v1[e[a]];
  return t;
}
function kf(e) {
  const t = e.toString(16);
  return t.length & 1 ? `0${t}` : t;
}
function js(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  return BigInt(e === "" ? "0" : `0x${e}`);
}
function Ht(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  if (e.length % 2)
    throw new Error("hex string is invalid: unpadded " + e.length);
  const t = new Uint8Array(e.length / 2);
  for (let a = 0; a < t.length; a++) {
    const r = a * 2, n = e.slice(r, r + 2), s = Number.parseInt(n, 16);
    if (Number.isNaN(s) || s < 0)
      throw new Error("invalid byte sequence");
    t[a] = s;
  }
  return t;
}
function Ne(e) {
  return js(Mt(e));
}
function Ii(e) {
  if (!Ls(e))
    throw new Error("Uint8Array expected");
  return js(Mt(Uint8Array.from(e).reverse()));
}
const Ha = (e, t) => Ht(e.toString(16).padStart(t * 2, "0")), xf = (e, t) => Ha(e, t).reverse(), Ni = (e) => Ht(kf(e));
function je(e, t, a) {
  let r;
  if (typeof t == "string")
    try {
      r = Ht(t);
    } catch (s) {
      throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${s}`);
    }
  else if (Ls(t))
    r = Uint8Array.from(t);
  else
    throw new Error(`${e} must be hex string or Uint8Array`);
  const n = r.length;
  if (typeof a == "number" && n !== a)
    throw new Error(`${e} expected ${a} bytes, got ${n}`);
  return r;
}
function Ja(...e) {
  const t = new Uint8Array(e.reduce((r, n) => r + n.length, 0));
  let a = 0;
  return e.forEach((r) => {
    if (!Ls(r))
      throw new Error("Uint8Array expected");
    t.set(r, a), a += r.length;
  }), t;
}
function w1(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let a = 0; a < e.length; a++)
    if (e[a] !== t[a])
      return !1;
  return !0;
}
function E1(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new TextEncoder().encode(e);
}
function k1(e) {
  let t;
  for (t = 0; e > Ef; e >>= Ps, t += 1)
    ;
  return t;
}
const x1 = (e, t) => e >> BigInt(t) & Ps, T1 = (e, t, a) => e | (a ? Ps : Ef) << BigInt(t), Zs = (e) => (_1 << BigInt(e - 1)) - Ps, oc = (e) => new Uint8Array(e), Vo = (e) => Uint8Array.from(e);
function Tf(e, t, a) {
  if (typeof e != "number" || e < 2)
    throw new Error("hashLen must be a number");
  if (typeof t != "number" || t < 2)
    throw new Error("qByteLen must be a number");
  if (typeof a != "function")
    throw new Error("hmacFn must be a function");
  let r = oc(e), n = oc(e), s = 0;
  const c = () => {
    r.fill(1), n.fill(0), s = 0;
  }, i = (...f) => a(n, r, ...f), o = (f = oc()) => {
    n = i(Vo([0]), f), r = i(), f.length !== 0 && (n = i(Vo([1]), f), r = i());
  }, d = () => {
    if (s++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let f = 0;
    const u = [];
    for (; f < t; ) {
      r = i();
      const l = r.slice();
      u.push(l), f += r.length;
    }
    return Ja(...u);
  };
  return (f, u) => {
    c(), o(f);
    let l;
    for (; !(l = u(d())); )
      o();
    return c(), l;
  };
}
const S1 = {
  bigint: (e) => typeof e == "bigint",
  function: (e) => typeof e == "function",
  boolean: (e) => typeof e == "boolean",
  string: (e) => typeof e == "string",
  isSafeInteger: (e) => Number.isSafeInteger(e),
  array: (e) => Array.isArray(e),
  field: (e, t) => t.Fp.isValid(e),
  hash: (e) => typeof e == "function" && Number.isSafeInteger(e.outputLen)
};
function vn(e, t, a = {}) {
  const r = (n, s, c) => {
    const i = S1[s];
    if (typeof i != "function")
      throw new Error(`Invalid validator "${s}", expected function`);
    const o = e[n];
    if (!(c && o === void 0) && !i(o, e))
      throw new Error(`Invalid param ${String(n)}=${o} (${typeof o}), expected ${s}`);
  };
  for (const [n, s] of Object.entries(t))
    r(n, s, !1);
  for (const [n, s] of Object.entries(a))
    r(n, s, !0);
  return e;
}
const C1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bitGet: x1,
  bitLen: k1,
  bitMask: Zs,
  bitSet: T1,
  bytesToHex: Mt,
  bytesToNumberBE: Ne,
  bytesToNumberLE: Ii,
  concatBytes: Ja,
  createHmacDrbg: Tf,
  ensureBytes: je,
  equalBytes: w1,
  hexToBytes: Ht,
  hexToNumber: js,
  numberToBytesBE: Ha,
  numberToBytesLE: xf,
  numberToHexUnpadded: kf,
  numberToVarBytesBE: Ni,
  utf8ToBytes: E1,
  validateObject: vn
}, Symbol.toStringTag, { value: "Module" }));
function $c(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`Wrong positive integer: ${e}`);
}
function A1(e) {
  if (typeof e != "boolean")
    throw new Error(`Expected boolean, not ${e}`);
}
function Sf(e, ...t) {
  if (!(e instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function O1(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  $c(e.outputLen), $c(e.blockLen);
}
function I1(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function N1(e, t) {
  Sf(e);
  const a = t.outputLen;
  if (e.length < a)
    throw new Error(`digestInto() expects output buffer of length at least ${a}`);
}
const yt = {
  number: $c,
  bool: A1,
  bytes: Sf,
  hash: O1,
  exists: I1,
  output: N1
}, Dn = BigInt(2 ** 32 - 1), zc = BigInt(32);
function Cf(e, t = !1) {
  return t ? { h: Number(e & Dn), l: Number(e >> zc & Dn) } : { h: Number(e >> zc & Dn) | 0, l: Number(e & Dn) | 0 };
}
function R1(e, t = !1) {
  let a = new Uint32Array(e.length), r = new Uint32Array(e.length);
  for (let n = 0; n < e.length; n++) {
    const { h: s, l: c } = Cf(e[n], t);
    [a[n], r[n]] = [s, c];
  }
  return [a, r];
}
const P1 = (e, t) => BigInt(e >>> 0) << zc | BigInt(t >>> 0), L1 = (e, t, a) => e >>> a, j1 = (e, t, a) => e << 32 - a | t >>> a, Z1 = (e, t, a) => e >>> a | t << 32 - a, D1 = (e, t, a) => e << 32 - a | t >>> a, B1 = (e, t, a) => e << 64 - a | t >>> a - 32, F1 = (e, t, a) => e >>> a - 32 | t << 64 - a, U1 = (e, t) => t, $1 = (e, t) => e, z1 = (e, t, a) => e << a | t >>> 32 - a, M1 = (e, t, a) => t << a | e >>> 32 - a, H1 = (e, t, a) => t << a - 32 | e >>> 64 - a, V1 = (e, t, a) => e << a - 32 | t >>> 64 - a;
function q1(e, t, a, r) {
  const n = (t >>> 0) + (r >>> 0);
  return { h: e + a + (n / 2 ** 32 | 0) | 0, l: n | 0 };
}
const K1 = (e, t, a) => (e >>> 0) + (t >>> 0) + (a >>> 0), W1 = (e, t, a, r) => t + a + r + (e / 2 ** 32 | 0) | 0, G1 = (e, t, a, r) => (e >>> 0) + (t >>> 0) + (a >>> 0) + (r >>> 0), Y1 = (e, t, a, r, n) => t + a + r + n + (e / 2 ** 32 | 0) | 0, J1 = (e, t, a, r, n) => (e >>> 0) + (t >>> 0) + (a >>> 0) + (r >>> 0) + (n >>> 0), X1 = (e, t, a, r, n, s) => t + a + r + n + s + (e / 2 ** 32 | 0) | 0, Fr = {
  fromBig: Cf,
  split: R1,
  toBig: P1,
  shrSH: L1,
  shrSL: j1,
  rotrSH: Z1,
  rotrSL: D1,
  rotrBH: B1,
  rotrBL: F1,
  rotr32H: U1,
  rotr32L: $1,
  rotlSH: z1,
  rotlSL: M1,
  rotlBH: H1,
  rotlBL: V1,
  add: q1,
  add3L: K1,
  add3H: W1,
  add4L: G1,
  add4H: Y1,
  add5H: X1,
  add5L: J1
};
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Q1 = (e) => e instanceof Uint8Array, e2 = (e) => new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4)), dc = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength), Qe = (e, t) => e << 32 - t | e >>> t, t2 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!t2)
  throw new Error("Non little-endian hardware is not supported");
Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function Af(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
function Ds(e) {
  if (typeof e == "string" && (e = Af(e)), !Q1(e))
    throw new Error(`expected Uint8Array, got ${typeof e}`);
  return e;
}
let Of = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function Ri(e) {
  const t = (r) => e().update(Ds(r)).digest(), a = e();
  return t.outputLen = a.outputLen, t.blockLen = a.blockLen, t.create = () => e(), t;
}
function a2(e) {
  const t = (r, n) => e(n).update(Ds(r)).digest(), a = e({});
  return t.outputLen = a.outputLen, t.blockLen = a.blockLen, t.create = (r) => e(r), t;
}
const [If, Nf, Rf] = [[], [], []], r2 = BigInt(0), kr = BigInt(1), n2 = BigInt(2), s2 = BigInt(7), c2 = BigInt(256), i2 = BigInt(113);
for (let e = 0, t = kr, a = 1, r = 0; e < 24; e++) {
  [a, r] = [r, (2 * a + 3 * r) % 5], If.push(2 * (5 * r + a)), Nf.push((e + 1) * (e + 2) / 2 % 64);
  let n = r2;
  for (let s = 0; s < 7; s++)
    t = (t << kr ^ (t >> s2) * i2) % c2, t & n2 && (n ^= kr << (kr << BigInt(s)) - kr);
  Rf.push(n);
}
const [o2, d2] = Fr.split(Rf, !0), qo = (e, t, a) => a > 32 ? Fr.rotlBH(e, t, a) : Fr.rotlSH(e, t, a), Ko = (e, t, a) => a > 32 ? Fr.rotlBL(e, t, a) : Fr.rotlSL(e, t, a);
function f2(e, t = 24) {
  const a = new Uint32Array(10);
  for (let r = 24 - t; r < 24; r++) {
    for (let c = 0; c < 10; c++)
      a[c] = e[c] ^ e[c + 10] ^ e[c + 20] ^ e[c + 30] ^ e[c + 40];
    for (let c = 0; c < 10; c += 2) {
      const i = (c + 8) % 10, o = (c + 2) % 10, d = a[o], f = a[o + 1], u = qo(d, f, 1) ^ a[i], l = Ko(d, f, 1) ^ a[i + 1];
      for (let b = 0; b < 50; b += 10)
        e[c + b] ^= u, e[c + b + 1] ^= l;
    }
    let n = e[2], s = e[3];
    for (let c = 0; c < 24; c++) {
      const i = Nf[c], o = qo(n, s, i), d = Ko(n, s, i), f = If[c];
      n = e[f], s = e[f + 1], e[f] = o, e[f + 1] = d;
    }
    for (let c = 0; c < 50; c += 10) {
      for (let i = 0; i < 10; i++)
        a[i] = e[c + i];
      for (let i = 0; i < 10; i++)
        e[c + i] ^= ~a[(i + 2) % 10] & a[(i + 4) % 10];
    }
    e[0] ^= o2[r], e[1] ^= d2[r];
  }
  a.fill(0);
}
class Bs extends Of {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(t, a, r, n = !1, s = 24) {
    if (super(), this.blockLen = t, this.suffix = a, this.outputLen = r, this.enableXOF = n, this.rounds = s, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, yt.number(r), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = e2(this.state);
  }
  keccak() {
    f2(this.state32, this.rounds), this.posOut = 0, this.pos = 0;
  }
  update(t) {
    yt.exists(this);
    const { blockLen: a, state: r } = this;
    t = Ds(t);
    const n = t.length;
    for (let s = 0; s < n; ) {
      const c = Math.min(a - this.pos, n - s);
      for (let i = 0; i < c; i++)
        r[this.pos++] ^= t[s++];
      this.pos === a && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: t, suffix: a, pos: r, blockLen: n } = this;
    t[r] ^= a, a & 128 && r === n - 1 && this.keccak(), t[n - 1] ^= 128, this.keccak();
  }
  writeInto(t) {
    yt.exists(this, !1), yt.bytes(t), this.finish();
    const a = this.state, { blockLen: r } = this;
    for (let n = 0, s = t.length; n < s; ) {
      this.posOut >= r && this.keccak();
      const c = Math.min(r - this.posOut, s - n);
      t.set(a.subarray(this.posOut, this.posOut + c), n), this.posOut += c, n += c;
    }
    return t;
  }
  xofInto(t) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(t);
  }
  xof(t) {
    return yt.number(t), this.xofInto(new Uint8Array(t));
  }
  digestInto(t) {
    if (yt.output(t, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(t), this.destroy(), t;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(t) {
    const { blockLen: a, suffix: r, outputLen: n, rounds: s, enableXOF: c } = this;
    return t || (t = new Bs(a, r, n, c, s)), t.state32.set(this.state32), t.pos = this.pos, t.posOut = this.posOut, t.finished = this.finished, t.rounds = s, t.suffix = r, t.outputLen = n, t.enableXOF = c, t.destroyed = this.destroyed, t;
  }
}
const ea = (e, t, a) => Ri(() => new Bs(t, e, a));
ea(6, 144, 224 / 8);
ea(6, 136, 256 / 8);
ea(6, 104, 384 / 8);
ea(6, 72, 512 / 8);
ea(1, 144, 224 / 8);
const u2 = ea(1, 136, 256 / 8);
ea(1, 104, 384 / 8);
ea(1, 72, 512 / 8);
const Pf = (e, t, a) => a2((r = {}) => new Bs(t, e, r.dkLen === void 0 ? a : r.dkLen, !0));
Pf(31, 168, 128 / 8);
Pf(31, 136, 256 / 8);
function l2(e, t, a, r) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, a, r);
  const n = BigInt(32), s = BigInt(4294967295), c = Number(a >> n & s), i = Number(a & s), o = r ? 4 : 0, d = r ? 0 : 4;
  e.setUint32(t + o, c, r), e.setUint32(t + d, i, r);
}
class b2 extends Of {
  constructor(t, a, r, n) {
    super(), this.blockLen = t, this.outputLen = a, this.padOffset = r, this.isLE = n, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = dc(this.buffer);
  }
  update(t) {
    yt.exists(this);
    const { view: a, buffer: r, blockLen: n } = this;
    t = Ds(t);
    const s = t.length;
    for (let c = 0; c < s; ) {
      const i = Math.min(n - this.pos, s - c);
      if (i === n) {
        const o = dc(t);
        for (; n <= s - c; c += n)
          this.process(o, c);
        continue;
      }
      r.set(t.subarray(c, c + i), this.pos), this.pos += i, c += i, this.pos === n && (this.process(a, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    yt.exists(this), yt.output(t, this), this.finished = !0;
    const { buffer: a, view: r, blockLen: n, isLE: s } = this;
    let { pos: c } = this;
    a[c++] = 128, this.buffer.subarray(c).fill(0), this.padOffset > n - c && (this.process(r, 0), c = 0);
    for (let u = c; u < n; u++)
      a[u] = 0;
    l2(r, n - 8, BigInt(this.length * 8), s), this.process(r, 0);
    const i = dc(t), o = this.outputLen;
    if (o % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const d = o / 4, f = this.get();
    if (d > f.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let u = 0; u < d; u++)
      i.setUint32(4 * u, f[u], s);
  }
  digest() {
    const { buffer: t, outputLen: a } = this;
    this.digestInto(t);
    const r = t.slice(0, a);
    return this.destroy(), r;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: a, buffer: r, length: n, finished: s, destroyed: c, pos: i } = this;
    return t.length = n, t.pos = i, t.finished = s, t.destroyed = c, n % a && t.buffer.set(r), t;
  }
}
const h2 = (e, t, a) => e & t ^ ~e & a, p2 = (e, t, a) => e & t ^ e & a ^ t & a, m2 = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), It = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), Nt = new Uint32Array(64);
class Lf extends b2 {
  constructor() {
    super(64, 32, 8, !1), this.A = It[0] | 0, this.B = It[1] | 0, this.C = It[2] | 0, this.D = It[3] | 0, this.E = It[4] | 0, this.F = It[5] | 0, this.G = It[6] | 0, this.H = It[7] | 0;
  }
  get() {
    const { A: t, B: a, C: r, D: n, E: s, F: c, G: i, H: o } = this;
    return [t, a, r, n, s, c, i, o];
  }
  // prettier-ignore
  set(t, a, r, n, s, c, i, o) {
    this.A = t | 0, this.B = a | 0, this.C = r | 0, this.D = n | 0, this.E = s | 0, this.F = c | 0, this.G = i | 0, this.H = o | 0;
  }
  process(t, a) {
    for (let u = 0; u < 16; u++, a += 4)
      Nt[u] = t.getUint32(a, !1);
    for (let u = 16; u < 64; u++) {
      const l = Nt[u - 15], b = Nt[u - 2], p = Qe(l, 7) ^ Qe(l, 18) ^ l >>> 3, h = Qe(b, 17) ^ Qe(b, 19) ^ b >>> 10;
      Nt[u] = h + Nt[u - 7] + p + Nt[u - 16] | 0;
    }
    let { A: r, B: n, C: s, D: c, E: i, F: o, G: d, H: f } = this;
    for (let u = 0; u < 64; u++) {
      const l = Qe(i, 6) ^ Qe(i, 11) ^ Qe(i, 25), b = f + l + h2(i, o, d) + m2[u] + Nt[u] | 0, p = (Qe(r, 2) ^ Qe(r, 13) ^ Qe(r, 22)) + p2(r, n, s) | 0;
      f = d, d = o, o = i, i = c + b | 0, c = s, s = n, n = r, r = b + p | 0;
    }
    r = r + this.A | 0, n = n + this.B | 0, s = s + this.C | 0, c = c + this.D | 0, i = i + this.E | 0, o = o + this.F | 0, d = d + this.G | 0, f = f + this.H | 0, this.set(r, n, s, c, i, o, d, f);
  }
  roundClean() {
    Nt.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
class y2 extends Lf {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
}
const Pi = Ri(() => new Lf());
Ri(() => new y2());
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const ge = BigInt(0), de = BigInt(1), sa = BigInt(2), g2 = BigInt(3), Mc = BigInt(4), Wo = BigInt(5), Go = BigInt(8);
BigInt(9);
BigInt(16);
function xe(e, t) {
  const a = e % t;
  return a >= ge ? a : t + a;
}
function _2(e, t, a) {
  if (a <= ge || t < ge)
    throw new Error("Expected power/modulo > 0");
  if (a === de)
    return ge;
  let r = de;
  for (; t > ge; )
    t & de && (r = r * e % a), e = e * e % a, t >>= de;
  return r;
}
function Hc(e, t) {
  if (e === ge || t <= ge)
    throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
  let a = xe(e, t), r = t, n = ge, s = de;
  for (; a !== ge; ) {
    const c = r / a, i = r % a, o = n - s * c;
    r = a, a = i, n = s, s = o;
  }
  if (r !== de)
    throw new Error("invert: does not exist");
  return xe(n, t);
}
function v2(e) {
  const t = (e - de) / sa;
  let a, r, n;
  for (a = e - de, r = 0; a % sa === ge; a /= sa, r++)
    ;
  for (n = sa; n < e && _2(n, t, e) !== e - de; n++)
    ;
  if (r === 1) {
    const c = (e + de) / Mc;
    return function(i, o) {
      const d = i.pow(o, c);
      if (!i.eql(i.sqr(d), o))
        throw new Error("Cannot find square root");
      return d;
    };
  }
  const s = (a + de) / sa;
  return function(c, i) {
    if (c.pow(i, t) === c.neg(c.ONE))
      throw new Error("Cannot find square root");
    let o = r, d = c.pow(c.mul(c.ONE, n), a), f = c.pow(i, s), u = c.pow(i, a);
    for (; !c.eql(u, c.ONE); ) {
      if (c.eql(u, c.ZERO))
        return c.ZERO;
      let l = 1;
      for (let p = c.sqr(u); l < o && !c.eql(p, c.ONE); l++)
        p = c.sqr(p);
      const b = c.pow(d, de << BigInt(o - l - 1));
      d = c.sqr(b), f = c.mul(f, b), u = c.mul(u, d), o = l;
    }
    return f;
  };
}
function w2(e) {
  if (e % Mc === g2) {
    const t = (e + de) / Mc;
    return function(a, r) {
      const n = a.pow(r, t);
      if (!a.eql(a.sqr(n), r))
        throw new Error("Cannot find square root");
      return n;
    };
  }
  if (e % Go === Wo) {
    const t = (e - Wo) / Go;
    return function(a, r) {
      const n = a.mul(r, sa), s = a.pow(n, t), c = a.mul(r, s), i = a.mul(a.mul(c, sa), s), o = a.mul(c, a.sub(i, a.ONE));
      if (!a.eql(a.sqr(o), r))
        throw new Error("Cannot find square root");
      return o;
    };
  }
  return v2(e);
}
const E2 = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function Fs(e) {
  const t = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, a = E2.reduce((r, n) => (r[n] = "function", r), t);
  return vn(e, a);
}
function jf(e, t, a) {
  if (a < ge)
    throw new Error("Expected power > 0");
  if (a === ge)
    return e.ONE;
  if (a === de)
    return t;
  let r = e.ONE, n = t;
  for (; a > ge; )
    a & de && (r = e.mul(r, n)), n = e.sqr(n), a >>= de;
  return r;
}
function k2(e, t) {
  const a = new Array(t.length), r = t.reduce((s, c, i) => e.is0(c) ? s : (a[i] = s, e.mul(s, c)), e.ONE), n = e.inv(r);
  return t.reduceRight((s, c, i) => e.is0(c) ? s : (a[i] = e.mul(s, a[i]), e.mul(s, c)), n), a;
}
function Li(e, t) {
  const a = t !== void 0 ? t : e.toString(2).length, r = Math.ceil(a / 8);
  return { nBitLength: a, nByteLength: r };
}
function ji(e, t, a = !1, r = {}) {
  if (e <= ge)
    throw new Error(`Expected Fp ORDER > 0, got ${e}`);
  const { nBitLength: n, nByteLength: s } = Li(e, t);
  if (s > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const c = w2(e), i = Object.freeze({
    ORDER: e,
    BITS: n,
    BYTES: s,
    MASK: Zs(n),
    ZERO: ge,
    ONE: de,
    create: (o) => xe(o, e),
    isValid: (o) => {
      if (typeof o != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof o}`);
      return ge <= o && o < e;
    },
    is0: (o) => o === ge,
    isOdd: (o) => (o & de) === de,
    neg: (o) => xe(-o, e),
    eql: (o, d) => o === d,
    sqr: (o) => xe(o * o, e),
    add: (o, d) => xe(o + d, e),
    sub: (o, d) => xe(o - d, e),
    mul: (o, d) => xe(o * d, e),
    pow: (o, d) => jf(i, o, d),
    div: (o, d) => xe(o * Hc(d, e), e),
    // Same as above, but doesn't normalize
    sqrN: (o) => o * o,
    addN: (o, d) => o + d,
    subN: (o, d) => o - d,
    mulN: (o, d) => o * d,
    inv: (o) => Hc(o, e),
    sqrt: r.sqrt || ((o) => c(i, o)),
    invertBatch: (o) => k2(i, o),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (o, d, f) => f ? d : o,
    toBytes: (o) => a ? xf(o, s) : Ha(o, s),
    fromBytes: (o) => {
      if (o.length !== s)
        throw new Error(`Fp.fromBytes: expected ${s}, got ${o.length}`);
      return a ? Ii(o) : Ne(o);
    }
  });
  return Object.freeze(i);
}
function x2(e, t, a = !1) {
  e = je("privateHash", e);
  const r = e.length, n = Li(t).nByteLength + 8;
  if (n < 24 || r < n || r > 1024)
    throw new Error(`hashToPrivateScalar: expected ${n}-1024 bytes of input, got ${r}`);
  const s = a ? Ii(e) : Ne(e);
  return xe(s, t - de) + de;
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function Zf(e) {
  const { Fp: t } = e;
  Fs(t);
  for (const o of ["t", "roundsFull", "roundsPartial"])
    if (typeof e[o] != "number" || !Number.isSafeInteger(e[o]))
      throw new Error(`Poseidon: invalid param ${o}=${e[o]} (${typeof e[o]})`);
  if (e.reversePartialPowIdx !== void 0 && typeof e.reversePartialPowIdx != "boolean")
    throw new Error(`Poseidon: invalid param reversePartialPowIdx=${e.reversePartialPowIdx}`);
  let a = e.sboxPower;
  if (a === void 0 && (a = 5), typeof a != "number" || !Number.isSafeInteger(a))
    throw new Error(`Poseidon wrong sboxPower=${a}`);
  const r = BigInt(a);
  let n = (o) => jf(t, o, r);
  if (a === 3 ? n = (o) => t.mul(t.sqrN(o), o) : a === 5 && (n = (o) => t.mul(t.sqrN(t.sqrN(o)), o)), e.roundsFull % 2 !== 0)
    throw new Error(`Poseidon roundsFull is not even: ${e.roundsFull}`);
  const s = e.roundsFull + e.roundsPartial;
  if (!Array.isArray(e.roundConstants) || e.roundConstants.length !== s)
    throw new Error("Poseidon: wrong round constants");
  const c = e.roundConstants.map((o) => {
    if (!Array.isArray(o) || o.length !== e.t)
      throw new Error(`Poseidon wrong round constants: ${o}`);
    return o.map((d) => {
      if (typeof d != "bigint" || !t.isValid(d))
        throw new Error(`Poseidon wrong round constant=${d}`);
      return t.create(d);
    });
  });
  if (!Array.isArray(e.mds) || e.mds.length !== e.t)
    throw new Error("Poseidon: wrong MDS matrix");
  const i = e.mds.map((o) => {
    if (!Array.isArray(o) || o.length !== e.t)
      throw new Error(`Poseidon MDS matrix row: ${o}`);
    return o.map((d) => {
      if (typeof d != "bigint")
        throw new Error(`Poseidon MDS matrix value=${d}`);
      return t.create(d);
    });
  });
  return Object.freeze({ ...e, rounds: s, sboxFn: n, roundConstants: c, mds: i });
}
function T2(e, t) {
  if (typeof t != "number")
    throw new Error("poseidonSplitConstants: wrong t");
  if (!Array.isArray(e) || e.length % t)
    throw new Error("poseidonSplitConstants: wrong rc");
  const a = [];
  let r = [];
  for (let n = 0; n < e.length; n++)
    r.push(e[n]), r.length === t && (a.push(r), r = []);
  return a;
}
function Df(e) {
  const { t, Fp: a, rounds: r, sboxFn: n, reversePartialPowIdx: s } = Zf(e), c = Math.floor(e.roundsFull / 2), i = s ? t - 1 : 0, o = (f, u, l) => (f = f.map((b, p) => a.add(b, e.roundConstants[l][p])), u ? f = f.map((b) => n(b)) : f[i] = n(f[i]), f = e.mds.map((b) => b.reduce((p, h, m) => a.add(p, a.mulN(h, f[m])), a.ZERO)), f), d = function(f) {
    if (!Array.isArray(f) || f.length !== t)
      throw new Error(`Poseidon: wrong values (expected array of bigints with length ${t})`);
    f = f.map((l) => {
      if (typeof l != "bigint")
        throw new Error(`Poseidon: wrong value=${l} (${typeof l})`);
      return a.create(l);
    });
    let u = 0;
    for (let l = 0; l < c; l++)
      f = o(f, !0, u++);
    for (let l = 0; l < e.roundsPartial; l++)
      f = o(f, !1, u++);
    for (let l = 0; l < c; l++)
      f = o(f, !0, u++);
    if (u !== r)
      throw new Error(`Poseidon: wrong number of rounds: last round=${u}, total=${r}`);
    return f;
  };
  return d.roundConstants = e.roundConstants, d;
}
const S2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  poseidon: Df,
  splitConstants: T2,
  validateOpts: Zf
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const C2 = BigInt(0), fc = BigInt(1);
function A2(e, t) {
  const a = (n, s) => {
    const c = s.negate();
    return n ? c : s;
  }, r = (n) => {
    const s = Math.ceil(t / n) + 1, c = 2 ** (n - 1);
    return { windows: s, windowSize: c };
  };
  return {
    constTimeNegate: a,
    // non-const time multiplication ladder
    unsafeLadder(n, s) {
      let c = e.ZERO, i = n;
      for (; s > C2; )
        s & fc && (c = c.add(i)), i = i.double(), s >>= fc;
      return c;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(n, s) {
      const { windows: c, windowSize: i } = r(s), o = [];
      let d = n, f = d;
      for (let u = 0; u < c; u++) {
        f = d, o.push(f);
        for (let l = 1; l < i; l++)
          f = f.add(d), o.push(f);
        d = f.double();
      }
      return o;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(n, s, c) {
      const { windows: i, windowSize: o } = r(n);
      let d = e.ZERO, f = e.BASE;
      const u = BigInt(2 ** n - 1), l = 2 ** n, b = BigInt(n);
      for (let p = 0; p < i; p++) {
        const h = p * o;
        let m = Number(c & u);
        c >>= b, m > o && (m -= l, c += fc);
        const y = h, v = h + Math.abs(m) - 1, g = p % 2 !== 0, T = m < 0;
        m === 0 ? f = f.add(a(g, s[y])) : d = d.add(a(T, s[v]));
      }
      return { p: d, f };
    },
    wNAFCached(n, s, c, i) {
      const o = n._WINDOW_SIZE || 1;
      let d = s.get(n);
      return d || (d = this.precomputeWindow(n, o), o !== 1 && s.set(n, i(d))), this.wNAF(o, d, c);
    }
  };
}
function Bf(e) {
  return Fs(e.Fp), vn(e, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...Li(e.n, e.nBitLength),
    ...e,
    p: e.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function O2(e) {
  const t = Bf(e);
  vn(t, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: a, Fp: r, a: n } = t;
  if (a) {
    if (!r.eql(n, r.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof a != "object" || typeof a.beta != "bigint" || typeof a.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...t });
}
const { bytesToNumberBE: I2, hexToBytes: N2 } = C1, Zt = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(e = "") {
      super(e);
    }
  },
  _parseInt(e) {
    const { Err: t } = Zt;
    if (e.length < 2 || e[0] !== 2)
      throw new t("Invalid signature integer tag");
    const a = e[1], r = e.subarray(2, a + 2);
    if (!a || r.length !== a)
      throw new t("Invalid signature integer: wrong length");
    if (r[0] & 128)
      throw new t("Invalid signature integer: negative");
    if (r[0] === 0 && !(r[1] & 128))
      throw new t("Invalid signature integer: unnecessary leading zero");
    return { d: I2(r), l: e.subarray(a + 2) };
  },
  toSig(e) {
    const { Err: t } = Zt, a = typeof e == "string" ? N2(e) : e;
    if (!(a instanceof Uint8Array))
      throw new Error("ui8a expected");
    let r = a.length;
    if (r < 2 || a[0] != 48)
      throw new t("Invalid signature tag");
    if (a[1] !== r - 2)
      throw new t("Invalid signature: incorrect length");
    const { d: n, l: s } = Zt._parseInt(a.subarray(2)), { d: c, l: i } = Zt._parseInt(s);
    if (i.length)
      throw new t("Invalid signature: left bytes after parsing");
    return { r: n, s: c };
  },
  hexFromSig(e) {
    const t = (d) => Number.parseInt(d[0], 16) & 8 ? "00" + d : d, a = (d) => {
      const f = d.toString(16);
      return f.length & 1 ? `0${f}` : f;
    }, r = t(a(e.s)), n = t(a(e.r)), s = r.length / 2, c = n.length / 2, i = a(s), o = a(c);
    return `30${a(c + s + 4)}02${o}${n}02${i}${r}`;
  }
}, ze = BigInt(0), fe = BigInt(1), pt = BigInt(2), as = BigInt(3), Yo = BigInt(4);
function Ff(e) {
  const t = O2(e), { Fp: a } = t, r = t.toBytes || ((p, h, m) => {
    const y = h.toAffine();
    return Ja(Uint8Array.from([4]), a.toBytes(y.x), a.toBytes(y.y));
  }), n = t.fromBytes || ((p) => {
    const h = p.subarray(1), m = a.fromBytes(h.subarray(0, a.BYTES)), y = a.fromBytes(h.subarray(a.BYTES, 2 * a.BYTES));
    return { x: m, y };
  });
  function s(p) {
    const { a: h, b: m } = t, y = a.sqr(p), v = a.mul(y, p);
    return a.add(a.add(v, a.mul(p, h)), m);
  }
  if (!a.eql(a.sqr(t.Gy), s(t.Gx)))
    throw new Error("bad generator point: equation left != right");
  function c(p) {
    return typeof p == "bigint" && ze < p && p < t.n;
  }
  function i(p) {
    if (!c(p))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function o(p) {
    const { allowedPrivateKeyLengths: h, nByteLength: m, wrapPrivateKey: y, n: v } = t;
    if (h && typeof p != "bigint") {
      if (p instanceof Uint8Array && (p = Mt(p)), typeof p != "string" || !h.includes(p.length))
        throw new Error("Invalid key");
      p = p.padStart(m * 2, "0");
    }
    let g;
    try {
      g = typeof p == "bigint" ? p : Ne(je("private key", p, m));
    } catch {
      throw new Error(`private key must be ${m} bytes, hex or bigint, not ${typeof p}`);
    }
    return y && (g = xe(g, v)), i(g), g;
  }
  const d = /* @__PURE__ */ new Map();
  function f(p) {
    if (!(p instanceof u))
      throw new Error("ProjectivePoint expected");
  }
  class u {
    constructor(h, m, y) {
      if (this.px = h, this.py = m, this.pz = y, h == null || !a.isValid(h))
        throw new Error("x required");
      if (m == null || !a.isValid(m))
        throw new Error("y required");
      if (y == null || !a.isValid(y))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(h) {
      const { x: m, y } = h || {};
      if (!h || !a.isValid(m) || !a.isValid(y))
        throw new Error("invalid affine point");
      if (h instanceof u)
        throw new Error("projective point not allowed");
      const v = (g) => a.eql(g, a.ZERO);
      return v(m) && v(y) ? u.ZERO : new u(m, y, a.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(h) {
      const m = a.invertBatch(h.map((y) => y.pz));
      return h.map((y, v) => y.toAffine(m[v])).map(u.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(h) {
      const m = u.fromAffine(n(je("pointHex", h)));
      return m.assertValidity(), m;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(h) {
      return u.BASE.multiply(o(h));
    }
    // "Private method", don't use it directly
    _setWindowSize(h) {
      this._WINDOW_SIZE = h, d.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (t.allowInfinityPoint)
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: h, y: m } = this.toAffine();
      if (!a.isValid(h) || !a.isValid(m))
        throw new Error("bad point: x or y not FE");
      const y = a.sqr(m), v = s(h);
      if (!a.eql(y, v))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: h } = this.toAffine();
      if (a.isOdd)
        return !a.isOdd(h);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(h) {
      f(h);
      const { px: m, py: y, pz: v } = this, { px: g, py: T, pz: Z } = h, _ = a.eql(a.mul(m, Z), a.mul(g, v)), w = a.eql(a.mul(y, Z), a.mul(T, v));
      return _ && w;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new u(this.px, a.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: h, b: m } = t, y = a.mul(m, as), { px: v, py: g, pz: T } = this;
      let Z = a.ZERO, _ = a.ZERO, w = a.ZERO, O = a.mul(v, v), I = a.mul(g, g), S = a.mul(T, T), C = a.mul(v, g);
      return C = a.add(C, C), w = a.mul(v, T), w = a.add(w, w), Z = a.mul(h, w), _ = a.mul(y, S), _ = a.add(Z, _), Z = a.sub(I, _), _ = a.add(I, _), _ = a.mul(Z, _), Z = a.mul(C, Z), w = a.mul(y, w), S = a.mul(h, S), C = a.sub(O, S), C = a.mul(h, C), C = a.add(C, w), w = a.add(O, O), O = a.add(w, O), O = a.add(O, S), O = a.mul(O, C), _ = a.add(_, O), S = a.mul(g, T), S = a.add(S, S), O = a.mul(S, C), Z = a.sub(Z, O), w = a.mul(S, I), w = a.add(w, w), w = a.add(w, w), new u(Z, _, w);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(h) {
      f(h);
      const { px: m, py: y, pz: v } = this, { px: g, py: T, pz: Z } = h;
      let _ = a.ZERO, w = a.ZERO, O = a.ZERO;
      const I = t.a, S = a.mul(t.b, as);
      let C = a.mul(m, g), X = a.mul(y, T), ne = a.mul(v, Z), D = a.add(m, y), E = a.add(g, T);
      D = a.mul(D, E), E = a.add(C, X), D = a.sub(D, E), E = a.add(m, v);
      let A = a.add(g, Z);
      return E = a.mul(E, A), A = a.add(C, ne), E = a.sub(E, A), A = a.add(y, v), _ = a.add(T, Z), A = a.mul(A, _), _ = a.add(X, ne), A = a.sub(A, _), O = a.mul(I, E), _ = a.mul(S, ne), O = a.add(_, O), _ = a.sub(X, O), O = a.add(X, O), w = a.mul(_, O), X = a.add(C, C), X = a.add(X, C), ne = a.mul(I, ne), E = a.mul(S, E), X = a.add(X, ne), ne = a.sub(C, ne), ne = a.mul(I, ne), E = a.add(E, ne), C = a.mul(X, E), w = a.add(w, C), C = a.mul(A, E), _ = a.mul(D, _), _ = a.sub(_, C), C = a.mul(D, X), O = a.mul(A, O), O = a.add(O, C), new u(_, w, O);
    }
    subtract(h) {
      return this.add(h.negate());
    }
    is0() {
      return this.equals(u.ZERO);
    }
    wNAF(h) {
      return b.wNAFCached(this, d, h, (m) => {
        const y = a.invertBatch(m.map((v) => v.pz));
        return m.map((v, g) => v.toAffine(y[g])).map(u.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(h) {
      const m = u.ZERO;
      if (h === ze)
        return m;
      if (i(h), h === fe)
        return this;
      const { endo: y } = t;
      if (!y)
        return b.unsafeLadder(this, h);
      let { k1neg: v, k1: g, k2neg: T, k2: Z } = y.splitScalar(h), _ = m, w = m, O = this;
      for (; g > ze || Z > ze; )
        g & fe && (_ = _.add(O)), Z & fe && (w = w.add(O)), O = O.double(), g >>= fe, Z >>= fe;
      return v && (_ = _.negate()), T && (w = w.negate()), w = new u(a.mul(w.px, y.beta), w.py, w.pz), _.add(w);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(h) {
      i(h);
      let m = h, y, v;
      const { endo: g } = t;
      if (g) {
        const { k1neg: T, k1: Z, k2neg: _, k2: w } = g.splitScalar(m);
        let { p: O, f: I } = this.wNAF(Z), { p: S, f: C } = this.wNAF(w);
        O = b.constTimeNegate(T, O), S = b.constTimeNegate(_, S), S = new u(a.mul(S.px, g.beta), S.py, S.pz), y = O.add(S), v = I.add(C);
      } else {
        const { p: T, f: Z } = this.wNAF(m);
        y = T, v = Z;
      }
      return u.normalizeZ([y, v])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(h, m, y) {
      const v = u.BASE, g = (Z, _) => _ === ze || _ === fe || !Z.equals(v) ? Z.multiplyUnsafe(_) : Z.multiply(_), T = g(this, m).add(g(h, y));
      return T.is0() ? void 0 : T;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z) ∋ (x=x/z, y=y/z)
    toAffine(h) {
      const { px: m, py: y, pz: v } = this, g = this.is0();
      h == null && (h = g ? a.ONE : a.inv(v));
      const T = a.mul(m, h), Z = a.mul(y, h), _ = a.mul(v, h);
      if (g)
        return { x: a.ZERO, y: a.ZERO };
      if (!a.eql(_, a.ONE))
        throw new Error("invZ was invalid");
      return { x: T, y: Z };
    }
    isTorsionFree() {
      const { h, isTorsionFree: m } = t;
      if (h === fe)
        return !0;
      if (m)
        return m(u, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h, clearCofactor: m } = t;
      return h === fe ? this : m ? m(u, this) : this.multiplyUnsafe(t.h);
    }
    toRawBytes(h = !0) {
      return this.assertValidity(), r(u, this, h);
    }
    toHex(h = !0) {
      return Mt(this.toRawBytes(h));
    }
  }
  u.BASE = new u(t.Gx, t.Gy, a.ONE), u.ZERO = new u(a.ZERO, a.ONE, a.ZERO);
  const l = t.nBitLength, b = A2(u, t.endo ? Math.ceil(l / 2) : l);
  return {
    CURVE: t,
    ProjectivePoint: u,
    normPrivateKeyToScalar: o,
    weierstrassEquation: s,
    isWithinCurveOrder: c
  };
}
function R2(e) {
  const t = Bf(e);
  return vn(t, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...t });
}
function Uf(e) {
  const t = R2(e), { Fp: a, n: r } = t, n = a.BYTES + 1, s = 2 * a.BYTES + 1;
  function c(E) {
    return ze < E && E < a.ORDER;
  }
  function i(E) {
    return xe(E, r);
  }
  function o(E) {
    return Hc(E, r);
  }
  const { ProjectivePoint: d, normPrivateKeyToScalar: f, weierstrassEquation: u, isWithinCurveOrder: l } = Ff({
    ...t,
    toBytes(E, A, H) {
      const Q = A.toAffine(), ae = a.toBytes(Q.x), _e = Ja;
      return H ? _e(Uint8Array.from([A.hasEvenY() ? 2 : 3]), ae) : _e(Uint8Array.from([4]), ae, a.toBytes(Q.y));
    },
    fromBytes(E) {
      const A = E.length, H = E[0], Q = E.subarray(1);
      if (A === n && (H === 2 || H === 3)) {
        const ae = Ne(Q);
        if (!c(ae))
          throw new Error("Point is not on curve");
        const _e = u(ae);
        let Be = a.sqrt(_e);
        const Pe = (Be & fe) === fe;
        return (H & 1) === 1 !== Pe && (Be = a.neg(Be)), { x: ae, y: Be };
      } else if (A === s && H === 4) {
        const ae = a.fromBytes(Q.subarray(0, a.BYTES)), _e = a.fromBytes(Q.subarray(a.BYTES, 2 * a.BYTES));
        return { x: ae, y: _e };
      } else
        throw new Error(`Point of length ${A} was invalid. Expected ${n} compressed bytes or ${s} uncompressed bytes`);
    }
  }), b = (E) => Mt(Ha(E, t.nByteLength));
  function p(E) {
    const A = r >> fe;
    return E > A;
  }
  function h(E) {
    return p(E) ? i(-E) : E;
  }
  const m = (E, A, H) => Ne(E.slice(A, H));
  class y {
    constructor(A, H, Q) {
      this.r = A, this.s = H, this.recovery = Q, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(A) {
      const H = t.nByteLength;
      return A = je("compactSignature", A, H * 2), new y(m(A, 0, H), m(A, H, 2 * H));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(A) {
      const { r: H, s: Q } = Zt.toSig(je("DER", A));
      return new y(H, Q);
    }
    assertValidity() {
      if (!l(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!l(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(A) {
      return new y(this.r, this.s, A);
    }
    recoverPublicKey(A) {
      const { r: H, s: Q, recovery: ae } = this, _e = w(je("msgHash", A));
      if (ae == null || ![0, 1, 2, 3].includes(ae))
        throw new Error("recovery id invalid");
      const Be = ae === 2 || ae === 3 ? H + t.n : H;
      if (Be >= a.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const Pe = ae & 1 ? "03" : "02", ra = d.fromHex(Pe + b(Be)), Ct = o(Be), Na = i(-_e * Ct), vr = i(Q * Ct), At = d.BASE.multiplyAndAddUnsafe(ra, Na, vr);
      if (!At)
        throw new Error("point at infinify");
      return At.assertValidity(), At;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return p(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new y(this.r, i(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return Ht(this.toDERHex());
    }
    toDERHex() {
      return Zt.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return Ht(this.toCompactHex());
    }
    toCompactHex() {
      return b(this.r) + b(this.s);
    }
  }
  const v = {
    isValidPrivateKey(E) {
      try {
        return f(E), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: f,
    /**
     * Produces cryptographically secure private key from random of size (nBitLength+64)
     * as per FIPS 186 B.4.1 with modulo bias being neglible.
     */
    randomPrivateKey: () => {
      const E = t.randomBytes(a.BYTES + 8), A = x2(E, r);
      return Ha(A, t.nByteLength);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(E = 8, A = d.BASE) {
      return A._setWindowSize(E), A.multiply(BigInt(3)), A;
    }
  };
  function g(E, A = !0) {
    return d.fromPrivateKey(E).toRawBytes(A);
  }
  function T(E) {
    const A = E instanceof Uint8Array, H = typeof E == "string", Q = (A || H) && E.length;
    return A ? Q === n || Q === s : H ? Q === 2 * n || Q === 2 * s : E instanceof d;
  }
  function Z(E, A, H = !0) {
    if (T(E))
      throw new Error("first arg must be private key");
    if (!T(A))
      throw new Error("second arg must be public key");
    return d.fromHex(A).multiply(f(E)).toRawBytes(H);
  }
  const _ = t.bits2int || function(E) {
    const A = Ne(E), H = E.length * 8 - t.nBitLength;
    return H > 0 ? A >> BigInt(H) : A;
  }, w = t.bits2int_modN || function(E) {
    return i(_(E));
  }, O = Zs(t.nBitLength);
  function I(E) {
    if (typeof E != "bigint")
      throw new Error("bigint expected");
    if (!(ze <= E && E < O))
      throw new Error(`bigint expected < 2^${t.nBitLength}`);
    return Ha(E, t.nByteLength);
  }
  function S(E, A, H = C) {
    if (["recovered", "canonical"].some((na) => na in H))
      throw new Error("sign() legacy options not supported");
    const { hash: Q, randomBytes: ae } = t;
    let { lowS: _e, prehash: Be, extraEntropy: Pe } = H;
    _e == null && (_e = !0), E = je("msgHash", E), Be && (E = je("prehashed msgHash", Q(E)));
    const ra = w(E), Ct = f(A), Na = [I(Ct), I(ra)];
    if (Pe != null) {
      const na = Pe === !0 ? ae(a.BYTES) : Pe;
      Na.push(je("extraEntropy", na, a.BYTES));
    }
    const vr = Ja(...Na), At = ra;
    function sc(na) {
      const Ra = _(na);
      if (!l(Ra))
        return;
      const Ot = o(Ra), wr = d.BASE.multiply(Ra).toAffine(), jn = i(wr.x);
      if (jn === ze)
        return;
      const Zn = i(Ot * i(At + jn * Ct));
      if (Zn === ze)
        return;
      let $o = (wr.x === jn ? 0 : 2) | Number(wr.y & fe), zo = Zn;
      return _e && p(Zn) && (zo = h(Zn), $o ^= 1), new y(jn, zo, $o);
    }
    return { seed: vr, k2sig: sc };
  }
  const C = { lowS: t.lowS, prehash: !1 }, X = { lowS: t.lowS, prehash: !1 };
  function ne(E, A, H = C) {
    const { seed: Q, k2sig: ae } = S(E, A, H);
    return Tf(t.hash.outputLen, t.nByteLength, t.hmac)(Q, ae);
  }
  d.BASE._setWindowSize(8);
  function D(E, A, H, Q = X) {
    const ae = E;
    if (A = je("msgHash", A), H = je("publicKey", H), "strict" in Q)
      throw new Error("options.strict was renamed to lowS");
    const { lowS: _e, prehash: Be } = Q;
    let Pe, ra;
    try {
      if (typeof ae == "string" || ae instanceof Uint8Array)
        try {
          Pe = y.fromDER(ae);
        } catch (Ot) {
          if (!(Ot instanceof Zt.Err))
            throw Ot;
          Pe = y.fromCompact(ae);
        }
      else if (typeof ae == "object" && typeof ae.r == "bigint" && typeof ae.s == "bigint") {
        const { r: Ot, s: wr } = ae;
        Pe = new y(Ot, wr);
      } else
        throw new Error("PARSE");
      ra = d.fromHex(H);
    } catch (Ot) {
      if (Ot.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1;
    }
    if (_e && Pe.hasHighS())
      return !1;
    Be && (A = t.hash(A));
    const { r: Ct, s: Na } = Pe, vr = w(A), At = o(Na), sc = i(vr * At), na = i(Ct * At), Ra = d.BASE.multiplyAndAddUnsafe(ra, sc, na)?.toAffine();
    return Ra ? i(Ra.x) === Ct : !1;
  }
  return {
    CURVE: t,
    getPublicKey: g,
    getSharedSecret: Z,
    sign: ne,
    verify: D,
    ProjectivePoint: d,
    Signature: y,
    utils: v
  };
}
function $f(e, t) {
  const a = e.ORDER;
  let r = ze;
  for (let l = a - fe; l % pt === ze; l /= pt)
    r += fe;
  const n = r, s = (a - fe) / pt ** n, c = (s - fe) / pt, i = pt ** n - fe, o = pt ** (n - fe), d = e.pow(t, s), f = e.pow(t, (s + fe) / pt);
  let u = (l, b) => {
    let p = d, h = e.pow(b, i), m = e.sqr(h);
    m = e.mul(m, b);
    let y = e.mul(l, m);
    y = e.pow(y, c), y = e.mul(y, h), h = e.mul(y, b), m = e.mul(y, l);
    let v = e.mul(m, h);
    y = e.pow(v, o);
    let g = e.eql(y, e.ONE);
    h = e.mul(m, f), y = e.mul(v, p), m = e.cmov(h, m, g), v = e.cmov(y, v, g);
    for (let T = n; T > fe; T--) {
      let Z = pt ** (T - pt), _ = e.pow(v, Z);
      const w = e.eql(_, e.ONE);
      h = e.mul(m, p), p = e.mul(p, p), _ = e.mul(v, p), m = e.cmov(h, m, w), v = e.cmov(_, v, w);
    }
    return { isValid: g, value: m };
  };
  if (e.ORDER % Yo === as) {
    const l = (e.ORDER - as) / Yo, b = e.sqrt(e.neg(t));
    u = (p, h) => {
      let m = e.sqr(h);
      const y = e.mul(p, h);
      m = e.mul(m, y);
      let v = e.pow(m, l);
      v = e.mul(v, y);
      const g = e.mul(v, b), T = e.mul(e.sqr(v), h), Z = e.eql(T, p);
      let _ = e.cmov(g, v, Z);
      return { isValid: Z, value: _ };
    };
  }
  return u;
}
function P2(e, t) {
  if (Fs(e), !e.isValid(t.A) || !e.isValid(t.B) || !e.isValid(t.Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const a = $f(e, t.Z);
  if (!e.isOdd)
    throw new Error("Fp.isOdd is not implemented!");
  return (r) => {
    let n, s, c, i, o, d, f, u;
    n = e.sqr(r), n = e.mul(n, t.Z), s = e.sqr(n), s = e.add(s, n), c = e.add(s, e.ONE), c = e.mul(c, t.B), i = e.cmov(t.Z, e.neg(s), !e.eql(s, e.ZERO)), i = e.mul(i, t.A), s = e.sqr(c), d = e.sqr(i), o = e.mul(d, t.A), s = e.add(s, o), s = e.mul(s, c), d = e.mul(d, i), o = e.mul(d, t.B), s = e.add(s, o), f = e.mul(n, c);
    const { isValid: l, value: b } = a(s, d);
    u = e.mul(n, r), u = e.mul(u, b), f = e.cmov(f, c, l), u = e.cmov(u, b, l);
    const p = e.isOdd(r) === e.isOdd(u);
    return u = e.cmov(e.neg(u), u, p), f = e.div(f, i), { x: f, y: u };
  };
}
const L2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DER: Zt,
  SWUFpSqrtRatio: $f,
  mapToCurveSimpleSWU: P2,
  weierstrass: Uf,
  weierstrassPoints: Ff
}, Symbol.toStringTag, { value: "Module" }));
function Vc(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`Wrong positive integer: ${e}`);
}
function j2(e) {
  if (typeof e != "boolean")
    throw new Error(`Expected boolean, not ${e}`);
}
function zf(e, ...t) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function Z2(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Vc(e.outputLen), Vc(e.blockLen);
}
function D2(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function B2(e, t) {
  zf(e);
  const a = t.outputLen;
  if (e.length < a)
    throw new Error(`digestInto() expects output buffer of length at least ${a}`);
}
const Bn = {
  number: Vc,
  bool: j2,
  bytes: zf,
  hash: Z2,
  exists: D2,
  output: B2
}, uc = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const F2 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!F2)
  throw new Error("Non little-endian hardware is not supported");
Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function U2(e) {
  if (typeof e != "string")
    throw new TypeError(`utf8ToBytes expected string, got ${typeof e}`);
  return new TextEncoder().encode(e);
}
function $2(e) {
  if (typeof e == "string" && (e = U2(e)), !(e instanceof Uint8Array))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);
  return e;
}
function z2(...e) {
  if (!e.every((r) => r instanceof Uint8Array))
    throw new Error("Uint8Array list expected");
  if (e.length === 1)
    return e[0];
  const t = e.reduce((r, n) => r + n.length, 0), a = new Uint8Array(t);
  for (let r = 0, n = 0; r < e.length; r++) {
    const s = e[r];
    a.set(s, n), n += s.length;
  }
  return a;
}
class M2 {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function H2(e = 32) {
  if (uc && typeof uc.getRandomValues == "function")
    return uc.getRandomValues(new Uint8Array(e));
  throw new Error("crypto.getRandomValues must be defined");
}
class Mf extends M2 {
  constructor(t, a) {
    super(), this.finished = !1, this.destroyed = !1, Bn.hash(t);
    const r = $2(a);
    if (this.iHash = t.create(), typeof this.iHash.update != "function")
      throw new TypeError("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const n = this.blockLen, s = new Uint8Array(n);
    s.set(r.length > n ? t.create().update(r).digest() : r);
    for (let c = 0; c < s.length; c++)
      s[c] ^= 54;
    this.iHash.update(s), this.oHash = t.create();
    for (let c = 0; c < s.length; c++)
      s[c] ^= 106;
    this.oHash.update(s), s.fill(0);
  }
  update(t) {
    return Bn.exists(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    Bn.exists(this), Bn.bytes(t, this.outputLen), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: a, iHash: r, finished: n, destroyed: s, blockLen: c, outputLen: i } = this;
    return t = t, t.finished = n, t.destroyed = s, t.blockLen = c, t.outputLen = i, t.oHash = a._cloneInto(t.oHash), t.iHash = r._cloneInto(t.iHash), t;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const Hf = (e, t, a) => new Mf(e, t).update(a).digest();
Hf.create = (e, t) => new Mf(e, t);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function V2(e) {
  return {
    hash: e,
    hmac: (t, ...a) => Hf(e, t, z2(...a)),
    randomBytes: H2
  };
}
const rs = BigInt("3618502788666131213697322783095070105526743751716087489154079457884512865583"), Vf = 252;
function Jo(e) {
  for (; e[0] === 0; )
    e = e.subarray(1);
  const t = e.length * 8 - Vf, a = Ne(e);
  return t > 0 ? a >> BigInt(t) : a;
}
function qf(e) {
  return typeof e == "string" && (e = Bi(e), e.length & 1 && (e = "0" + e)), Ht(e);
}
const Oa = Uf({
  a: BigInt(1),
  b: BigInt("3141592653589793238462643383279502884197169399375105820974944592307816406665"),
  Fp: ji(BigInt("0x800000000000011000000000000000000000000000000000000000000000001")),
  n: rs,
  nBitLength: Vf,
  Gx: BigInt("874739451078007766457464989774322083649278607533249481151382481072868806602"),
  Gy: BigInt("152666792071518830868575557812948353041420400780739481342941381225525861407"),
  h: BigInt(1),
  lowS: !1,
  ...V2(Pi),
  bits2int: Jo,
  bits2int_modN: (e) => {
    const t = Ne(e).toString(16);
    return t.length === 63 && (e = qf(t + "0")), xe(Jo(e), rs);
  }
}), q2 = Oa;
function ba(e) {
  return je("", typeof e == "string" ? qf(e) : e);
}
function Zi(e) {
  return Mt(ba(e)).padStart(64, "0");
}
function Kf(e, t = !1) {
  return Oa.getPublicKey(Zi(e), t);
}
function K2(e, t) {
  return Oa.getSharedSecret(Zi(e), t);
}
function Sr(e, t, a) {
  return Oa.sign(ba(e), Zi(t), a);
}
function W2(e, t, a) {
  const r = e instanceof Wf ? e : ba(e);
  return Oa.verify(r, ba(t), ba(a));
}
const { CURVE: G2, ProjectivePoint: ja, Signature: Wf, utils: Di } = Oa;
function Gf(e) {
  return `0x${Mt(e.subarray(1)).replace(/^0+/gm, "")}`;
}
function Bi(e) {
  return e.replace(/^0x/i, "");
}
function Y2(e) {
  return `0x${e.toString(16)}`;
}
function Yf(e) {
  const t = ba(e), a = 2n ** 256n, r = a - xe(a, rs);
  for (let n = 0; ; n++) {
    const s = qc(Ja(t, Ni(BigInt(n))));
    if (s < r)
      return xe(s, rs).toString(16);
    if (n === 1e5)
      throw new Error("grindKey is broken: tried 100k vals");
  }
}
function Fi(e) {
  return Gf(Kf(e, !0));
}
function J2(e) {
  if (e = Bi(e), e.length !== 130)
    throw new Error("Wrong ethereum signature");
  return Yf(e.substring(0, 64));
}
const X2 = 2n ** 31n - 1n, Fn = (e) => Number(e & X2);
function Q2(e, t, a, r) {
  const n = Fn(qc(e)), s = Fn(qc(t)), c = js(Bi(a));
  return `m/2645'/${n}'/${s}'/${Fn(c)}'/${Fn(c >> 31n)}'/${r}`;
}
const Ur = [
  new ja(2089986280348253421170679821480865132823066470938446095505822317253594081284n, 1713931329540660377023406109199410414810705867260802078187082345529207694986n, 1n),
  new ja(996781205833008774514500082376783249102396023663454813447423147977397232763n, 1668503676786377725805489344771023921079126552019160156920634619255970485781n, 1n),
  new ja(2251563274489750535117886426533222435294046428347329203627021249169616184184n, 1798716007562728905295480679789526322175868328062420237419143593021674992973n, 1n),
  new ja(2138414695194151160943305727036575959195309218611738193261179310511854807447n, 113410276730064486255102093846540133784865286929052426931474106396135072156n, 1n),
  new ja(2379962749567351885752724891227938183011949129833673362440656643086021394946n, 776496453633298175483985398648758586525933812536653089401905292063708816422n, 1n)
];
function Jf(e, t) {
  const a = [];
  let r = e;
  for (let n = 0; n < 248; n++)
    a.push(r), r = r.double();
  r = t;
  for (let n = 0; n < 4; n++)
    a.push(r), r = r.double();
  return a;
}
const eh = Jf(Ur[1], Ur[2]), th = Jf(Ur[3], Ur[4]);
function Xf(e) {
  let t;
  if (typeof e == "bigint")
    t = e;
  else if (typeof e == "number") {
    if (!Number.isSafeInteger(e))
      throw new Error(`Invalid pedersenArg: ${e}`);
    t = BigInt(e);
  } else
    t = Ne(ba(e));
  if (!(0n <= t && t < Oa.CURVE.Fp.ORDER))
    throw new Error(`PedersenArg should be 0 <= value < CURVE.P: ${t}`);
  return t;
}
function Xo(e, t, a) {
  let r = Xf(t);
  for (let n = 0; n < 252; n++) {
    const s = a[n];
    if (s.equals(e))
      throw new Error("Same point");
    (r & 1n) !== 0n && (e = e.add(s)), r >>= 1n;
  }
  return e;
}
function fr(e, t) {
  let a = Ur[0];
  return a = Xo(a, e, eh), a = Xo(a, t, th), Gf(a.toRawBytes(!0));
}
function ah(e, t = fr) {
  if (!Array.isArray(e) || e.length < 1)
    throw new Error("data should be array of at least 1 element");
  return e.length === 1 ? Y2(Xf(e[0])) : Array.from(e).reverse().reduce((a, r) => t(r, a));
}
const rh = (e, t = fr) => [0, ...e, e.length].reduce((a, r) => t(a, r)), nh = Zs(250), wn = (e) => Ne(u2(e)) & nh, qc = (e) => Ne(Pi(e)), sh = ji(BigInt("14474011154664525231415395255581126252639794253786371766033694892385558855681")), Qf = ji(BigInt("3618502788666131213697322783095070105623107215331596699973092056135872020481"));
function Kc(e, t, a) {
  const r = e.fromBytes(Pi(Af(`${t}${a}`)));
  return e.create(r);
}
function eu(e, t, a, r = 0) {
  const n = [], s = [];
  for (let c = 0; c < a; c++)
    n.push(Kc(e, `${t}x`, r * a + c)), s.push(Kc(e, `${t}y`, r * a + c));
  if ((/* @__PURE__ */ new Set([...n, ...s])).size !== 2 * a)
    throw new Error("X and Y values are not distinct");
  return n.map((c) => s.map((i) => e.inv(e.sub(c, i))));
}
const ch = [
  [3, 1, 1],
  [1, -1, 1],
  [1, 1, -2]
].map((e) => e.map(BigInt));
function Ui(e, t) {
  if (Fs(e.Fp), !Number.isSafeInteger(e.rate) || !Number.isSafeInteger(e.capacity))
    throw new Error(`Wrong poseidon opts: ${e}`);
  const a = e.rate + e.capacity, r = e.roundsFull + e.roundsPartial, n = [];
  for (let c = 0; c < r; c++) {
    const i = [];
    for (let o = 0; o < a; o++)
      i.push(Kc(e.Fp, "Hades", a * c + o));
    n.push(i);
  }
  const s = Df({
    ...e,
    t: a,
    sboxPower: 3,
    reversePartialPowIdx: !0,
    mds: t,
    roundConstants: n
  });
  return s.m = a, s.rate = e.rate, s.capacity = e.capacity, s;
}
function ih(e, t = 0) {
  const a = e.rate + e.capacity;
  if (!Number.isSafeInteger(t))
    throw new Error(`Wrong mdsAttempt=${t}`);
  return Ui(e, eu(e.Fp, "HadesMDS", a, t));
}
const En = Ui({ Fp: Qf, rate: 2, capacity: 1, roundsFull: 8, roundsPartial: 83 }, ch);
function tu(e, t, a = En) {
  return a([e, t, 2n])[0];
}
function oh(e, t, a = En) {
  return Ni(tu(Ne(e), Ne(t), a));
}
function dh(e, t = En) {
  return t([e, 0n, 1n])[0];
}
function Vt(e, t = En) {
  const { m: a, rate: r } = t;
  if (!Array.isArray(e))
    throw new Error("bigint array expected in values");
  const n = Array.from(e);
  for (n.push(1n); n.length % r !== 0; )
    n.push(0n);
  let s = new Array(a).fill(0n);
  for (let c = 0; c < n.length; c += r) {
    for (let i = 0; i < r; i++)
      s[i] += n[c + i];
    s = t(s);
  }
  return s[0];
}
const fh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CURVE: G2,
  Fp251: Qf,
  Fp253: sh,
  ProjectivePoint: ja,
  Signature: Wf,
  _poseidonMDS: eu,
  _starkCurve: q2,
  computeHashOnElements: rh,
  ethSigToPrivate: J2,
  getAccountPath: Q2,
  getPublicKey: Kf,
  getSharedSecret: K2,
  getStarkKey: Fi,
  grindKey: Yf,
  hashChain: ah,
  keccak: wn,
  pedersen: fr,
  poseidonBasic: Ui,
  poseidonCreate: ih,
  poseidonHash: tu,
  poseidonHashFunc: oh,
  poseidonHashMany: Vt,
  poseidonHashSingle: dh,
  poseidonSmall: En,
  sign: Sr,
  utils: Di,
  verify: W2
}, Symbol.toStringTag, { value: "Module" }));
function kn(e) {
  return uh.test(e);
}
var uh = /^-?[0-9]+$/;
function au(e) {
  return lh.test(e);
}
var lh = /^-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?$/;
function bh(e, t) {
  var a = parseFloat(e), r = String(a), n = Qo(e), s = Qo(r);
  if (n === s)
    return !0;
  if (t?.approx === !0) {
    var c = 14;
    if (!kn(e) && s.length >= c && n.startsWith(s.substring(0, c)))
      return !0;
  }
  return !1;
}
var Cr = /* @__PURE__ */ function(e) {
  return e.underflow = "underflow", e.overflow = "overflow", e.truncate_integer = "truncate_integer", e.truncate_float = "truncate_float", e;
}({});
function hh(e) {
  if (!bh(e, {
    approx: !1
  })) {
    if (kn(e))
      return Cr.truncate_integer;
    var t = parseFloat(e);
    return isFinite(t) ? t === 0 ? Cr.underflow : Cr.truncate_float : Cr.overflow;
  }
}
function Qo(e) {
  return e.replace(ph, "").replace(yh, "").replace(gh, "").replace(mh, "");
}
var ph = /[eE][+-]?\d+$/, mh = /^-?(0*)?/, yh = /\./, gh = /0+$/;
function Xa(e) {
  "@babel/helpers - typeof";
  return Xa = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Xa(e);
}
function _h(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function ed(e, t) {
  for (var a = 0; a < t.length; a++) {
    var r = t[a];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, ru(r.key), r);
  }
}
function vh(e, t, a) {
  return t && ed(e.prototype, t), a && ed(e, a), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function wh(e, t, a) {
  return t = ru(t), t in e ? Object.defineProperty(e, t, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = a, e;
}
function ru(e) {
  var t = Eh(e, "string");
  return Xa(t) === "symbol" ? t : String(t);
}
function Eh(e, t) {
  if (Xa(e) !== "object" || e === null)
    return e;
  var a = e[Symbol.toPrimitive];
  if (a !== void 0) {
    var r = a.call(e, t || "default");
    if (Xa(r) !== "object")
      return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var kh = /* @__PURE__ */ function() {
  function e(t) {
    if (_h(this, e), wh(this, "isLosslessNumber", !0), !au(t))
      throw new Error('Invalid number (value: "' + t + '")');
    this.value = t;
  }
  return vh(e, [{
    key: "valueOf",
    value: function() {
      var t = hh(this.value);
      if (t === void 0 || t === Cr.truncate_float)
        return parseFloat(this.value);
      if (kn(this.value))
        return BigInt(this.value);
      throw new Error("Cannot safely convert to number: " + "the value '".concat(this.value, "' would ").concat(t, " and become ").concat(parseFloat(this.value)));
    }
    /**
     * Get the value of the LosslessNumber as string.
     */
  }, {
    key: "toString",
    value: function() {
      return this.value;
    }
    // Note: we do NOT implement a .toJSON() method, and you should not implement
    // or use that, it cannot safely turn the numeric value in the string into
    // stringified JSON since it has to be parsed into a number first.
  }]), e;
}();
function xh(e) {
  return e && Xa(e) === "object" && e.isLosslessNumber === !0 || !1;
}
function Th(e) {
  return new kh(e);
}
function Sh(e) {
  return kn(e) ? BigInt(e) : parseFloat(e);
}
function Wc(e) {
  "@babel/helpers - typeof";
  return Wc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Wc(e);
}
function Ch(e, t) {
  return $i({
    "": e
  }, "", e, t);
}
function $i(e, t, a, r) {
  return Array.isArray(a) ? r.call(e, t, Oh(a, r)) : a && Wc(a) === "object" && !xh(a) ? r.call(e, t, Ah(a, r)) : r.call(e, t, a);
}
function Ah(e, t) {
  return Object.keys(e).forEach(function(a) {
    var r = $i(e, a, e[a], t);
    r !== void 0 ? e[a] = r : delete e[a];
  }), e;
}
function Oh(e, t) {
  for (var a = 0; a < e.length; a++)
    e[a] = $i(e, a + "", e[a], t);
  return e;
}
function Gc(e) {
  "@babel/helpers - typeof";
  return Gc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Gc(e);
}
function lc(e) {
  return Ph(e) || Rh(e) || Nh(e) || Ih();
}
function Ih() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Nh(e, t) {
  if (e) {
    if (typeof e == "string")
      return Yc(e, t);
    var a = Object.prototype.toString.call(e).slice(8, -1);
    if (a === "Object" && e.constructor && (a = e.constructor.name), a === "Map" || a === "Set")
      return Array.from(e);
    if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a))
      return Yc(e, t);
  }
}
function Rh(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null)
    return Array.from(e);
}
function Ph(e) {
  if (Array.isArray(e))
    return Yc(e);
}
function Yc(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var a = 0, r = new Array(t); a < t; a++)
    r[a] = e[a];
  return r;
}
function nu(e, t) {
  var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Th, r = 0, n = i();
  return p(n), m(), t ? Ch(n, t) : n;
  function s() {
    if (e.charCodeAt(r) === Fh) {
      r++, d();
      for (var D = {}, E = !0; r < e.length && e.charCodeAt(r) !== ad; ) {
        E ? E = !1 : (l(), d());
        var A = r, H = f();
        H === void 0 && g(), d(), b();
        var Q = i();
        Q === void 0 && I(), Object.prototype.hasOwnProperty.call(D, H) && !Jc(Q, D[H]) && T(H, A + 1), D[H] = Q;
      }
      return e.charCodeAt(r) !== ad && Z(), r++, D;
    }
  }
  function c() {
    if (e.charCodeAt(r) === Uh) {
      r++, d();
      for (var D = [], E = !0; r < e.length && e.charCodeAt(r) !== rd; ) {
        E ? E = !1 : l();
        var A = i();
        h(A), D.push(A);
      }
      return e.charCodeAt(r) !== rd && _(), r++, D;
    }
  }
  function i() {
    var D, E, A, H, Q, ae;
    d();
    var _e = (D = (E = (A = (H = (Q = (ae = f()) !== null && ae !== void 0 ? ae : u()) !== null && Q !== void 0 ? Q : s()) !== null && H !== void 0 ? H : c()) !== null && A !== void 0 ? A : o("true", !0)) !== null && E !== void 0 ? E : o("false", !1)) !== null && D !== void 0 ? D : o("null", null);
    return d(), _e;
  }
  function o(D, E) {
    if (e.slice(r, r + D.length) === D)
      return r += D.length, E;
  }
  function d() {
    for (; Lh(e.charCodeAt(r)); )
      r++;
  }
  function f() {
    if (e.charCodeAt(r) === bc) {
      r++;
      for (var D = ""; r < e.length && e.charCodeAt(r) !== bc; ) {
        if (e.charCodeAt(r) === Bh) {
          var E = e[r + 1], A = Dh[E];
          A !== void 0 ? (D += A, r++) : E === "u" ? Un(e.charCodeAt(r + 2)) && Un(e.charCodeAt(r + 3)) && Un(e.charCodeAt(r + 4)) && Un(e.charCodeAt(r + 5)) ? (D += String.fromCharCode(parseInt(e.slice(r + 2, r + 6), 16)), r += 5) : S(r) : O(r);
        } else
          Zh(e.charCodeAt(r)) ? D += e[r] : w(e[r]);
        r++;
      }
      return v(), r++, D;
    }
  }
  function u() {
    var D = r;
    if (e.charCodeAt(r) === nd && (r++, y(D)), e.charCodeAt(r) === zi)
      r++;
    else if (jh(e.charCodeAt(r)))
      for (r++; $n(e.charCodeAt(r)); )
        r++;
    if (e.charCodeAt(r) === Wh)
      for (r++, y(D); $n(e.charCodeAt(r)); )
        r++;
    if (e.charCodeAt(r) === Qh || e.charCodeAt(r) === Xh)
      for (r++, (e.charCodeAt(r) === nd || e.charCodeAt(r) === Vh) && r++, y(D); $n(e.charCodeAt(r)); )
        r++;
    if (r > D)
      return a(e.slice(D, r));
  }
  function l() {
    if (e.charCodeAt(r) !== Kh)
      throw new SyntaxError("Comma ',' expected after value ".concat(ne()));
    r++;
  }
  function b() {
    if (e.charCodeAt(r) !== Gh)
      throw new SyntaxError("Colon ':' expected after property name ".concat(ne()));
    r++;
  }
  function p(D) {
    if (D === void 0)
      throw new SyntaxError("JSON value expected ".concat(ne()));
  }
  function h(D) {
    if (D === void 0)
      throw new SyntaxError("Array item expected ".concat(ne()));
  }
  function m() {
    if (r < e.length)
      throw new SyntaxError("Expected end of input ".concat(ne()));
  }
  function y(D) {
    if (!$n(e.charCodeAt(r))) {
      var E = e.slice(D, r);
      throw new SyntaxError("Invalid number '".concat(E, "', expecting a digit ").concat(ne()));
    }
  }
  function v() {
    if (e.charCodeAt(r) !== bc)
      throw new SyntaxError(`End of string '"' expected `.concat(ne()));
  }
  function g() {
    throw new SyntaxError("Quoted object key expected ".concat(ne()));
  }
  function T(D, E) {
    throw new SyntaxError("Duplicate key '".concat(D, "' encountered at position ").concat(E));
  }
  function Z() {
    throw new SyntaxError("Quoted object key or end of object '}' expected ".concat(ne()));
  }
  function _() {
    throw new SyntaxError("Array item or end of array ']' expected ".concat(ne()));
  }
  function w(D) {
    throw new SyntaxError("Invalid character '".concat(D, "' ").concat(C()));
  }
  function O(D) {
    var E = e.slice(D, D + 2);
    throw new SyntaxError("Invalid escape character '".concat(E, "' ").concat(C()));
  }
  function I() {
    throw new SyntaxError("Object value expected after ':' ".concat(C()));
  }
  function S(D) {
    for (var E = D + 2; /\w/.test(e[E]); )
      E++;
    var A = e.slice(D, E);
    throw new SyntaxError("Invalid unicode character '".concat(A, "' ").concat(C()));
  }
  function C() {
    return "at position ".concat(r);
  }
  function X() {
    return r < e.length ? "but got '".concat(e[r], "'") : "but reached end of input";
  }
  function ne() {
    return X() + " " + C();
  }
}
function Lh(e) {
  return e === $h || e === zh || e === Mh || e === Hh;
}
function Un(e) {
  return e >= zi && e <= Mi || e >= Yh && e <= e5 || e >= Jh && e <= t5;
}
function $n(e) {
  return e >= zi && e <= Mi;
}
function jh(e) {
  return e >= qh && e <= Mi;
}
function Zh(e) {
  return e >= 32 && e <= 1114111;
}
function Jc(e, t) {
  if (e === t)
    return !0;
  if (Array.isArray(e) && Array.isArray(t))
    return e.length === t.length && e.every(function(r, n) {
      return Jc(r, t[n]);
    });
  if (td(e) && td(t)) {
    var a = lc(new Set([].concat(lc(Object.keys(e)), lc(Object.keys(t)))));
    return a.every(function(r) {
      return Jc(e[r], t[r]);
    });
  }
  return !1;
}
function td(e) {
  return Gc(e) === "object" && e !== null;
}
var Dh = {
  '"': '"',
  "\\": "\\",
  "/": "/",
  b: "\b",
  f: "\f",
  n: `
`,
  r: "\r",
  t: "	"
  // note that \u is handled separately in parseString()
}, Bh = 92, Fh = 123, ad = 125, Uh = 91, rd = 93, $h = 32, zh = 10, Mh = 9, Hh = 13, bc = 34, Vh = 43, nd = 45, zi = 48, qh = 49, Mi = 57, Kh = 44, Wh = 46, Gh = 58, Yh = 65, Jh = 97, Xh = 69, Qh = 101, e5 = 70, t5 = 102;
function ns(e) {
  "@babel/helpers - typeof";
  return ns = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, ns(e);
}
function su(e, t, a, r) {
  var n = a5(a), s = typeof t == "function" ? t.call({
    "": e
  }, "", e) : e;
  return c(s, "");
  function c(f, u) {
    if (Array.isArray(r)) {
      var l = r.find(function(p) {
        return p.test(f);
      });
      if (l) {
        var b = l.stringify(f);
        if (typeof b != "string" || !au(b))
          throw new Error("Invalid JSON number: output of a number stringifier must be a string containing a JSON number " + "(output: ".concat(b, ")"));
        return b;
      }
    }
    if (typeof f == "boolean" || typeof f == "number" || typeof f == "string" || f === null || f instanceof Date || f instanceof Boolean || f instanceof Number || f instanceof String)
      return JSON.stringify(f);
    if (f && f.isLosslessNumber || typeof f == "bigint")
      return f.toString();
    if (Array.isArray(f))
      return i(f, u);
    if (f && ns(f) === "object")
      return o(f, u);
  }
  function i(f, u) {
    if (f.length === 0)
      return "[]";
    for (var l = n ? u + n : void 0, b = n ? `[
` : "[", p = 0; p < f.length; p++) {
      var h = typeof t == "function" ? t.call(f, String(p), f[p]) : f[p];
      n && (b += l), typeof h < "u" && typeof h != "function" ? b += c(h, l) : b += "null", p < f.length - 1 && (b += n ? `,
` : ",");
    }
    return b += n ? `
` + u + "]" : "]", b;
  }
  function o(f, u) {
    if (typeof f.toJSON == "function")
      return su(f.toJSON(), t, a, void 0);
    var l = Array.isArray(t) ? t.map(String) : Object.keys(f);
    if (l.length === 0)
      return "{}";
    var b = n ? u + n : void 0, p = !0, h = n ? `{
` : "{";
    return l.forEach(function(m) {
      var y = typeof t == "function" ? t.call(f, m, f[m]) : f[m];
      if (d(m, y)) {
        p ? p = !1 : h += n ? `,
` : ",";
        var v = JSON.stringify(m);
        h += n ? b + v + ": " : v + ":", h += c(y, b);
      }
    }), h += n ? `
` + u + "}" : "}", h;
  }
  function d(f, u) {
    return typeof u < "u" && typeof u != "function" && ns(u) !== "symbol";
  }
}
function a5(e) {
  if (typeof e == "number")
    return " ".repeat(e);
  if (typeof e == "string" && e !== "")
    return e;
}
/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
const r5 = 4, sd = 0, cd = 1, n5 = 2;
function ur(e) {
  let t = e.length;
  for (; --t >= 0; )
    e[t] = 0;
}
const s5 = 0, cu = 1, c5 = 2, i5 = 3, o5 = 258, Hi = 29, xn = 256, $r = xn + 1 + Hi, Va = 30, Vi = 19, iu = 2 * $r + 1, da = 15, hc = 16, d5 = 7, qi = 256, ou = 16, du = 17, fu = 18, Xc = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
), Wn = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
), f5 = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
), uu = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), u5 = 512, gt = new Array(($r + 2) * 2);
ur(gt);
const Nr = new Array(Va * 2);
ur(Nr);
const zr = new Array(u5);
ur(zr);
const Mr = new Array(o5 - i5 + 1);
ur(Mr);
const Ki = new Array(Hi);
ur(Ki);
const ss = new Array(Va);
ur(ss);
function pc(e, t, a, r, n) {
  this.static_tree = e, this.extra_bits = t, this.extra_base = a, this.elems = r, this.max_length = n, this.has_stree = e && e.length;
}
let lu, bu, hu;
function mc(e, t) {
  this.dyn_tree = e, this.max_code = 0, this.stat_desc = t;
}
const pu = (e) => e < 256 ? zr[e] : zr[256 + (e >>> 7)], Hr = (e, t) => {
  e.pending_buf[e.pending++] = t & 255, e.pending_buf[e.pending++] = t >>> 8 & 255;
}, Ie = (e, t, a) => {
  e.bi_valid > hc - a ? (e.bi_buf |= t << e.bi_valid & 65535, Hr(e, e.bi_buf), e.bi_buf = t >> hc - e.bi_valid, e.bi_valid += a - hc) : (e.bi_buf |= t << e.bi_valid & 65535, e.bi_valid += a);
}, tt = (e, t, a) => {
  Ie(
    e,
    a[t * 2],
    a[t * 2 + 1]
    /*.Len*/
  );
}, mu = (e, t) => {
  let a = 0;
  do
    a |= e & 1, e >>>= 1, a <<= 1;
  while (--t > 0);
  return a >>> 1;
}, l5 = (e) => {
  e.bi_valid === 16 ? (Hr(e, e.bi_buf), e.bi_buf = 0, e.bi_valid = 0) : e.bi_valid >= 8 && (e.pending_buf[e.pending++] = e.bi_buf & 255, e.bi_buf >>= 8, e.bi_valid -= 8);
}, b5 = (e, t) => {
  const a = t.dyn_tree, r = t.max_code, n = t.stat_desc.static_tree, s = t.stat_desc.has_stree, c = t.stat_desc.extra_bits, i = t.stat_desc.extra_base, o = t.stat_desc.max_length;
  let d, f, u, l, b, p, h = 0;
  for (l = 0; l <= da; l++)
    e.bl_count[l] = 0;
  for (a[e.heap[e.heap_max] * 2 + 1] = 0, d = e.heap_max + 1; d < iu; d++)
    f = e.heap[d], l = a[a[f * 2 + 1] * 2 + 1] + 1, l > o && (l = o, h++), a[f * 2 + 1] = l, !(f > r) && (e.bl_count[l]++, b = 0, f >= i && (b = c[f - i]), p = a[f * 2], e.opt_len += p * (l + b), s && (e.static_len += p * (n[f * 2 + 1] + b)));
  if (h !== 0) {
    do {
      for (l = o - 1; e.bl_count[l] === 0; )
        l--;
      e.bl_count[l]--, e.bl_count[l + 1] += 2, e.bl_count[o]--, h -= 2;
    } while (h > 0);
    for (l = o; l !== 0; l--)
      for (f = e.bl_count[l]; f !== 0; )
        u = e.heap[--d], !(u > r) && (a[u * 2 + 1] !== l && (e.opt_len += (l - a[u * 2 + 1]) * a[u * 2], a[u * 2 + 1] = l), f--);
  }
}, yu = (e, t, a) => {
  const r = new Array(da + 1);
  let n = 0, s, c;
  for (s = 1; s <= da; s++)
    n = n + a[s - 1] << 1, r[s] = n;
  for (c = 0; c <= t; c++) {
    let i = e[c * 2 + 1];
    i !== 0 && (e[c * 2] = mu(r[i]++, i));
  }
}, h5 = () => {
  let e, t, a, r, n;
  const s = new Array(da + 1);
  for (a = 0, r = 0; r < Hi - 1; r++)
    for (Ki[r] = a, e = 0; e < 1 << Xc[r]; e++)
      Mr[a++] = r;
  for (Mr[a - 1] = r, n = 0, r = 0; r < 16; r++)
    for (ss[r] = n, e = 0; e < 1 << Wn[r]; e++)
      zr[n++] = r;
  for (n >>= 7; r < Va; r++)
    for (ss[r] = n << 7, e = 0; e < 1 << Wn[r] - 7; e++)
      zr[256 + n++] = r;
  for (t = 0; t <= da; t++)
    s[t] = 0;
  for (e = 0; e <= 143; )
    gt[e * 2 + 1] = 8, e++, s[8]++;
  for (; e <= 255; )
    gt[e * 2 + 1] = 9, e++, s[9]++;
  for (; e <= 279; )
    gt[e * 2 + 1] = 7, e++, s[7]++;
  for (; e <= 287; )
    gt[e * 2 + 1] = 8, e++, s[8]++;
  for (yu(gt, $r + 1, s), e = 0; e < Va; e++)
    Nr[e * 2 + 1] = 5, Nr[e * 2] = mu(e, 5);
  lu = new pc(gt, Xc, xn + 1, $r, da), bu = new pc(Nr, Wn, 0, Va, da), hu = new pc(new Array(0), f5, 0, Vi, d5);
}, gu = (e) => {
  let t;
  for (t = 0; t < $r; t++)
    e.dyn_ltree[t * 2] = 0;
  for (t = 0; t < Va; t++)
    e.dyn_dtree[t * 2] = 0;
  for (t = 0; t < Vi; t++)
    e.bl_tree[t * 2] = 0;
  e.dyn_ltree[qi * 2] = 1, e.opt_len = e.static_len = 0, e.sym_next = e.matches = 0;
}, _u = (e) => {
  e.bi_valid > 8 ? Hr(e, e.bi_buf) : e.bi_valid > 0 && (e.pending_buf[e.pending++] = e.bi_buf), e.bi_buf = 0, e.bi_valid = 0;
}, id = (e, t, a, r) => {
  const n = t * 2, s = a * 2;
  return e[n] < e[s] || e[n] === e[s] && r[t] <= r[a];
}, yc = (e, t, a) => {
  const r = e.heap[a];
  let n = a << 1;
  for (; n <= e.heap_len && (n < e.heap_len && id(t, e.heap[n + 1], e.heap[n], e.depth) && n++, !id(t, r, e.heap[n], e.depth)); )
    e.heap[a] = e.heap[n], a = n, n <<= 1;
  e.heap[a] = r;
}, od = (e, t, a) => {
  let r, n, s = 0, c, i;
  if (e.sym_next !== 0)
    do
      r = e.pending_buf[e.sym_buf + s++] & 255, r += (e.pending_buf[e.sym_buf + s++] & 255) << 8, n = e.pending_buf[e.sym_buf + s++], r === 0 ? tt(e, n, t) : (c = Mr[n], tt(e, c + xn + 1, t), i = Xc[c], i !== 0 && (n -= Ki[c], Ie(e, n, i)), r--, c = pu(r), tt(e, c, a), i = Wn[c], i !== 0 && (r -= ss[c], Ie(e, r, i)));
    while (s < e.sym_next);
  tt(e, qi, t);
}, Qc = (e, t) => {
  const a = t.dyn_tree, r = t.stat_desc.static_tree, n = t.stat_desc.has_stree, s = t.stat_desc.elems;
  let c, i, o = -1, d;
  for (e.heap_len = 0, e.heap_max = iu, c = 0; c < s; c++)
    a[c * 2] !== 0 ? (e.heap[++e.heap_len] = o = c, e.depth[c] = 0) : a[c * 2 + 1] = 0;
  for (; e.heap_len < 2; )
    d = e.heap[++e.heap_len] = o < 2 ? ++o : 0, a[d * 2] = 1, e.depth[d] = 0, e.opt_len--, n && (e.static_len -= r[d * 2 + 1]);
  for (t.max_code = o, c = e.heap_len >> 1; c >= 1; c--)
    yc(e, a, c);
  d = s;
  do
    c = e.heap[
      1
      /*SMALLEST*/
    ], e.heap[
      1
      /*SMALLEST*/
    ] = e.heap[e.heap_len--], yc(
      e,
      a,
      1
      /*SMALLEST*/
    ), i = e.heap[
      1
      /*SMALLEST*/
    ], e.heap[--e.heap_max] = c, e.heap[--e.heap_max] = i, a[d * 2] = a[c * 2] + a[i * 2], e.depth[d] = (e.depth[c] >= e.depth[i] ? e.depth[c] : e.depth[i]) + 1, a[c * 2 + 1] = a[i * 2 + 1] = d, e.heap[
      1
      /*SMALLEST*/
    ] = d++, yc(
      e,
      a,
      1
      /*SMALLEST*/
    );
  while (e.heap_len >= 2);
  e.heap[--e.heap_max] = e.heap[
    1
    /*SMALLEST*/
  ], b5(e, t), yu(a, o, e.bl_count);
}, dd = (e, t, a) => {
  let r, n = -1, s, c = t[0 * 2 + 1], i = 0, o = 7, d = 4;
  for (c === 0 && (o = 138, d = 3), t[(a + 1) * 2 + 1] = 65535, r = 0; r <= a; r++)
    s = c, c = t[(r + 1) * 2 + 1], !(++i < o && s === c) && (i < d ? e.bl_tree[s * 2] += i : s !== 0 ? (s !== n && e.bl_tree[s * 2]++, e.bl_tree[ou * 2]++) : i <= 10 ? e.bl_tree[du * 2]++ : e.bl_tree[fu * 2]++, i = 0, n = s, c === 0 ? (o = 138, d = 3) : s === c ? (o = 6, d = 3) : (o = 7, d = 4));
}, fd = (e, t, a) => {
  let r, n = -1, s, c = t[0 * 2 + 1], i = 0, o = 7, d = 4;
  for (c === 0 && (o = 138, d = 3), r = 0; r <= a; r++)
    if (s = c, c = t[(r + 1) * 2 + 1], !(++i < o && s === c)) {
      if (i < d)
        do
          tt(e, s, e.bl_tree);
        while (--i !== 0);
      else
        s !== 0 ? (s !== n && (tt(e, s, e.bl_tree), i--), tt(e, ou, e.bl_tree), Ie(e, i - 3, 2)) : i <= 10 ? (tt(e, du, e.bl_tree), Ie(e, i - 3, 3)) : (tt(e, fu, e.bl_tree), Ie(e, i - 11, 7));
      i = 0, n = s, c === 0 ? (o = 138, d = 3) : s === c ? (o = 6, d = 3) : (o = 7, d = 4);
    }
}, p5 = (e) => {
  let t;
  for (dd(e, e.dyn_ltree, e.l_desc.max_code), dd(e, e.dyn_dtree, e.d_desc.max_code), Qc(e, e.bl_desc), t = Vi - 1; t >= 3 && e.bl_tree[uu[t] * 2 + 1] === 0; t--)
    ;
  return e.opt_len += 3 * (t + 1) + 5 + 5 + 4, t;
}, m5 = (e, t, a, r) => {
  let n;
  for (Ie(e, t - 257, 5), Ie(e, a - 1, 5), Ie(e, r - 4, 4), n = 0; n < r; n++)
    Ie(e, e.bl_tree[uu[n] * 2 + 1], 3);
  fd(e, e.dyn_ltree, t - 1), fd(e, e.dyn_dtree, a - 1);
}, y5 = (e) => {
  let t = 4093624447, a;
  for (a = 0; a <= 31; a++, t >>>= 1)
    if (t & 1 && e.dyn_ltree[a * 2] !== 0)
      return sd;
  if (e.dyn_ltree[9 * 2] !== 0 || e.dyn_ltree[10 * 2] !== 0 || e.dyn_ltree[13 * 2] !== 0)
    return cd;
  for (a = 32; a < xn; a++)
    if (e.dyn_ltree[a * 2] !== 0)
      return cd;
  return sd;
};
let ud = !1;
const g5 = (e) => {
  ud || (h5(), ud = !0), e.l_desc = new mc(e.dyn_ltree, lu), e.d_desc = new mc(e.dyn_dtree, bu), e.bl_desc = new mc(e.bl_tree, hu), e.bi_buf = 0, e.bi_valid = 0, gu(e);
}, vu = (e, t, a, r) => {
  Ie(e, (s5 << 1) + (r ? 1 : 0), 3), _u(e), Hr(e, a), Hr(e, ~a), a && e.pending_buf.set(e.window.subarray(t, t + a), e.pending), e.pending += a;
}, _5 = (e) => {
  Ie(e, cu << 1, 3), tt(e, qi, gt), l5(e);
}, v5 = (e, t, a, r) => {
  let n, s, c = 0;
  e.level > 0 ? (e.strm.data_type === n5 && (e.strm.data_type = y5(e)), Qc(e, e.l_desc), Qc(e, e.d_desc), c = p5(e), n = e.opt_len + 3 + 7 >>> 3, s = e.static_len + 3 + 7 >>> 3, s <= n && (n = s)) : n = s = a + 5, a + 4 <= n && t !== -1 ? vu(e, t, a, r) : e.strategy === r5 || s === n ? (Ie(e, (cu << 1) + (r ? 1 : 0), 3), od(e, gt, Nr)) : (Ie(e, (c5 << 1) + (r ? 1 : 0), 3), m5(e, e.l_desc.max_code + 1, e.d_desc.max_code + 1, c + 1), od(e, e.dyn_ltree, e.dyn_dtree)), gu(e), r && _u(e);
}, w5 = (e, t, a) => (e.pending_buf[e.sym_buf + e.sym_next++] = t, e.pending_buf[e.sym_buf + e.sym_next++] = t >> 8, e.pending_buf[e.sym_buf + e.sym_next++] = a, t === 0 ? e.dyn_ltree[a * 2]++ : (e.matches++, t--, e.dyn_ltree[(Mr[a] + xn + 1) * 2]++, e.dyn_dtree[pu(t) * 2]++), e.sym_next === e.sym_end);
var E5 = g5, k5 = vu, x5 = v5, T5 = w5, S5 = _5, C5 = {
  _tr_init: E5,
  _tr_stored_block: k5,
  _tr_flush_block: x5,
  _tr_tally: T5,
  _tr_align: S5
};
const A5 = (e, t, a, r) => {
  let n = e & 65535 | 0, s = e >>> 16 & 65535 | 0, c = 0;
  for (; a !== 0; ) {
    c = a > 2e3 ? 2e3 : a, a -= c;
    do
      n = n + t[r++] | 0, s = s + n | 0;
    while (--c);
    n %= 65521, s %= 65521;
  }
  return n | s << 16 | 0;
};
var Vr = A5;
const O5 = () => {
  let e, t = [];
  for (var a = 0; a < 256; a++) {
    e = a;
    for (var r = 0; r < 8; r++)
      e = e & 1 ? 3988292384 ^ e >>> 1 : e >>> 1;
    t[a] = e;
  }
  return t;
}, I5 = new Uint32Array(O5()), N5 = (e, t, a, r) => {
  const n = I5, s = r + a;
  e ^= -1;
  for (let c = r; c < s; c++)
    e = e >>> 8 ^ n[(e ^ t[c]) & 255];
  return e ^ -1;
};
var be = N5, ya = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
}, lr = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
const { _tr_init: R5, _tr_stored_block: ei, _tr_flush_block: P5, _tr_tally: Ft, _tr_align: L5 } = C5, {
  Z_NO_FLUSH: Ut,
  Z_PARTIAL_FLUSH: j5,
  Z_FULL_FLUSH: Z5,
  Z_FINISH: Fe,
  Z_BLOCK: ld,
  Z_OK: ye,
  Z_STREAM_END: bd,
  Z_STREAM_ERROR: nt,
  Z_DATA_ERROR: D5,
  Z_BUF_ERROR: gc,
  Z_DEFAULT_COMPRESSION: B5,
  Z_FILTERED: F5,
  Z_HUFFMAN_ONLY: zn,
  Z_RLE: U5,
  Z_FIXED: $5,
  Z_DEFAULT_STRATEGY: z5,
  Z_UNKNOWN: M5,
  Z_DEFLATED: Us
} = lr, H5 = 9, V5 = 15, q5 = 8, K5 = 29, W5 = 256, ti = W5 + 1 + K5, G5 = 30, Y5 = 19, J5 = 2 * ti + 1, X5 = 15, J = 3, Dt = 258, st = Dt + J + 1, Q5 = 32, Qa = 42, Wi = 57, ai = 69, ri = 73, ni = 91, si = 103, fa = 113, Ar = 666, Se = 1, br = 2, ga = 3, hr = 4, e6 = 3, ua = (e, t) => (e.msg = ya[t], t), hd = (e) => e * 2 - (e > 4 ? 9 : 0), Pt = (e) => {
  let t = e.length;
  for (; --t >= 0; )
    e[t] = 0;
}, t6 = (e) => {
  let t, a, r, n = e.w_size;
  t = e.hash_size, r = t;
  do
    a = e.head[--r], e.head[r] = a >= n ? a - n : 0;
  while (--t);
  t = n, r = t;
  do
    a = e.prev[--r], e.prev[r] = a >= n ? a - n : 0;
  while (--t);
};
let a6 = (e, t, a) => (t << e.hash_shift ^ a) & e.hash_mask, $t = a6;
const Le = (e) => {
  const t = e.state;
  let a = t.pending;
  a > e.avail_out && (a = e.avail_out), a !== 0 && (e.output.set(t.pending_buf.subarray(t.pending_out, t.pending_out + a), e.next_out), e.next_out += a, t.pending_out += a, e.total_out += a, e.avail_out -= a, t.pending -= a, t.pending === 0 && (t.pending_out = 0));
}, De = (e, t) => {
  P5(e, e.block_start >= 0 ? e.block_start : -1, e.strstart - e.block_start, t), e.block_start = e.strstart, Le(e.strm);
}, re = (e, t) => {
  e.pending_buf[e.pending++] = t;
}, xr = (e, t) => {
  e.pending_buf[e.pending++] = t >>> 8 & 255, e.pending_buf[e.pending++] = t & 255;
}, ci = (e, t, a, r) => {
  let n = e.avail_in;
  return n > r && (n = r), n === 0 ? 0 : (e.avail_in -= n, t.set(e.input.subarray(e.next_in, e.next_in + n), a), e.state.wrap === 1 ? e.adler = Vr(e.adler, t, n, a) : e.state.wrap === 2 && (e.adler = be(e.adler, t, n, a)), e.next_in += n, e.total_in += n, n);
}, wu = (e, t) => {
  let a = e.max_chain_length, r = e.strstart, n, s, c = e.prev_length, i = e.nice_match;
  const o = e.strstart > e.w_size - st ? e.strstart - (e.w_size - st) : 0, d = e.window, f = e.w_mask, u = e.prev, l = e.strstart + Dt;
  let b = d[r + c - 1], p = d[r + c];
  e.prev_length >= e.good_match && (a >>= 2), i > e.lookahead && (i = e.lookahead);
  do
    if (n = t, !(d[n + c] !== p || d[n + c - 1] !== b || d[n] !== d[r] || d[++n] !== d[r + 1])) {
      r += 2, n++;
      do
        ;
      while (d[++r] === d[++n] && d[++r] === d[++n] && d[++r] === d[++n] && d[++r] === d[++n] && d[++r] === d[++n] && d[++r] === d[++n] && d[++r] === d[++n] && d[++r] === d[++n] && r < l);
      if (s = Dt - (l - r), r = l - Dt, s > c) {
        if (e.match_start = t, c = s, s >= i)
          break;
        b = d[r + c - 1], p = d[r + c];
      }
    }
  while ((t = u[t & f]) > o && --a !== 0);
  return c <= e.lookahead ? c : e.lookahead;
}, er = (e) => {
  const t = e.w_size;
  let a, r, n;
  do {
    if (r = e.window_size - e.lookahead - e.strstart, e.strstart >= t + (t - st) && (e.window.set(e.window.subarray(t, t + t - r), 0), e.match_start -= t, e.strstart -= t, e.block_start -= t, e.insert > e.strstart && (e.insert = e.strstart), t6(e), r += t), e.strm.avail_in === 0)
      break;
    if (a = ci(e.strm, e.window, e.strstart + e.lookahead, r), e.lookahead += a, e.lookahead + e.insert >= J)
      for (n = e.strstart - e.insert, e.ins_h = e.window[n], e.ins_h = $t(e, e.ins_h, e.window[n + 1]); e.insert && (e.ins_h = $t(e, e.ins_h, e.window[n + J - 1]), e.prev[n & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = n, n++, e.insert--, !(e.lookahead + e.insert < J)); )
        ;
  } while (e.lookahead < st && e.strm.avail_in !== 0);
}, Eu = (e, t) => {
  let a = e.pending_buf_size - 5 > e.w_size ? e.w_size : e.pending_buf_size - 5, r, n, s, c = 0, i = e.strm.avail_in;
  do {
    if (r = 65535, s = e.bi_valid + 42 >> 3, e.strm.avail_out < s || (s = e.strm.avail_out - s, n = e.strstart - e.block_start, r > n + e.strm.avail_in && (r = n + e.strm.avail_in), r > s && (r = s), r < a && (r === 0 && t !== Fe || t === Ut || r !== n + e.strm.avail_in)))
      break;
    c = t === Fe && r === n + e.strm.avail_in ? 1 : 0, ei(e, 0, 0, c), e.pending_buf[e.pending - 4] = r, e.pending_buf[e.pending - 3] = r >> 8, e.pending_buf[e.pending - 2] = ~r, e.pending_buf[e.pending - 1] = ~r >> 8, Le(e.strm), n && (n > r && (n = r), e.strm.output.set(e.window.subarray(e.block_start, e.block_start + n), e.strm.next_out), e.strm.next_out += n, e.strm.avail_out -= n, e.strm.total_out += n, e.block_start += n, r -= n), r && (ci(e.strm, e.strm.output, e.strm.next_out, r), e.strm.next_out += r, e.strm.avail_out -= r, e.strm.total_out += r);
  } while (c === 0);
  return i -= e.strm.avail_in, i && (i >= e.w_size ? (e.matches = 2, e.window.set(e.strm.input.subarray(e.strm.next_in - e.w_size, e.strm.next_in), 0), e.strstart = e.w_size, e.insert = e.strstart) : (e.window_size - e.strstart <= i && (e.strstart -= e.w_size, e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0), e.matches < 2 && e.matches++, e.insert > e.strstart && (e.insert = e.strstart)), e.window.set(e.strm.input.subarray(e.strm.next_in - i, e.strm.next_in), e.strstart), e.strstart += i, e.insert += i > e.w_size - e.insert ? e.w_size - e.insert : i), e.block_start = e.strstart), e.high_water < e.strstart && (e.high_water = e.strstart), c ? hr : t !== Ut && t !== Fe && e.strm.avail_in === 0 && e.strstart === e.block_start ? br : (s = e.window_size - e.strstart, e.strm.avail_in > s && e.block_start >= e.w_size && (e.block_start -= e.w_size, e.strstart -= e.w_size, e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0), e.matches < 2 && e.matches++, s += e.w_size, e.insert > e.strstart && (e.insert = e.strstart)), s > e.strm.avail_in && (s = e.strm.avail_in), s && (ci(e.strm, e.window, e.strstart, s), e.strstart += s, e.insert += s > e.w_size - e.insert ? e.w_size - e.insert : s), e.high_water < e.strstart && (e.high_water = e.strstart), s = e.bi_valid + 42 >> 3, s = e.pending_buf_size - s > 65535 ? 65535 : e.pending_buf_size - s, a = s > e.w_size ? e.w_size : s, n = e.strstart - e.block_start, (n >= a || (n || t === Fe) && t !== Ut && e.strm.avail_in === 0 && n <= s) && (r = n > s ? s : n, c = t === Fe && e.strm.avail_in === 0 && r === n ? 1 : 0, ei(e, e.block_start, r, c), e.block_start += r, Le(e.strm)), c ? ga : Se);
}, _c = (e, t) => {
  let a, r;
  for (; ; ) {
    if (e.lookahead < st) {
      if (er(e), e.lookahead < st && t === Ut)
        return Se;
      if (e.lookahead === 0)
        break;
    }
    if (a = 0, e.lookahead >= J && (e.ins_h = $t(e, e.ins_h, e.window[e.strstart + J - 1]), a = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), a !== 0 && e.strstart - a <= e.w_size - st && (e.match_length = wu(e, a)), e.match_length >= J)
      if (r = Ft(e, e.strstart - e.match_start, e.match_length - J), e.lookahead -= e.match_length, e.match_length <= e.max_lazy_match && e.lookahead >= J) {
        e.match_length--;
        do
          e.strstart++, e.ins_h = $t(e, e.ins_h, e.window[e.strstart + J - 1]), a = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart;
        while (--e.match_length !== 0);
        e.strstart++;
      } else
        e.strstart += e.match_length, e.match_length = 0, e.ins_h = e.window[e.strstart], e.ins_h = $t(e, e.ins_h, e.window[e.strstart + 1]);
    else
      r = Ft(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++;
    if (r && (De(e, !1), e.strm.avail_out === 0))
      return Se;
  }
  return e.insert = e.strstart < J - 1 ? e.strstart : J - 1, t === Fe ? (De(e, !0), e.strm.avail_out === 0 ? ga : hr) : e.sym_next && (De(e, !1), e.strm.avail_out === 0) ? Se : br;
}, Pa = (e, t) => {
  let a, r, n;
  for (; ; ) {
    if (e.lookahead < st) {
      if (er(e), e.lookahead < st && t === Ut)
        return Se;
      if (e.lookahead === 0)
        break;
    }
    if (a = 0, e.lookahead >= J && (e.ins_h = $t(e, e.ins_h, e.window[e.strstart + J - 1]), a = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), e.prev_length = e.match_length, e.prev_match = e.match_start, e.match_length = J - 1, a !== 0 && e.prev_length < e.max_lazy_match && e.strstart - a <= e.w_size - st && (e.match_length = wu(e, a), e.match_length <= 5 && (e.strategy === F5 || e.match_length === J && e.strstart - e.match_start > 4096) && (e.match_length = J - 1)), e.prev_length >= J && e.match_length <= e.prev_length) {
      n = e.strstart + e.lookahead - J, r = Ft(e, e.strstart - 1 - e.prev_match, e.prev_length - J), e.lookahead -= e.prev_length - 1, e.prev_length -= 2;
      do
        ++e.strstart <= n && (e.ins_h = $t(e, e.ins_h, e.window[e.strstart + J - 1]), a = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart);
      while (--e.prev_length !== 0);
      if (e.match_available = 0, e.match_length = J - 1, e.strstart++, r && (De(e, !1), e.strm.avail_out === 0))
        return Se;
    } else if (e.match_available) {
      if (r = Ft(e, 0, e.window[e.strstart - 1]), r && De(e, !1), e.strstart++, e.lookahead--, e.strm.avail_out === 0)
        return Se;
    } else
      e.match_available = 1, e.strstart++, e.lookahead--;
  }
  return e.match_available && (r = Ft(e, 0, e.window[e.strstart - 1]), e.match_available = 0), e.insert = e.strstart < J - 1 ? e.strstart : J - 1, t === Fe ? (De(e, !0), e.strm.avail_out === 0 ? ga : hr) : e.sym_next && (De(e, !1), e.strm.avail_out === 0) ? Se : br;
}, r6 = (e, t) => {
  let a, r, n, s;
  const c = e.window;
  for (; ; ) {
    if (e.lookahead <= Dt) {
      if (er(e), e.lookahead <= Dt && t === Ut)
        return Se;
      if (e.lookahead === 0)
        break;
    }
    if (e.match_length = 0, e.lookahead >= J && e.strstart > 0 && (n = e.strstart - 1, r = c[n], r === c[++n] && r === c[++n] && r === c[++n])) {
      s = e.strstart + Dt;
      do
        ;
      while (r === c[++n] && r === c[++n] && r === c[++n] && r === c[++n] && r === c[++n] && r === c[++n] && r === c[++n] && r === c[++n] && n < s);
      e.match_length = Dt - (s - n), e.match_length > e.lookahead && (e.match_length = e.lookahead);
    }
    if (e.match_length >= J ? (a = Ft(e, 1, e.match_length - J), e.lookahead -= e.match_length, e.strstart += e.match_length, e.match_length = 0) : (a = Ft(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++), a && (De(e, !1), e.strm.avail_out === 0))
      return Se;
  }
  return e.insert = 0, t === Fe ? (De(e, !0), e.strm.avail_out === 0 ? ga : hr) : e.sym_next && (De(e, !1), e.strm.avail_out === 0) ? Se : br;
}, n6 = (e, t) => {
  let a;
  for (; ; ) {
    if (e.lookahead === 0 && (er(e), e.lookahead === 0)) {
      if (t === Ut)
        return Se;
      break;
    }
    if (e.match_length = 0, a = Ft(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++, a && (De(e, !1), e.strm.avail_out === 0))
      return Se;
  }
  return e.insert = 0, t === Fe ? (De(e, !0), e.strm.avail_out === 0 ? ga : hr) : e.sym_next && (De(e, !1), e.strm.avail_out === 0) ? Se : br;
};
function et(e, t, a, r, n) {
  this.good_length = e, this.max_lazy = t, this.nice_length = a, this.max_chain = r, this.func = n;
}
const Or = [
  /*      good lazy nice chain */
  new et(0, 0, 0, 0, Eu),
  /* 0 store only */
  new et(4, 4, 8, 4, _c),
  /* 1 max speed, no lazy matches */
  new et(4, 5, 16, 8, _c),
  /* 2 */
  new et(4, 6, 32, 32, _c),
  /* 3 */
  new et(4, 4, 16, 16, Pa),
  /* 4 lazy matches */
  new et(8, 16, 32, 32, Pa),
  /* 5 */
  new et(8, 16, 128, 128, Pa),
  /* 6 */
  new et(8, 32, 128, 256, Pa),
  /* 7 */
  new et(32, 128, 258, 1024, Pa),
  /* 8 */
  new et(32, 258, 258, 4096, Pa)
  /* 9 max compression */
], s6 = (e) => {
  e.window_size = 2 * e.w_size, Pt(e.head), e.max_lazy_match = Or[e.level].max_lazy, e.good_match = Or[e.level].good_length, e.nice_match = Or[e.level].nice_length, e.max_chain_length = Or[e.level].max_chain, e.strstart = 0, e.block_start = 0, e.lookahead = 0, e.insert = 0, e.match_length = e.prev_length = J - 1, e.match_available = 0, e.ins_h = 0;
};
function c6() {
  this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = Us, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(J5 * 2), this.dyn_dtree = new Uint16Array((2 * G5 + 1) * 2), this.bl_tree = new Uint16Array((2 * Y5 + 1) * 2), Pt(this.dyn_ltree), Pt(this.dyn_dtree), Pt(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(X5 + 1), this.heap = new Uint16Array(2 * ti + 1), Pt(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * ti + 1), Pt(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
}
const Tn = (e) => {
  if (!e)
    return 1;
  const t = e.state;
  return !t || t.strm !== e || t.status !== Qa && //#ifdef GZIP
  t.status !== Wi && //#endif
  t.status !== ai && t.status !== ri && t.status !== ni && t.status !== si && t.status !== fa && t.status !== Ar ? 1 : 0;
}, ku = (e) => {
  if (Tn(e))
    return ua(e, nt);
  e.total_in = e.total_out = 0, e.data_type = M5;
  const t = e.state;
  return t.pending = 0, t.pending_out = 0, t.wrap < 0 && (t.wrap = -t.wrap), t.status = //#ifdef GZIP
  t.wrap === 2 ? Wi : (
    //#endif
    t.wrap ? Qa : fa
  ), e.adler = t.wrap === 2 ? 0 : 1, t.last_flush = -2, R5(t), ye;
}, xu = (e) => {
  const t = ku(e);
  return t === ye && s6(e.state), t;
}, i6 = (e, t) => Tn(e) || e.state.wrap !== 2 ? nt : (e.state.gzhead = t, ye), Tu = (e, t, a, r, n, s) => {
  if (!e)
    return nt;
  let c = 1;
  if (t === B5 && (t = 6), r < 0 ? (c = 0, r = -r) : r > 15 && (c = 2, r -= 16), n < 1 || n > H5 || a !== Us || r < 8 || r > 15 || t < 0 || t > 9 || s < 0 || s > $5 || r === 8 && c !== 1)
    return ua(e, nt);
  r === 8 && (r = 9);
  const i = new c6();
  return e.state = i, i.strm = e, i.status = Qa, i.wrap = c, i.gzhead = null, i.w_bits = r, i.w_size = 1 << i.w_bits, i.w_mask = i.w_size - 1, i.hash_bits = n + 7, i.hash_size = 1 << i.hash_bits, i.hash_mask = i.hash_size - 1, i.hash_shift = ~~((i.hash_bits + J - 1) / J), i.window = new Uint8Array(i.w_size * 2), i.head = new Uint16Array(i.hash_size), i.prev = new Uint16Array(i.w_size), i.lit_bufsize = 1 << n + 6, i.pending_buf_size = i.lit_bufsize * 4, i.pending_buf = new Uint8Array(i.pending_buf_size), i.sym_buf = i.lit_bufsize, i.sym_end = (i.lit_bufsize - 1) * 3, i.level = t, i.strategy = s, i.method = a, xu(e);
}, o6 = (e, t) => Tu(e, t, Us, V5, q5, z5), d6 = (e, t) => {
  if (Tn(e) || t > ld || t < 0)
    return e ? ua(e, nt) : nt;
  const a = e.state;
  if (!e.output || e.avail_in !== 0 && !e.input || a.status === Ar && t !== Fe)
    return ua(e, e.avail_out === 0 ? gc : nt);
  const r = a.last_flush;
  if (a.last_flush = t, a.pending !== 0) {
    if (Le(e), e.avail_out === 0)
      return a.last_flush = -1, ye;
  } else if (e.avail_in === 0 && hd(t) <= hd(r) && t !== Fe)
    return ua(e, gc);
  if (a.status === Ar && e.avail_in !== 0)
    return ua(e, gc);
  if (a.status === Qa && a.wrap === 0 && (a.status = fa), a.status === Qa) {
    let n = Us + (a.w_bits - 8 << 4) << 8, s = -1;
    if (a.strategy >= zn || a.level < 2 ? s = 0 : a.level < 6 ? s = 1 : a.level === 6 ? s = 2 : s = 3, n |= s << 6, a.strstart !== 0 && (n |= Q5), n += 31 - n % 31, xr(a, n), a.strstart !== 0 && (xr(a, e.adler >>> 16), xr(a, e.adler & 65535)), e.adler = 1, a.status = fa, Le(e), a.pending !== 0)
      return a.last_flush = -1, ye;
  }
  if (a.status === Wi) {
    if (e.adler = 0, re(a, 31), re(a, 139), re(a, 8), a.gzhead)
      re(
        a,
        (a.gzhead.text ? 1 : 0) + (a.gzhead.hcrc ? 2 : 0) + (a.gzhead.extra ? 4 : 0) + (a.gzhead.name ? 8 : 0) + (a.gzhead.comment ? 16 : 0)
      ), re(a, a.gzhead.time & 255), re(a, a.gzhead.time >> 8 & 255), re(a, a.gzhead.time >> 16 & 255), re(a, a.gzhead.time >> 24 & 255), re(a, a.level === 9 ? 2 : a.strategy >= zn || a.level < 2 ? 4 : 0), re(a, a.gzhead.os & 255), a.gzhead.extra && a.gzhead.extra.length && (re(a, a.gzhead.extra.length & 255), re(a, a.gzhead.extra.length >> 8 & 255)), a.gzhead.hcrc && (e.adler = be(e.adler, a.pending_buf, a.pending, 0)), a.gzindex = 0, a.status = ai;
    else if (re(a, 0), re(a, 0), re(a, 0), re(a, 0), re(a, 0), re(a, a.level === 9 ? 2 : a.strategy >= zn || a.level < 2 ? 4 : 0), re(a, e6), a.status = fa, Le(e), a.pending !== 0)
      return a.last_flush = -1, ye;
  }
  if (a.status === ai) {
    if (a.gzhead.extra) {
      let n = a.pending, s = (a.gzhead.extra.length & 65535) - a.gzindex;
      for (; a.pending + s > a.pending_buf_size; ) {
        let i = a.pending_buf_size - a.pending;
        if (a.pending_buf.set(a.gzhead.extra.subarray(a.gzindex, a.gzindex + i), a.pending), a.pending = a.pending_buf_size, a.gzhead.hcrc && a.pending > n && (e.adler = be(e.adler, a.pending_buf, a.pending - n, n)), a.gzindex += i, Le(e), a.pending !== 0)
          return a.last_flush = -1, ye;
        n = 0, s -= i;
      }
      let c = new Uint8Array(a.gzhead.extra);
      a.pending_buf.set(c.subarray(a.gzindex, a.gzindex + s), a.pending), a.pending += s, a.gzhead.hcrc && a.pending > n && (e.adler = be(e.adler, a.pending_buf, a.pending - n, n)), a.gzindex = 0;
    }
    a.status = ri;
  }
  if (a.status === ri) {
    if (a.gzhead.name) {
      let n = a.pending, s;
      do {
        if (a.pending === a.pending_buf_size) {
          if (a.gzhead.hcrc && a.pending > n && (e.adler = be(e.adler, a.pending_buf, a.pending - n, n)), Le(e), a.pending !== 0)
            return a.last_flush = -1, ye;
          n = 0;
        }
        a.gzindex < a.gzhead.name.length ? s = a.gzhead.name.charCodeAt(a.gzindex++) & 255 : s = 0, re(a, s);
      } while (s !== 0);
      a.gzhead.hcrc && a.pending > n && (e.adler = be(e.adler, a.pending_buf, a.pending - n, n)), a.gzindex = 0;
    }
    a.status = ni;
  }
  if (a.status === ni) {
    if (a.gzhead.comment) {
      let n = a.pending, s;
      do {
        if (a.pending === a.pending_buf_size) {
          if (a.gzhead.hcrc && a.pending > n && (e.adler = be(e.adler, a.pending_buf, a.pending - n, n)), Le(e), a.pending !== 0)
            return a.last_flush = -1, ye;
          n = 0;
        }
        a.gzindex < a.gzhead.comment.length ? s = a.gzhead.comment.charCodeAt(a.gzindex++) & 255 : s = 0, re(a, s);
      } while (s !== 0);
      a.gzhead.hcrc && a.pending > n && (e.adler = be(e.adler, a.pending_buf, a.pending - n, n));
    }
    a.status = si;
  }
  if (a.status === si) {
    if (a.gzhead.hcrc) {
      if (a.pending + 2 > a.pending_buf_size && (Le(e), a.pending !== 0))
        return a.last_flush = -1, ye;
      re(a, e.adler & 255), re(a, e.adler >> 8 & 255), e.adler = 0;
    }
    if (a.status = fa, Le(e), a.pending !== 0)
      return a.last_flush = -1, ye;
  }
  if (e.avail_in !== 0 || a.lookahead !== 0 || t !== Ut && a.status !== Ar) {
    let n = a.level === 0 ? Eu(a, t) : a.strategy === zn ? n6(a, t) : a.strategy === U5 ? r6(a, t) : Or[a.level].func(a, t);
    if ((n === ga || n === hr) && (a.status = Ar), n === Se || n === ga)
      return e.avail_out === 0 && (a.last_flush = -1), ye;
    if (n === br && (t === j5 ? L5(a) : t !== ld && (ei(a, 0, 0, !1), t === Z5 && (Pt(a.head), a.lookahead === 0 && (a.strstart = 0, a.block_start = 0, a.insert = 0))), Le(e), e.avail_out === 0))
      return a.last_flush = -1, ye;
  }
  return t !== Fe ? ye : a.wrap <= 0 ? bd : (a.wrap === 2 ? (re(a, e.adler & 255), re(a, e.adler >> 8 & 255), re(a, e.adler >> 16 & 255), re(a, e.adler >> 24 & 255), re(a, e.total_in & 255), re(a, e.total_in >> 8 & 255), re(a, e.total_in >> 16 & 255), re(a, e.total_in >> 24 & 255)) : (xr(a, e.adler >>> 16), xr(a, e.adler & 65535)), Le(e), a.wrap > 0 && (a.wrap = -a.wrap), a.pending !== 0 ? ye : bd);
}, f6 = (e) => {
  if (Tn(e))
    return nt;
  const t = e.state.status;
  return e.state = null, t === fa ? ua(e, D5) : ye;
}, u6 = (e, t) => {
  let a = t.length;
  if (Tn(e))
    return nt;
  const r = e.state, n = r.wrap;
  if (n === 2 || n === 1 && r.status !== Qa || r.lookahead)
    return nt;
  if (n === 1 && (e.adler = Vr(e.adler, t, a, 0)), r.wrap = 0, a >= r.w_size) {
    n === 0 && (Pt(r.head), r.strstart = 0, r.block_start = 0, r.insert = 0);
    let o = new Uint8Array(r.w_size);
    o.set(t.subarray(a - r.w_size, a), 0), t = o, a = r.w_size;
  }
  const s = e.avail_in, c = e.next_in, i = e.input;
  for (e.avail_in = a, e.next_in = 0, e.input = t, er(r); r.lookahead >= J; ) {
    let o = r.strstart, d = r.lookahead - (J - 1);
    do
      r.ins_h = $t(r, r.ins_h, r.window[o + J - 1]), r.prev[o & r.w_mask] = r.head[r.ins_h], r.head[r.ins_h] = o, o++;
    while (--d);
    r.strstart = o, r.lookahead = J - 1, er(r);
  }
  return r.strstart += r.lookahead, r.block_start = r.strstart, r.insert = r.lookahead, r.lookahead = 0, r.match_length = r.prev_length = J - 1, r.match_available = 0, e.next_in = c, e.input = i, e.avail_in = s, r.wrap = n, ye;
};
var l6 = o6, b6 = Tu, h6 = xu, p6 = ku, m6 = i6, y6 = d6, g6 = f6, _6 = u6, v6 = "pako deflate (from Nodeca project)", Rr = {
  deflateInit: l6,
  deflateInit2: b6,
  deflateReset: h6,
  deflateResetKeep: p6,
  deflateSetHeader: m6,
  deflate: y6,
  deflateEnd: g6,
  deflateSetDictionary: _6,
  deflateInfo: v6
};
const w6 = (e, t) => Object.prototype.hasOwnProperty.call(e, t);
var E6 = function(e) {
  const t = Array.prototype.slice.call(arguments, 1);
  for (; t.length; ) {
    const a = t.shift();
    if (a) {
      if (typeof a != "object")
        throw new TypeError(a + "must be non-object");
      for (const r in a)
        w6(a, r) && (e[r] = a[r]);
    }
  }
  return e;
}, k6 = (e) => {
  let t = 0;
  for (let r = 0, n = e.length; r < n; r++)
    t += e[r].length;
  const a = new Uint8Array(t);
  for (let r = 0, n = 0, s = e.length; r < s; r++) {
    let c = e[r];
    a.set(c, n), n += c.length;
  }
  return a;
}, $s = {
  assign: E6,
  flattenChunks: k6
};
let Su = !0;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch {
  Su = !1;
}
const qr = new Uint8Array(256);
for (let e = 0; e < 256; e++)
  qr[e] = e >= 252 ? 6 : e >= 248 ? 5 : e >= 240 ? 4 : e >= 224 ? 3 : e >= 192 ? 2 : 1;
qr[254] = qr[254] = 1;
var x6 = (e) => {
  if (typeof TextEncoder == "function" && TextEncoder.prototype.encode)
    return new TextEncoder().encode(e);
  let t, a, r, n, s, c = e.length, i = 0;
  for (n = 0; n < c; n++)
    a = e.charCodeAt(n), (a & 64512) === 55296 && n + 1 < c && (r = e.charCodeAt(n + 1), (r & 64512) === 56320 && (a = 65536 + (a - 55296 << 10) + (r - 56320), n++)), i += a < 128 ? 1 : a < 2048 ? 2 : a < 65536 ? 3 : 4;
  for (t = new Uint8Array(i), s = 0, n = 0; s < i; n++)
    a = e.charCodeAt(n), (a & 64512) === 55296 && n + 1 < c && (r = e.charCodeAt(n + 1), (r & 64512) === 56320 && (a = 65536 + (a - 55296 << 10) + (r - 56320), n++)), a < 128 ? t[s++] = a : a < 2048 ? (t[s++] = 192 | a >>> 6, t[s++] = 128 | a & 63) : a < 65536 ? (t[s++] = 224 | a >>> 12, t[s++] = 128 | a >>> 6 & 63, t[s++] = 128 | a & 63) : (t[s++] = 240 | a >>> 18, t[s++] = 128 | a >>> 12 & 63, t[s++] = 128 | a >>> 6 & 63, t[s++] = 128 | a & 63);
  return t;
};
const T6 = (e, t) => {
  if (t < 65534 && e.subarray && Su)
    return String.fromCharCode.apply(null, e.length === t ? e : e.subarray(0, t));
  let a = "";
  for (let r = 0; r < t; r++)
    a += String.fromCharCode(e[r]);
  return a;
};
var S6 = (e, t) => {
  const a = t || e.length;
  if (typeof TextDecoder == "function" && TextDecoder.prototype.decode)
    return new TextDecoder().decode(e.subarray(0, t));
  let r, n;
  const s = new Array(a * 2);
  for (n = 0, r = 0; r < a; ) {
    let c = e[r++];
    if (c < 128) {
      s[n++] = c;
      continue;
    }
    let i = qr[c];
    if (i > 4) {
      s[n++] = 65533, r += i - 1;
      continue;
    }
    for (c &= i === 2 ? 31 : i === 3 ? 15 : 7; i > 1 && r < a; )
      c = c << 6 | e[r++] & 63, i--;
    if (i > 1) {
      s[n++] = 65533;
      continue;
    }
    c < 65536 ? s[n++] = c : (c -= 65536, s[n++] = 55296 | c >> 10 & 1023, s[n++] = 56320 | c & 1023);
  }
  return T6(s, n);
}, C6 = (e, t) => {
  t = t || e.length, t > e.length && (t = e.length);
  let a = t - 1;
  for (; a >= 0 && (e[a] & 192) === 128; )
    a--;
  return a < 0 || a === 0 ? t : a + qr[e[a]] > t ? a : t;
}, Kr = {
  string2buf: x6,
  buf2string: S6,
  utf8border: C6
};
function A6() {
  this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
}
var Cu = A6;
const Au = Object.prototype.toString, {
  Z_NO_FLUSH: O6,
  Z_SYNC_FLUSH: I6,
  Z_FULL_FLUSH: N6,
  Z_FINISH: R6,
  Z_OK: cs,
  Z_STREAM_END: P6,
  Z_DEFAULT_COMPRESSION: L6,
  Z_DEFAULT_STRATEGY: j6,
  Z_DEFLATED: Z6
} = lr;
function Sn(e) {
  this.options = $s.assign({
    level: L6,
    method: Z6,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: j6
  }, e || {});
  let t = this.options;
  t.raw && t.windowBits > 0 ? t.windowBits = -t.windowBits : t.gzip && t.windowBits > 0 && t.windowBits < 16 && (t.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new Cu(), this.strm.avail_out = 0;
  let a = Rr.deflateInit2(
    this.strm,
    t.level,
    t.method,
    t.windowBits,
    t.memLevel,
    t.strategy
  );
  if (a !== cs)
    throw new Error(ya[a]);
  if (t.header && Rr.deflateSetHeader(this.strm, t.header), t.dictionary) {
    let r;
    if (typeof t.dictionary == "string" ? r = Kr.string2buf(t.dictionary) : Au.call(t.dictionary) === "[object ArrayBuffer]" ? r = new Uint8Array(t.dictionary) : r = t.dictionary, a = Rr.deflateSetDictionary(this.strm, r), a !== cs)
      throw new Error(ya[a]);
    this._dict_set = !0;
  }
}
Sn.prototype.push = function(e, t) {
  const a = this.strm, r = this.options.chunkSize;
  let n, s;
  if (this.ended)
    return !1;
  for (t === ~~t ? s = t : s = t === !0 ? R6 : O6, typeof e == "string" ? a.input = Kr.string2buf(e) : Au.call(e) === "[object ArrayBuffer]" ? a.input = new Uint8Array(e) : a.input = e, a.next_in = 0, a.avail_in = a.input.length; ; ) {
    if (a.avail_out === 0 && (a.output = new Uint8Array(r), a.next_out = 0, a.avail_out = r), (s === I6 || s === N6) && a.avail_out <= 6) {
      this.onData(a.output.subarray(0, a.next_out)), a.avail_out = 0;
      continue;
    }
    if (n = Rr.deflate(a, s), n === P6)
      return a.next_out > 0 && this.onData(a.output.subarray(0, a.next_out)), n = Rr.deflateEnd(this.strm), this.onEnd(n), this.ended = !0, n === cs;
    if (a.avail_out === 0) {
      this.onData(a.output);
      continue;
    }
    if (s > 0 && a.next_out > 0) {
      this.onData(a.output.subarray(0, a.next_out)), a.avail_out = 0;
      continue;
    }
    if (a.avail_in === 0)
      break;
  }
  return !0;
};
Sn.prototype.onData = function(e) {
  this.chunks.push(e);
};
Sn.prototype.onEnd = function(e) {
  e === cs && (this.result = $s.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;
};
function Gi(e, t) {
  const a = new Sn(t);
  if (a.push(e, !0), a.err)
    throw a.msg || ya[a.err];
  return a.result;
}
function D6(e, t) {
  return t = t || {}, t.raw = !0, Gi(e, t);
}
function B6(e, t) {
  return t = t || {}, t.gzip = !0, Gi(e, t);
}
var F6 = Sn, U6 = Gi, $6 = D6, z6 = B6, M6 = lr, H6 = {
  Deflate: F6,
  deflate: U6,
  deflateRaw: $6,
  gzip: z6,
  constants: M6
};
const Mn = 16209, V6 = 16191;
var q6 = function(e, t) {
  let a, r, n, s, c, i, o, d, f, u, l, b, p, h, m, y, v, g, T, Z, _, w, O, I;
  const S = e.state;
  a = e.next_in, O = e.input, r = a + (e.avail_in - 5), n = e.next_out, I = e.output, s = n - (t - e.avail_out), c = n + (e.avail_out - 257), i = S.dmax, o = S.wsize, d = S.whave, f = S.wnext, u = S.window, l = S.hold, b = S.bits, p = S.lencode, h = S.distcode, m = (1 << S.lenbits) - 1, y = (1 << S.distbits) - 1;
  e:
    do {
      b < 15 && (l += O[a++] << b, b += 8, l += O[a++] << b, b += 8), v = p[l & m];
      t:
        for (; ; ) {
          if (g = v >>> 24, l >>>= g, b -= g, g = v >>> 16 & 255, g === 0)
            I[n++] = v & 65535;
          else if (g & 16) {
            T = v & 65535, g &= 15, g && (b < g && (l += O[a++] << b, b += 8), T += l & (1 << g) - 1, l >>>= g, b -= g), b < 15 && (l += O[a++] << b, b += 8, l += O[a++] << b, b += 8), v = h[l & y];
            a:
              for (; ; ) {
                if (g = v >>> 24, l >>>= g, b -= g, g = v >>> 16 & 255, g & 16) {
                  if (Z = v & 65535, g &= 15, b < g && (l += O[a++] << b, b += 8, b < g && (l += O[a++] << b, b += 8)), Z += l & (1 << g) - 1, Z > i) {
                    e.msg = "invalid distance too far back", S.mode = Mn;
                    break e;
                  }
                  if (l >>>= g, b -= g, g = n - s, Z > g) {
                    if (g = Z - g, g > d && S.sane) {
                      e.msg = "invalid distance too far back", S.mode = Mn;
                      break e;
                    }
                    if (_ = 0, w = u, f === 0) {
                      if (_ += o - g, g < T) {
                        T -= g;
                        do
                          I[n++] = u[_++];
                        while (--g);
                        _ = n - Z, w = I;
                      }
                    } else if (f < g) {
                      if (_ += o + f - g, g -= f, g < T) {
                        T -= g;
                        do
                          I[n++] = u[_++];
                        while (--g);
                        if (_ = 0, f < T) {
                          g = f, T -= g;
                          do
                            I[n++] = u[_++];
                          while (--g);
                          _ = n - Z, w = I;
                        }
                      }
                    } else if (_ += f - g, g < T) {
                      T -= g;
                      do
                        I[n++] = u[_++];
                      while (--g);
                      _ = n - Z, w = I;
                    }
                    for (; T > 2; )
                      I[n++] = w[_++], I[n++] = w[_++], I[n++] = w[_++], T -= 3;
                    T && (I[n++] = w[_++], T > 1 && (I[n++] = w[_++]));
                  } else {
                    _ = n - Z;
                    do
                      I[n++] = I[_++], I[n++] = I[_++], I[n++] = I[_++], T -= 3;
                    while (T > 2);
                    T && (I[n++] = I[_++], T > 1 && (I[n++] = I[_++]));
                  }
                } else if (g & 64) {
                  e.msg = "invalid distance code", S.mode = Mn;
                  break e;
                } else {
                  v = h[(v & 65535) + (l & (1 << g) - 1)];
                  continue a;
                }
                break;
              }
          } else if (g & 64)
            if (g & 32) {
              S.mode = V6;
              break e;
            } else {
              e.msg = "invalid literal/length code", S.mode = Mn;
              break e;
            }
          else {
            v = p[(v & 65535) + (l & (1 << g) - 1)];
            continue t;
          }
          break;
        }
    } while (a < r && n < c);
  T = b >> 3, a -= T, b -= T << 3, l &= (1 << b) - 1, e.next_in = a, e.next_out = n, e.avail_in = a < r ? 5 + (r - a) : 5 - (a - r), e.avail_out = n < c ? 257 + (c - n) : 257 - (n - c), S.hold = l, S.bits = b;
};
const La = 15, pd = 852, md = 592, yd = 0, vc = 1, gd = 2, K6 = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]), W6 = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]), G6 = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]), Y6 = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]), J6 = (e, t, a, r, n, s, c, i) => {
  const o = i.bits;
  let d = 0, f = 0, u = 0, l = 0, b = 0, p = 0, h = 0, m = 0, y = 0, v = 0, g, T, Z, _, w, O = null, I;
  const S = new Uint16Array(La + 1), C = new Uint16Array(La + 1);
  let X = null, ne, D, E;
  for (d = 0; d <= La; d++)
    S[d] = 0;
  for (f = 0; f < r; f++)
    S[t[a + f]]++;
  for (b = o, l = La; l >= 1 && S[l] === 0; l--)
    ;
  if (b > l && (b = l), l === 0)
    return n[s++] = 1 << 24 | 64 << 16 | 0, n[s++] = 1 << 24 | 64 << 16 | 0, i.bits = 1, 0;
  for (u = 1; u < l && S[u] === 0; u++)
    ;
  for (b < u && (b = u), m = 1, d = 1; d <= La; d++)
    if (m <<= 1, m -= S[d], m < 0)
      return -1;
  if (m > 0 && (e === yd || l !== 1))
    return -1;
  for (C[1] = 0, d = 1; d < La; d++)
    C[d + 1] = C[d] + S[d];
  for (f = 0; f < r; f++)
    t[a + f] !== 0 && (c[C[t[a + f]]++] = f);
  if (e === yd ? (O = X = c, I = 20) : e === vc ? (O = K6, X = W6, I = 257) : (O = G6, X = Y6, I = 0), v = 0, f = 0, d = u, w = s, p = b, h = 0, Z = -1, y = 1 << b, _ = y - 1, e === vc && y > pd || e === gd && y > md)
    return 1;
  for (; ; ) {
    ne = d - h, c[f] + 1 < I ? (D = 0, E = c[f]) : c[f] >= I ? (D = X[c[f] - I], E = O[c[f] - I]) : (D = 32 + 64, E = 0), g = 1 << d - h, T = 1 << p, u = T;
    do
      T -= g, n[w + (v >> h) + T] = ne << 24 | D << 16 | E | 0;
    while (T !== 0);
    for (g = 1 << d - 1; v & g; )
      g >>= 1;
    if (g !== 0 ? (v &= g - 1, v += g) : v = 0, f++, --S[d] === 0) {
      if (d === l)
        break;
      d = t[a + c[f]];
    }
    if (d > b && (v & _) !== Z) {
      for (h === 0 && (h = b), w += u, p = d - h, m = 1 << p; p + h < l && (m -= S[p + h], !(m <= 0)); )
        p++, m <<= 1;
      if (y += 1 << p, e === vc && y > pd || e === gd && y > md)
        return 1;
      Z = v & _, n[Z] = b << 24 | p << 16 | w - s | 0;
    }
  }
  return v !== 0 && (n[w + v] = d - h << 24 | 64 << 16 | 0), i.bits = b, 0;
};
var Pr = J6;
const X6 = 0, Ou = 1, Iu = 2, {
  Z_FINISH: _d,
  Z_BLOCK: Q6,
  Z_TREES: Hn,
  Z_OK: _a,
  Z_STREAM_END: ep,
  Z_NEED_DICT: tp,
  Z_STREAM_ERROR: Ge,
  Z_DATA_ERROR: Nu,
  Z_MEM_ERROR: Ru,
  Z_BUF_ERROR: ap,
  Z_DEFLATED: vd
} = lr, zs = 16180, wd = 16181, Ed = 16182, kd = 16183, xd = 16184, Td = 16185, Sd = 16186, Cd = 16187, Ad = 16188, Od = 16189, is = 16190, mt = 16191, wc = 16192, Id = 16193, Ec = 16194, Nd = 16195, Rd = 16196, Pd = 16197, Ld = 16198, Vn = 16199, qn = 16200, jd = 16201, Zd = 16202, Dd = 16203, Bd = 16204, Fd = 16205, kc = 16206, Ud = 16207, $d = 16208, ce = 16209, Pu = 16210, Lu = 16211, rp = 852, np = 592, sp = 15, cp = sp, zd = (e) => (e >>> 24 & 255) + (e >>> 8 & 65280) + ((e & 65280) << 8) + ((e & 255) << 24);
function ip() {
  this.strm = null, this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
}
const Ia = (e) => {
  if (!e)
    return 1;
  const t = e.state;
  return !t || t.strm !== e || t.mode < zs || t.mode > Lu ? 1 : 0;
}, ju = (e) => {
  if (Ia(e))
    return Ge;
  const t = e.state;
  return e.total_in = e.total_out = t.total = 0, e.msg = "", t.wrap && (e.adler = t.wrap & 1), t.mode = zs, t.last = 0, t.havedict = 0, t.flags = -1, t.dmax = 32768, t.head = null, t.hold = 0, t.bits = 0, t.lencode = t.lendyn = new Int32Array(rp), t.distcode = t.distdyn = new Int32Array(np), t.sane = 1, t.back = -1, _a;
}, Zu = (e) => {
  if (Ia(e))
    return Ge;
  const t = e.state;
  return t.wsize = 0, t.whave = 0, t.wnext = 0, ju(e);
}, Du = (e, t) => {
  let a;
  if (Ia(e))
    return Ge;
  const r = e.state;
  return t < 0 ? (a = 0, t = -t) : (a = (t >> 4) + 5, t < 48 && (t &= 15)), t && (t < 8 || t > 15) ? Ge : (r.window !== null && r.wbits !== t && (r.window = null), r.wrap = a, r.wbits = t, Zu(e));
}, Bu = (e, t) => {
  if (!e)
    return Ge;
  const a = new ip();
  e.state = a, a.strm = e, a.window = null, a.mode = zs;
  const r = Du(e, t);
  return r !== _a && (e.state = null), r;
}, op = (e) => Bu(e, cp);
let Md = !0, xc, Tc;
const dp = (e) => {
  if (Md) {
    xc = new Int32Array(512), Tc = new Int32Array(32);
    let t = 0;
    for (; t < 144; )
      e.lens[t++] = 8;
    for (; t < 256; )
      e.lens[t++] = 9;
    for (; t < 280; )
      e.lens[t++] = 7;
    for (; t < 288; )
      e.lens[t++] = 8;
    for (Pr(Ou, e.lens, 0, 288, xc, 0, e.work, { bits: 9 }), t = 0; t < 32; )
      e.lens[t++] = 5;
    Pr(Iu, e.lens, 0, 32, Tc, 0, e.work, { bits: 5 }), Md = !1;
  }
  e.lencode = xc, e.lenbits = 9, e.distcode = Tc, e.distbits = 5;
}, Fu = (e, t, a, r) => {
  let n;
  const s = e.state;
  return s.window === null && (s.wsize = 1 << s.wbits, s.wnext = 0, s.whave = 0, s.window = new Uint8Array(s.wsize)), r >= s.wsize ? (s.window.set(t.subarray(a - s.wsize, a), 0), s.wnext = 0, s.whave = s.wsize) : (n = s.wsize - s.wnext, n > r && (n = r), s.window.set(t.subarray(a - r, a - r + n), s.wnext), r -= n, r ? (s.window.set(t.subarray(a - r, a), 0), s.wnext = r, s.whave = s.wsize) : (s.wnext += n, s.wnext === s.wsize && (s.wnext = 0), s.whave < s.wsize && (s.whave += n))), 0;
}, fp = (e, t) => {
  let a, r, n, s, c, i, o, d, f, u, l, b, p, h, m = 0, y, v, g, T, Z, _, w, O;
  const I = new Uint8Array(4);
  let S, C;
  const X = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (Ia(e) || !e.output || !e.input && e.avail_in !== 0)
    return Ge;
  a = e.state, a.mode === mt && (a.mode = wc), c = e.next_out, n = e.output, o = e.avail_out, s = e.next_in, r = e.input, i = e.avail_in, d = a.hold, f = a.bits, u = i, l = o, O = _a;
  e:
    for (; ; )
      switch (a.mode) {
        case zs:
          if (a.wrap === 0) {
            a.mode = wc;
            break;
          }
          for (; f < 16; ) {
            if (i === 0)
              break e;
            i--, d += r[s++] << f, f += 8;
          }
          if (a.wrap & 2 && d === 35615) {
            a.wbits === 0 && (a.wbits = 15), a.check = 0, I[0] = d & 255, I[1] = d >>> 8 & 255, a.check = be(a.check, I, 2, 0), d = 0, f = 0, a.mode = wd;
            break;
          }
          if (a.head && (a.head.done = !1), !(a.wrap & 1) || /* check if zlib header allowed */
          (((d & 255) << 8) + (d >> 8)) % 31) {
            e.msg = "incorrect header check", a.mode = ce;
            break;
          }
          if ((d & 15) !== vd) {
            e.msg = "unknown compression method", a.mode = ce;
            break;
          }
          if (d >>>= 4, f -= 4, w = (d & 15) + 8, a.wbits === 0 && (a.wbits = w), w > 15 || w > a.wbits) {
            e.msg = "invalid window size", a.mode = ce;
            break;
          }
          a.dmax = 1 << a.wbits, a.flags = 0, e.adler = a.check = 1, a.mode = d & 512 ? Od : mt, d = 0, f = 0;
          break;
        case wd:
          for (; f < 16; ) {
            if (i === 0)
              break e;
            i--, d += r[s++] << f, f += 8;
          }
          if (a.flags = d, (a.flags & 255) !== vd) {
            e.msg = "unknown compression method", a.mode = ce;
            break;
          }
          if (a.flags & 57344) {
            e.msg = "unknown header flags set", a.mode = ce;
            break;
          }
          a.head && (a.head.text = d >> 8 & 1), a.flags & 512 && a.wrap & 4 && (I[0] = d & 255, I[1] = d >>> 8 & 255, a.check = be(a.check, I, 2, 0)), d = 0, f = 0, a.mode = Ed;
        case Ed:
          for (; f < 32; ) {
            if (i === 0)
              break e;
            i--, d += r[s++] << f, f += 8;
          }
          a.head && (a.head.time = d), a.flags & 512 && a.wrap & 4 && (I[0] = d & 255, I[1] = d >>> 8 & 255, I[2] = d >>> 16 & 255, I[3] = d >>> 24 & 255, a.check = be(a.check, I, 4, 0)), d = 0, f = 0, a.mode = kd;
        case kd:
          for (; f < 16; ) {
            if (i === 0)
              break e;
            i--, d += r[s++] << f, f += 8;
          }
          a.head && (a.head.xflags = d & 255, a.head.os = d >> 8), a.flags & 512 && a.wrap & 4 && (I[0] = d & 255, I[1] = d >>> 8 & 255, a.check = be(a.check, I, 2, 0)), d = 0, f = 0, a.mode = xd;
        case xd:
          if (a.flags & 1024) {
            for (; f < 16; ) {
              if (i === 0)
                break e;
              i--, d += r[s++] << f, f += 8;
            }
            a.length = d, a.head && (a.head.extra_len = d), a.flags & 512 && a.wrap & 4 && (I[0] = d & 255, I[1] = d >>> 8 & 255, a.check = be(a.check, I, 2, 0)), d = 0, f = 0;
          } else
            a.head && (a.head.extra = null);
          a.mode = Td;
        case Td:
          if (a.flags & 1024 && (b = a.length, b > i && (b = i), b && (a.head && (w = a.head.extra_len - a.length, a.head.extra || (a.head.extra = new Uint8Array(a.head.extra_len)), a.head.extra.set(
            r.subarray(
              s,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              s + b
            ),
            /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
            w
          )), a.flags & 512 && a.wrap & 4 && (a.check = be(a.check, r, b, s)), i -= b, s += b, a.length -= b), a.length))
            break e;
          a.length = 0, a.mode = Sd;
        case Sd:
          if (a.flags & 2048) {
            if (i === 0)
              break e;
            b = 0;
            do
              w = r[s + b++], a.head && w && a.length < 65536 && (a.head.name += String.fromCharCode(w));
            while (w && b < i);
            if (a.flags & 512 && a.wrap & 4 && (a.check = be(a.check, r, b, s)), i -= b, s += b, w)
              break e;
          } else
            a.head && (a.head.name = null);
          a.length = 0, a.mode = Cd;
        case Cd:
          if (a.flags & 4096) {
            if (i === 0)
              break e;
            b = 0;
            do
              w = r[s + b++], a.head && w && a.length < 65536 && (a.head.comment += String.fromCharCode(w));
            while (w && b < i);
            if (a.flags & 512 && a.wrap & 4 && (a.check = be(a.check, r, b, s)), i -= b, s += b, w)
              break e;
          } else
            a.head && (a.head.comment = null);
          a.mode = Ad;
        case Ad:
          if (a.flags & 512) {
            for (; f < 16; ) {
              if (i === 0)
                break e;
              i--, d += r[s++] << f, f += 8;
            }
            if (a.wrap & 4 && d !== (a.check & 65535)) {
              e.msg = "header crc mismatch", a.mode = ce;
              break;
            }
            d = 0, f = 0;
          }
          a.head && (a.head.hcrc = a.flags >> 9 & 1, a.head.done = !0), e.adler = a.check = 0, a.mode = mt;
          break;
        case Od:
          for (; f < 32; ) {
            if (i === 0)
              break e;
            i--, d += r[s++] << f, f += 8;
          }
          e.adler = a.check = zd(d), d = 0, f = 0, a.mode = is;
        case is:
          if (a.havedict === 0)
            return e.next_out = c, e.avail_out = o, e.next_in = s, e.avail_in = i, a.hold = d, a.bits = f, tp;
          e.adler = a.check = 1, a.mode = mt;
        case mt:
          if (t === Q6 || t === Hn)
            break e;
        case wc:
          if (a.last) {
            d >>>= f & 7, f -= f & 7, a.mode = kc;
            break;
          }
          for (; f < 3; ) {
            if (i === 0)
              break e;
            i--, d += r[s++] << f, f += 8;
          }
          switch (a.last = d & 1, d >>>= 1, f -= 1, d & 3) {
            case 0:
              a.mode = Id;
              break;
            case 1:
              if (dp(a), a.mode = Vn, t === Hn) {
                d >>>= 2, f -= 2;
                break e;
              }
              break;
            case 2:
              a.mode = Rd;
              break;
            case 3:
              e.msg = "invalid block type", a.mode = ce;
          }
          d >>>= 2, f -= 2;
          break;
        case Id:
          for (d >>>= f & 7, f -= f & 7; f < 32; ) {
            if (i === 0)
              break e;
            i--, d += r[s++] << f, f += 8;
          }
          if ((d & 65535) !== (d >>> 16 ^ 65535)) {
            e.msg = "invalid stored block lengths", a.mode = ce;
            break;
          }
          if (a.length = d & 65535, d = 0, f = 0, a.mode = Ec, t === Hn)
            break e;
        case Ec:
          a.mode = Nd;
        case Nd:
          if (b = a.length, b) {
            if (b > i && (b = i), b > o && (b = o), b === 0)
              break e;
            n.set(r.subarray(s, s + b), c), i -= b, s += b, o -= b, c += b, a.length -= b;
            break;
          }
          a.mode = mt;
          break;
        case Rd:
          for (; f < 14; ) {
            if (i === 0)
              break e;
            i--, d += r[s++] << f, f += 8;
          }
          if (a.nlen = (d & 31) + 257, d >>>= 5, f -= 5, a.ndist = (d & 31) + 1, d >>>= 5, f -= 5, a.ncode = (d & 15) + 4, d >>>= 4, f -= 4, a.nlen > 286 || a.ndist > 30) {
            e.msg = "too many length or distance symbols", a.mode = ce;
            break;
          }
          a.have = 0, a.mode = Pd;
        case Pd:
          for (; a.have < a.ncode; ) {
            for (; f < 3; ) {
              if (i === 0)
                break e;
              i--, d += r[s++] << f, f += 8;
            }
            a.lens[X[a.have++]] = d & 7, d >>>= 3, f -= 3;
          }
          for (; a.have < 19; )
            a.lens[X[a.have++]] = 0;
          if (a.lencode = a.lendyn, a.lenbits = 7, S = { bits: a.lenbits }, O = Pr(X6, a.lens, 0, 19, a.lencode, 0, a.work, S), a.lenbits = S.bits, O) {
            e.msg = "invalid code lengths set", a.mode = ce;
            break;
          }
          a.have = 0, a.mode = Ld;
        case Ld:
          for (; a.have < a.nlen + a.ndist; ) {
            for (; m = a.lencode[d & (1 << a.lenbits) - 1], y = m >>> 24, v = m >>> 16 & 255, g = m & 65535, !(y <= f); ) {
              if (i === 0)
                break e;
              i--, d += r[s++] << f, f += 8;
            }
            if (g < 16)
              d >>>= y, f -= y, a.lens[a.have++] = g;
            else {
              if (g === 16) {
                for (C = y + 2; f < C; ) {
                  if (i === 0)
                    break e;
                  i--, d += r[s++] << f, f += 8;
                }
                if (d >>>= y, f -= y, a.have === 0) {
                  e.msg = "invalid bit length repeat", a.mode = ce;
                  break;
                }
                w = a.lens[a.have - 1], b = 3 + (d & 3), d >>>= 2, f -= 2;
              } else if (g === 17) {
                for (C = y + 3; f < C; ) {
                  if (i === 0)
                    break e;
                  i--, d += r[s++] << f, f += 8;
                }
                d >>>= y, f -= y, w = 0, b = 3 + (d & 7), d >>>= 3, f -= 3;
              } else {
                for (C = y + 7; f < C; ) {
                  if (i === 0)
                    break e;
                  i--, d += r[s++] << f, f += 8;
                }
                d >>>= y, f -= y, w = 0, b = 11 + (d & 127), d >>>= 7, f -= 7;
              }
              if (a.have + b > a.nlen + a.ndist) {
                e.msg = "invalid bit length repeat", a.mode = ce;
                break;
              }
              for (; b--; )
                a.lens[a.have++] = w;
            }
          }
          if (a.mode === ce)
            break;
          if (a.lens[256] === 0) {
            e.msg = "invalid code -- missing end-of-block", a.mode = ce;
            break;
          }
          if (a.lenbits = 9, S = { bits: a.lenbits }, O = Pr(Ou, a.lens, 0, a.nlen, a.lencode, 0, a.work, S), a.lenbits = S.bits, O) {
            e.msg = "invalid literal/lengths set", a.mode = ce;
            break;
          }
          if (a.distbits = 6, a.distcode = a.distdyn, S = { bits: a.distbits }, O = Pr(Iu, a.lens, a.nlen, a.ndist, a.distcode, 0, a.work, S), a.distbits = S.bits, O) {
            e.msg = "invalid distances set", a.mode = ce;
            break;
          }
          if (a.mode = Vn, t === Hn)
            break e;
        case Vn:
          a.mode = qn;
        case qn:
          if (i >= 6 && o >= 258) {
            e.next_out = c, e.avail_out = o, e.next_in = s, e.avail_in = i, a.hold = d, a.bits = f, q6(e, l), c = e.next_out, n = e.output, o = e.avail_out, s = e.next_in, r = e.input, i = e.avail_in, d = a.hold, f = a.bits, a.mode === mt && (a.back = -1);
            break;
          }
          for (a.back = 0; m = a.lencode[d & (1 << a.lenbits) - 1], y = m >>> 24, v = m >>> 16 & 255, g = m & 65535, !(y <= f); ) {
            if (i === 0)
              break e;
            i--, d += r[s++] << f, f += 8;
          }
          if (v && !(v & 240)) {
            for (T = y, Z = v, _ = g; m = a.lencode[_ + ((d & (1 << T + Z) - 1) >> T)], y = m >>> 24, v = m >>> 16 & 255, g = m & 65535, !(T + y <= f); ) {
              if (i === 0)
                break e;
              i--, d += r[s++] << f, f += 8;
            }
            d >>>= T, f -= T, a.back += T;
          }
          if (d >>>= y, f -= y, a.back += y, a.length = g, v === 0) {
            a.mode = Fd;
            break;
          }
          if (v & 32) {
            a.back = -1, a.mode = mt;
            break;
          }
          if (v & 64) {
            e.msg = "invalid literal/length code", a.mode = ce;
            break;
          }
          a.extra = v & 15, a.mode = jd;
        case jd:
          if (a.extra) {
            for (C = a.extra; f < C; ) {
              if (i === 0)
                break e;
              i--, d += r[s++] << f, f += 8;
            }
            a.length += d & (1 << a.extra) - 1, d >>>= a.extra, f -= a.extra, a.back += a.extra;
          }
          a.was = a.length, a.mode = Zd;
        case Zd:
          for (; m = a.distcode[d & (1 << a.distbits) - 1], y = m >>> 24, v = m >>> 16 & 255, g = m & 65535, !(y <= f); ) {
            if (i === 0)
              break e;
            i--, d += r[s++] << f, f += 8;
          }
          if (!(v & 240)) {
            for (T = y, Z = v, _ = g; m = a.distcode[_ + ((d & (1 << T + Z) - 1) >> T)], y = m >>> 24, v = m >>> 16 & 255, g = m & 65535, !(T + y <= f); ) {
              if (i === 0)
                break e;
              i--, d += r[s++] << f, f += 8;
            }
            d >>>= T, f -= T, a.back += T;
          }
          if (d >>>= y, f -= y, a.back += y, v & 64) {
            e.msg = "invalid distance code", a.mode = ce;
            break;
          }
          a.offset = g, a.extra = v & 15, a.mode = Dd;
        case Dd:
          if (a.extra) {
            for (C = a.extra; f < C; ) {
              if (i === 0)
                break e;
              i--, d += r[s++] << f, f += 8;
            }
            a.offset += d & (1 << a.extra) - 1, d >>>= a.extra, f -= a.extra, a.back += a.extra;
          }
          if (a.offset > a.dmax) {
            e.msg = "invalid distance too far back", a.mode = ce;
            break;
          }
          a.mode = Bd;
        case Bd:
          if (o === 0)
            break e;
          if (b = l - o, a.offset > b) {
            if (b = a.offset - b, b > a.whave && a.sane) {
              e.msg = "invalid distance too far back", a.mode = ce;
              break;
            }
            b > a.wnext ? (b -= a.wnext, p = a.wsize - b) : p = a.wnext - b, b > a.length && (b = a.length), h = a.window;
          } else
            h = n, p = c - a.offset, b = a.length;
          b > o && (b = o), o -= b, a.length -= b;
          do
            n[c++] = h[p++];
          while (--b);
          a.length === 0 && (a.mode = qn);
          break;
        case Fd:
          if (o === 0)
            break e;
          n[c++] = a.length, o--, a.mode = qn;
          break;
        case kc:
          if (a.wrap) {
            for (; f < 32; ) {
              if (i === 0)
                break e;
              i--, d |= r[s++] << f, f += 8;
            }
            if (l -= o, e.total_out += l, a.total += l, a.wrap & 4 && l && (e.adler = a.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
            a.flags ? be(a.check, n, l, c - l) : Vr(a.check, n, l, c - l)), l = o, a.wrap & 4 && (a.flags ? d : zd(d)) !== a.check) {
              e.msg = "incorrect data check", a.mode = ce;
              break;
            }
            d = 0, f = 0;
          }
          a.mode = Ud;
        case Ud:
          if (a.wrap && a.flags) {
            for (; f < 32; ) {
              if (i === 0)
                break e;
              i--, d += r[s++] << f, f += 8;
            }
            if (a.wrap & 4 && d !== (a.total & 4294967295)) {
              e.msg = "incorrect length check", a.mode = ce;
              break;
            }
            d = 0, f = 0;
          }
          a.mode = $d;
        case $d:
          O = ep;
          break e;
        case ce:
          O = Nu;
          break e;
        case Pu:
          return Ru;
        case Lu:
        default:
          return Ge;
      }
  return e.next_out = c, e.avail_out = o, e.next_in = s, e.avail_in = i, a.hold = d, a.bits = f, (a.wsize || l !== e.avail_out && a.mode < ce && (a.mode < kc || t !== _d)) && Fu(e, e.output, e.next_out, l - e.avail_out), u -= e.avail_in, l -= e.avail_out, e.total_in += u, e.total_out += l, a.total += l, a.wrap & 4 && l && (e.adler = a.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
  a.flags ? be(a.check, n, l, e.next_out - l) : Vr(a.check, n, l, e.next_out - l)), e.data_type = a.bits + (a.last ? 64 : 0) + (a.mode === mt ? 128 : 0) + (a.mode === Vn || a.mode === Ec ? 256 : 0), (u === 0 && l === 0 || t === _d) && O === _a && (O = ap), O;
}, up = (e) => {
  if (Ia(e))
    return Ge;
  let t = e.state;
  return t.window && (t.window = null), e.state = null, _a;
}, lp = (e, t) => {
  if (Ia(e))
    return Ge;
  const a = e.state;
  return a.wrap & 2 ? (a.head = t, t.done = !1, _a) : Ge;
}, bp = (e, t) => {
  const a = t.length;
  let r, n, s;
  return Ia(e) || (r = e.state, r.wrap !== 0 && r.mode !== is) ? Ge : r.mode === is && (n = 1, n = Vr(n, t, a, 0), n !== r.check) ? Nu : (s = Fu(e, t, a, a), s ? (r.mode = Pu, Ru) : (r.havedict = 1, _a));
};
var hp = Zu, pp = Du, mp = ju, yp = op, gp = Bu, _p = fp, vp = up, wp = lp, Ep = bp, kp = "pako inflate (from Nodeca project)", _t = {
  inflateReset: hp,
  inflateReset2: pp,
  inflateResetKeep: mp,
  inflateInit: yp,
  inflateInit2: gp,
  inflate: _p,
  inflateEnd: vp,
  inflateGetHeader: wp,
  inflateSetDictionary: Ep,
  inflateInfo: kp
};
function xp() {
  this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
}
var Tp = xp;
const Uu = Object.prototype.toString, {
  Z_NO_FLUSH: Sp,
  Z_FINISH: Cp,
  Z_OK: Wr,
  Z_STREAM_END: Sc,
  Z_NEED_DICT: Cc,
  Z_STREAM_ERROR: Ap,
  Z_DATA_ERROR: Hd,
  Z_MEM_ERROR: Op
} = lr;
function Cn(e) {
  this.options = $s.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, e || {});
  const t = this.options;
  t.raw && t.windowBits >= 0 && t.windowBits < 16 && (t.windowBits = -t.windowBits, t.windowBits === 0 && (t.windowBits = -15)), t.windowBits >= 0 && t.windowBits < 16 && !(e && e.windowBits) && (t.windowBits += 32), t.windowBits > 15 && t.windowBits < 48 && (t.windowBits & 15 || (t.windowBits |= 15)), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new Cu(), this.strm.avail_out = 0;
  let a = _t.inflateInit2(
    this.strm,
    t.windowBits
  );
  if (a !== Wr)
    throw new Error(ya[a]);
  if (this.header = new Tp(), _t.inflateGetHeader(this.strm, this.header), t.dictionary && (typeof t.dictionary == "string" ? t.dictionary = Kr.string2buf(t.dictionary) : Uu.call(t.dictionary) === "[object ArrayBuffer]" && (t.dictionary = new Uint8Array(t.dictionary)), t.raw && (a = _t.inflateSetDictionary(this.strm, t.dictionary), a !== Wr)))
    throw new Error(ya[a]);
}
Cn.prototype.push = function(e, t) {
  const a = this.strm, r = this.options.chunkSize, n = this.options.dictionary;
  let s, c, i;
  if (this.ended)
    return !1;
  for (t === ~~t ? c = t : c = t === !0 ? Cp : Sp, Uu.call(e) === "[object ArrayBuffer]" ? a.input = new Uint8Array(e) : a.input = e, a.next_in = 0, a.avail_in = a.input.length; ; ) {
    for (a.avail_out === 0 && (a.output = new Uint8Array(r), a.next_out = 0, a.avail_out = r), s = _t.inflate(a, c), s === Cc && n && (s = _t.inflateSetDictionary(a, n), s === Wr ? s = _t.inflate(a, c) : s === Hd && (s = Cc)); a.avail_in > 0 && s === Sc && a.state.wrap > 0 && e[a.next_in] !== 0; )
      _t.inflateReset(a), s = _t.inflate(a, c);
    switch (s) {
      case Ap:
      case Hd:
      case Cc:
      case Op:
        return this.onEnd(s), this.ended = !0, !1;
    }
    if (i = a.avail_out, a.next_out && (a.avail_out === 0 || s === Sc))
      if (this.options.to === "string") {
        let o = Kr.utf8border(a.output, a.next_out), d = a.next_out - o, f = Kr.buf2string(a.output, o);
        a.next_out = d, a.avail_out = r - d, d && a.output.set(a.output.subarray(o, o + d), 0), this.onData(f);
      } else
        this.onData(a.output.length === a.next_out ? a.output : a.output.subarray(0, a.next_out));
    if (!(s === Wr && i === 0)) {
      if (s === Sc)
        return s = _t.inflateEnd(this.strm), this.onEnd(s), this.ended = !0, !0;
      if (a.avail_in === 0)
        break;
    }
  }
  return !0;
};
Cn.prototype.onData = function(e) {
  this.chunks.push(e);
};
Cn.prototype.onEnd = function(e) {
  e === Wr && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = $s.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;
};
function Yi(e, t) {
  const a = new Cn(t);
  if (a.push(e), a.err)
    throw a.msg || ya[a.err];
  return a.result;
}
function Ip(e, t) {
  return t = t || {}, t.raw = !0, Yi(e, t);
}
var Np = Cn, Rp = Yi, Pp = Ip, Lp = Yi, jp = lr, Zp = {
  Inflate: Np,
  inflate: Rp,
  inflateRaw: Pp,
  ungzip: Lp,
  constants: jp
};
const { Deflate: gm, deflate: _m, deflateRaw: vm, gzip: Dp } = H6, { Inflate: wm, inflate: Em, inflateRaw: km, ungzip: Bp } = Zp;
var Fp = Dp, Up = Bp, Ir = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function $u(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function zu(e) {
  if (e.__esModule)
    return e;
  var t = e.default;
  if (typeof t == "function") {
    var a = function r() {
      if (this instanceof r) {
        var n = [null];
        n.push.apply(n, arguments);
        var s = Function.bind.apply(t, n);
        return new s();
      }
      return t.apply(this, arguments);
    };
    a.prototype = t.prototype;
  } else
    a = {};
  return Object.defineProperty(a, "__esModule", { value: !0 }), Object.keys(e).forEach(function(r) {
    var n = Object.getOwnPropertyDescriptor(e, r);
    Object.defineProperty(a, r, n.get ? n : {
      enumerable: !0,
      get: function() {
        return e[r];
      }
    });
  }), a;
}
var we = typeof globalThis < "u" && globalThis || typeof self < "u" && self || typeof we < "u" && we, Oe = {
  searchParams: "URLSearchParams" in we,
  iterable: "Symbol" in we && "iterator" in Symbol,
  blob: "FileReader" in we && "Blob" in we && function() {
    try {
      return new Blob(), !0;
    } catch {
      return !1;
    }
  }(),
  formData: "FormData" in we,
  arrayBuffer: "ArrayBuffer" in we
};
function $p(e) {
  return e && DataView.prototype.isPrototypeOf(e);
}
if (Oe.arrayBuffer)
  var zp = [
    "[object Int8Array]",
    "[object Uint8Array]",
    "[object Uint8ClampedArray]",
    "[object Int16Array]",
    "[object Uint16Array]",
    "[object Int32Array]",
    "[object Uint32Array]",
    "[object Float32Array]",
    "[object Float64Array]"
  ], Mp = ArrayBuffer.isView || function(e) {
    return e && zp.indexOf(Object.prototype.toString.call(e)) > -1;
  };
function An(e) {
  if (typeof e != "string" && (e = String(e)), /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(e) || e === "")
    throw new TypeError('Invalid character in header field name: "' + e + '"');
  return e.toLowerCase();
}
function Ji(e) {
  return typeof e != "string" && (e = String(e)), e;
}
function Xi(e) {
  var t = {
    next: function() {
      var a = e.shift();
      return { done: a === void 0, value: a };
    }
  };
  return Oe.iterable && (t[Symbol.iterator] = function() {
    return t;
  }), t;
}
function le(e) {
  this.map = {}, e instanceof le ? e.forEach(function(t, a) {
    this.append(a, t);
  }, this) : Array.isArray(e) ? e.forEach(function(t) {
    this.append(t[0], t[1]);
  }, this) : e && Object.getOwnPropertyNames(e).forEach(function(t) {
    this.append(t, e[t]);
  }, this);
}
le.prototype.append = function(e, t) {
  e = An(e), t = Ji(t);
  var a = this.map[e];
  this.map[e] = a ? a + ", " + t : t;
};
le.prototype.delete = function(e) {
  delete this.map[An(e)];
};
le.prototype.get = function(e) {
  return e = An(e), this.has(e) ? this.map[e] : null;
};
le.prototype.has = function(e) {
  return this.map.hasOwnProperty(An(e));
};
le.prototype.set = function(e, t) {
  this.map[An(e)] = Ji(t);
};
le.prototype.forEach = function(e, t) {
  for (var a in this.map)
    this.map.hasOwnProperty(a) && e.call(t, this.map[a], a, this);
};
le.prototype.keys = function() {
  var e = [];
  return this.forEach(function(t, a) {
    e.push(a);
  }), Xi(e);
};
le.prototype.values = function() {
  var e = [];
  return this.forEach(function(t) {
    e.push(t);
  }), Xi(e);
};
le.prototype.entries = function() {
  var e = [];
  return this.forEach(function(t, a) {
    e.push([a, t]);
  }), Xi(e);
};
Oe.iterable && (le.prototype[Symbol.iterator] = le.prototype.entries);
function Ac(e) {
  if (e.bodyUsed)
    return Promise.reject(new TypeError("Already read"));
  e.bodyUsed = !0;
}
function Mu(e) {
  return new Promise(function(t, a) {
    e.onload = function() {
      t(e.result);
    }, e.onerror = function() {
      a(e.error);
    };
  });
}
function Hp(e) {
  var t = new FileReader(), a = Mu(t);
  return t.readAsArrayBuffer(e), a;
}
function Vp(e) {
  var t = new FileReader(), a = Mu(t);
  return t.readAsText(e), a;
}
function qp(e) {
  for (var t = new Uint8Array(e), a = new Array(t.length), r = 0; r < t.length; r++)
    a[r] = String.fromCharCode(t[r]);
  return a.join("");
}
function Vd(e) {
  if (e.slice)
    return e.slice(0);
  var t = new Uint8Array(e.byteLength);
  return t.set(new Uint8Array(e)), t.buffer;
}
function Hu() {
  return this.bodyUsed = !1, this._initBody = function(e) {
    this.bodyUsed = this.bodyUsed, this._bodyInit = e, e ? typeof e == "string" ? this._bodyText = e : Oe.blob && Blob.prototype.isPrototypeOf(e) ? this._bodyBlob = e : Oe.formData && FormData.prototype.isPrototypeOf(e) ? this._bodyFormData = e : Oe.searchParams && URLSearchParams.prototype.isPrototypeOf(e) ? this._bodyText = e.toString() : Oe.arrayBuffer && Oe.blob && $p(e) ? (this._bodyArrayBuffer = Vd(e.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : Oe.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(e) || Mp(e)) ? this._bodyArrayBuffer = Vd(e) : this._bodyText = e = Object.prototype.toString.call(e) : this._bodyText = "", this.headers.get("content-type") || (typeof e == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : Oe.searchParams && URLSearchParams.prototype.isPrototypeOf(e) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
  }, Oe.blob && (this.blob = function() {
    var e = Ac(this);
    if (e)
      return e;
    if (this._bodyBlob)
      return Promise.resolve(this._bodyBlob);
    if (this._bodyArrayBuffer)
      return Promise.resolve(new Blob([this._bodyArrayBuffer]));
    if (this._bodyFormData)
      throw new Error("could not read FormData body as blob");
    return Promise.resolve(new Blob([this._bodyText]));
  }, this.arrayBuffer = function() {
    if (this._bodyArrayBuffer) {
      var e = Ac(this);
      return e || (ArrayBuffer.isView(this._bodyArrayBuffer) ? Promise.resolve(
        this._bodyArrayBuffer.buffer.slice(
          this._bodyArrayBuffer.byteOffset,
          this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
        )
      ) : Promise.resolve(this._bodyArrayBuffer));
    } else
      return this.blob().then(Hp);
  }), this.text = function() {
    var e = Ac(this);
    if (e)
      return e;
    if (this._bodyBlob)
      return Vp(this._bodyBlob);
    if (this._bodyArrayBuffer)
      return Promise.resolve(qp(this._bodyArrayBuffer));
    if (this._bodyFormData)
      throw new Error("could not read FormData body as text");
    return Promise.resolve(this._bodyText);
  }, Oe.formData && (this.formData = function() {
    return this.text().then(Gp);
  }), this.json = function() {
    return this.text().then(JSON.parse);
  }, this;
}
var Kp = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
function Wp(e) {
  var t = e.toUpperCase();
  return Kp.indexOf(t) > -1 ? t : e;
}
function va(e, t) {
  if (!(this instanceof va))
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  t = t || {};
  var a = t.body;
  if (e instanceof va) {
    if (e.bodyUsed)
      throw new TypeError("Already read");
    this.url = e.url, this.credentials = e.credentials, t.headers || (this.headers = new le(e.headers)), this.method = e.method, this.mode = e.mode, this.signal = e.signal, !a && e._bodyInit != null && (a = e._bodyInit, e.bodyUsed = !0);
  } else
    this.url = String(e);
  if (this.credentials = t.credentials || this.credentials || "same-origin", (t.headers || !this.headers) && (this.headers = new le(t.headers)), this.method = Wp(t.method || this.method || "GET"), this.mode = t.mode || this.mode || null, this.signal = t.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && a)
    throw new TypeError("Body not allowed for GET or HEAD requests");
  if (this._initBody(a), (this.method === "GET" || this.method === "HEAD") && (t.cache === "no-store" || t.cache === "no-cache")) {
    var r = /([?&])_=[^&]*/;
    if (r.test(this.url))
      this.url = this.url.replace(r, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
    else {
      var n = /\?/;
      this.url += (n.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
    }
  }
}
va.prototype.clone = function() {
  return new va(this, { body: this._bodyInit });
};
function Gp(e) {
  var t = new FormData();
  return e.trim().split("&").forEach(function(a) {
    if (a) {
      var r = a.split("="), n = r.shift().replace(/\+/g, " "), s = r.join("=").replace(/\+/g, " ");
      t.append(decodeURIComponent(n), decodeURIComponent(s));
    }
  }), t;
}
function Yp(e) {
  var t = new le(), a = e.replace(/\r?\n[\t ]+/g, " ");
  return a.split("\r").map(function(r) {
    return r.indexOf(`
`) === 0 ? r.substr(1, r.length) : r;
  }).forEach(function(r) {
    var n = r.split(":"), s = n.shift().trim();
    if (s) {
      var c = n.join(":").trim();
      t.append(s, c);
    }
  }), t;
}
Hu.call(va.prototype);
function ot(e, t) {
  if (!(this instanceof ot))
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  t || (t = {}), this.type = "default", this.status = t.status === void 0 ? 200 : t.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = t.statusText === void 0 ? "" : "" + t.statusText, this.headers = new le(t.headers), this.url = t.url || "", this._initBody(e);
}
Hu.call(ot.prototype);
ot.prototype.clone = function() {
  return new ot(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new le(this.headers),
    url: this.url
  });
};
ot.error = function() {
  var e = new ot(null, { status: 0, statusText: "" });
  return e.type = "error", e;
};
var Jp = [301, 302, 303, 307, 308];
ot.redirect = function(e, t) {
  if (Jp.indexOf(t) === -1)
    throw new RangeError("Invalid status code");
  return new ot(null, { status: t, headers: { location: e } });
};
var ca = we.DOMException;
try {
  new ca();
} catch {
  ca = function(e, t) {
    this.message = e, this.name = t;
    var a = Error(e);
    this.stack = a.stack;
  }, ca.prototype = Object.create(Error.prototype), ca.prototype.constructor = ca;
}
function Vu(e, t) {
  return new Promise(function(a, r) {
    var n = new va(e, t);
    if (n.signal && n.signal.aborted)
      return r(new ca("Aborted", "AbortError"));
    var s = new XMLHttpRequest();
    function c() {
      s.abort();
    }
    s.onload = function() {
      var o = {
        status: s.status,
        statusText: s.statusText,
        headers: Yp(s.getAllResponseHeaders() || "")
      };
      o.url = "responseURL" in s ? s.responseURL : o.headers.get("X-Request-URL");
      var d = "response" in s ? s.response : s.responseText;
      setTimeout(function() {
        a(new ot(d, o));
      }, 0);
    }, s.onerror = function() {
      setTimeout(function() {
        r(new TypeError("Network request failed"));
      }, 0);
    }, s.ontimeout = function() {
      setTimeout(function() {
        r(new TypeError("Network request failed"));
      }, 0);
    }, s.onabort = function() {
      setTimeout(function() {
        r(new ca("Aborted", "AbortError"));
      }, 0);
    };
    function i(o) {
      try {
        return o === "" && we.location.href ? we.location.href : o;
      } catch {
        return o;
      }
    }
    s.open(n.method, i(n.url), !0), n.credentials === "include" ? s.withCredentials = !0 : n.credentials === "omit" && (s.withCredentials = !1), "responseType" in s && (Oe.blob ? s.responseType = "blob" : Oe.arrayBuffer && n.headers.get("Content-Type") && n.headers.get("Content-Type").indexOf("application/octet-stream") !== -1 && (s.responseType = "arraybuffer")), t && typeof t.headers == "object" && !(t.headers instanceof le) ? Object.getOwnPropertyNames(t.headers).forEach(function(o) {
      s.setRequestHeader(o, Ji(t.headers[o]));
    }) : n.headers.forEach(function(o, d) {
      s.setRequestHeader(d, o);
    }), n.signal && (n.signal.addEventListener("abort", c), s.onreadystatechange = function() {
      s.readyState === 4 && n.signal.removeEventListener("abort", c);
    }), s.send(typeof n._bodyInit > "u" ? null : n._bodyInit);
  });
}
Vu.polyfill = !0;
we.fetch || (we.fetch = Vu, we.Headers = le, we.Request = va, we.Response = ot);
var Xp = self.fetch.bind(self);
const Qp = /* @__PURE__ */ $u(Xp);
var qu = { exports: {} };
(function(e) {
  (function(t, a, r) {
    e.exports ? e.exports = r() : a[t] = r();
  })("urljoin", Ir, function() {
    function t(a) {
      var r = [];
      if (a.length === 0)
        return "";
      if (typeof a[0] != "string")
        throw new TypeError("Url must be a string. Received " + a[0]);
      if (a[0].match(/^[^/:]+:\/*$/) && a.length > 1) {
        var n = a.shift();
        a[0] = n + a[0];
      }
      a[0].match(/^file:\/\/\//) ? a[0] = a[0].replace(/^([^/:]+):\/*/, "$1:///") : a[0] = a[0].replace(/^([^/:]+):\/*/, "$1://");
      for (var s = 0; s < a.length; s++) {
        var c = a[s];
        if (typeof c != "string")
          throw new TypeError("Url must be a string. Received " + c);
        c !== "" && (s > 0 && (c = c.replace(/^[\/]+/, "")), s < a.length - 1 ? c = c.replace(/[\/]+$/, "") : c = c.replace(/[\/]+$/, "/"), r.push(c));
      }
      var i = r.join("/");
      i = i.replace(/\/(\?|&|#[^!])/g, "$1");
      var o = i.split("?");
      return i = o.shift() + (o.length > 0 ? "?" : "") + o.join("&"), i;
    }
    return function() {
      var a;
      return typeof arguments[0] == "object" ? a = arguments[0] : a = [].slice.call(arguments), t(a);
    };
  });
})(qu);
var e3 = qu.exports;
const Ku = /* @__PURE__ */ $u(e3);
var t3 = Object.defineProperty, pe = (e, t) => {
  for (var a in t)
    t3(e, a, { get: t[a], enumerable: !0 });
}, Wu = {};
pe(Wu, {
  ALPHA: () => f3,
  API_VERSION: () => sl,
  BETA: () => u3,
  BaseUrl: () => cl,
  CONSTANT_POINTS: () => b3,
  EC_ORDER: () => d3,
  FIELD_GEN: () => i3,
  FIELD_PRIME: () => c3,
  FIELD_SIZE: () => o3,
  HEX_STR_TRANSACTION_VERSION_1: () => al,
  HEX_STR_TRANSACTION_VERSION_2: () => rl,
  IS_BROWSER: () => Ms,
  MASK_250: () => nl,
  MASK_251: () => s3,
  MAX_ECDSA_VAL: () => l3,
  NetworkName: () => il,
  StarknetChainId: () => ol,
  TransactionHashPrefix: () => dl,
  UDC: () => ia,
  ZERO: () => Ze
});
var a3 = {};
pe(a3, {
  IS_BROWSER: () => Ms,
  addHexPrefix: () => Re,
  arrayBufferToString: () => eo,
  atobUniversal: () => Yu,
  btoaUniversal: () => Ju,
  buf2hex: () => Xu,
  calcByteLength: () => el,
  padLeft: () => Qu,
  pascalToSnake: () => ii,
  removeHexPrefix: () => pr,
  sanitizeBytes: () => tl,
  sanitizeHex: () => n3,
  stringToArrayBuffer: () => Gu,
  utf8ToArray: () => Hs
});
var Ms = typeof window < "u", Qi = "0";
function eo(e) {
  return new Uint8Array(e).reduce((t, a) => t + String.fromCharCode(a), "");
}
function Gu(e) {
  return Uint8Array.from(e, (t) => t.charCodeAt(0));
}
function Yu(e) {
  return Ms ? Gu(atob(e)) : Buffer.from(e, "base64");
}
function Ju(e) {
  return Ms ? btoa(eo(e)) : Buffer.from(e).toString("base64");
}
function Xu(e) {
  return [...e].map((t) => t.toString(16).padStart(2, "0")).join("");
}
function pr(e) {
  return e.replace(/^0x/i, "");
}
function Re(e) {
  return `0x${pr(e)}`;
}
function r3(e, t, a, r = Qi) {
  const n = t - e.length;
  let s = e;
  if (n > 0) {
    const c = r.repeat(n);
    s = a ? c + e : e + c;
  }
  return s;
}
function Qu(e, t, a = Qi) {
  return r3(e, t, !0, a);
}
function el(e, t = 8) {
  const a = e % t;
  return a ? (e - a) / t * t + t : e;
}
function tl(e, t = 8, a = Qi) {
  return Qu(e, el(e.length, t), a);
}
function n3(e) {
  return e = pr(e), e = tl(e, 2), e && (e = Re(e)), e;
}
function Hs(e) {
  return new TextEncoder().encode(e);
}
var ii = (e) => e.split(/(?=[A-Z])/).join("_").toUpperCase(), al = "0x1", rl = "0x2", Ze = 0n, nl = 2n ** 250n - 1n, s3 = 2n ** 251n, sl = Ze, cl = /* @__PURE__ */ ((e) => (e.SN_MAIN = "https://alpha-mainnet.starknet.io", e.SN_GOERLI = "https://alpha4.starknet.io", e.SN_GOERLI2 = "https://alpha4-2.starknet.io", e))(cl || {}), il = /* @__PURE__ */ ((e) => (e.SN_MAIN = "SN_MAIN", e.SN_GOERLI = "SN_GOERLI", e.SN_GOERLI2 = "SN_GOERLI2", e))(il || {}), ol = /* @__PURE__ */ ((e) => (e.SN_MAIN = "0x534e5f4d41494e", e.SN_GOERLI = "0x534e5f474f45524c49", e.SN_GOERLI2 = "0x534e5f474f45524c4932", e))(ol || {}), dl = /* @__PURE__ */ ((e) => (e.DECLARE = "0x6465636c617265", e.DEPLOY = "0x6465706c6f79", e.DEPLOY_ACCOUNT = "0x6465706c6f795f6163636f756e74", e.INVOKE = "0x696e766f6b65", e.L1_HANDLER = "0x6c315f68616e646c6572", e))(dl || {}), ia = {
  ADDRESS: "0x041a78e741e5af2fec34b695679bc6891742439f7afb8484ecd7766661ad02bf",
  ENTRYPOINT: "deployContract"
}, c3 = "800000000000011000000000000000000000000000000000000000000000001", i3 = "3", o3 = 251, d3 = "800000000000010FFFFFFFFFFFFFFFFB781126DCAE7B2321E66A241ADC64D2F", f3 = "1", u3 = "6F21413EFBE40DE150E596D72F7A8C5609AD26C15C915C1F4CDFCB99CEE9E89", l3 = "800000000000000000000000000000000000000000000000000000000000000", b3 = [
  [
    "49ee3eba8c1600700ee1b87eb599f16716b0b1022947733551fde4050ca6804",
    "3ca0cfe4b3bc6ddf346d49d06ea0ed34e621062c0e056c1d0405d266e10268a"
  ],
  [
    "1ef15c18599971b7beced415a40f0c7deacfd9b0d1819e03d723d8bc943cfca",
    "5668060aa49730b7be4801df46ec62de53ecd11abe43a32873000c36e8dc1f"
  ],
  [
    "234287dcbaffe7f969c748655fca9e58fa8120b6d56eb0c1080d17957ebe47b",
    "3b056f100f96fb21e889527d41f4e39940135dd7a6c94cc6ed0268ee89e5615"
  ],
  [
    "3909690e1123c80678a7ba0fde0e8447f6f02b3f6b960034d1e93524f8b476",
    "7122e9063d239d89d4e336753845b76f2b33ca0d7f0c1acd4b9fe974994cc19"
  ],
  [
    "40fd002e38ea01a01b2702eb7c643e9decc2894cbf31765922e281939ab542c",
    "109f720a79e2a41471f054ca885efd90c8cfbbec37991d1b6343991e0a3e740"
  ],
  [
    "2f52066635c139fc2f64eb0bd5e3fd7a705f576854ec4f00aa60361fddb981b",
    "6d78a24d8a5f97fc600318ce16b3c840315979c3273078ec1a285f217ee6a26"
  ],
  [
    "6a0767a1fd60d5b9027a35af1b68e57a1c366ebcde2006cdd07af27043ef674",
    "606b72c0ca0498b8c1817ed7922d550894c324f5efdfc85a19a1ae382411ca2"
  ],
  [
    "7fa463ee2a2d6a585d5c3358918270f6c28c66df1f86803374d1edf3819cc62",
    "a996edf01598832e644e1cae9a37288865ad80e2787f9bf958aceccc99afae"
  ],
  [
    "3d4da70d1540da597dbae1651d28487604a4e66a4a1823b97e8e9639393dbec",
    "45cdef70c35d3b6f0a2273a9886ccb6306d813e8204bdfd30b4efee63c8a3f9"
  ],
  [
    "1e448fdbcd9896c6fbf5f36cb7e7fcb77a751ff2d942593cae023363cc7750e",
    "30c81da0f3a8cb64468eaa491c7ae7b4842b62cb4148820da211afc4caffb3a"
  ],
  [
    "6531acf1a7cb90a4eb27de0b7f915e387a3b0fd063ba6e1289b91f48411be26",
    "31330f5daa091889981a3ea782ae997f5f171336ed0487a03f051551a2cafa2"
  ],
  [
    "54be016394d5662d67d7e82f5e889ed2f97ccf95d911f57dd2362c4040ed4f4",
    "c6cb184053f054d6a59c1bf0986d17090d25089b3fdcdaf185edc87ef113e5"
  ],
  [
    "35b9ecd0499ca1d5d42dcbb0c6b4042b3733c64b607ca711e706e786ef2afc6",
    "5624b476a5b21c3a544f0712d4817b06ad380a5a6529d323bf64da8ef862d8d"
  ],
  [
    "4ce0378e3ee8f77ed58f2ddbd8bb7676c8a38bfb1d3694c275254bd8ca38e23",
    "5a16fcbff0769c9cf2b02c31621878ec819fff4b8231bff82c6183db2746820"
  ],
  [
    "648d5c6f98680a1b926bfeb01c00224c56fdcf751b251c4449c8a94f425cfcf",
    "72c05ac793cd1620a833fbe2214d36900ebe446e095c62fcb740937f98cca8c"
  ],
  [
    "bd09be3e4e1af8a14189977e334f097c18e4a8bf42577ef5aafa0f807bd89b",
    "6e0e72ed7eb65c86cee29c411fb4761122558ee81013344ba8509c49de9f9b6"
  ],
  [
    "35ea4e339b44ae7724419bdfbe07022253137a4afb7cbaffad341ea61249357",
    "3665d676a026a174f367bb4417780e53a7803cb02d0db32eb4545c267c42f14"
  ],
  [
    "36457bc744f42e697b825c2d1afd8f4029d696a4514710f81da52d88e178643",
    "7c93715896735492a68c7969a024b3a8fd538bffc1521538107de1a5f13ce9c"
  ],
  [
    "5b3a08ebcf9c109cc9082f70d9df2b9c11b5428ee23917b4e790c4c10f6e661",
    "9d7b42ab0c20f5510df7ea5e196eec99342739077e9a168198c89da859753"
  ],
  [
    "21883ef8580fc06e59481955d52ece3aca6e82c8c9fc58e216dcf46f96990c6",
    "51a6423543e6e8a43e71da34cd90f5b520b8d33b67c4bf857573ab9e301aa4c"
  ],
  [
    "19e86b77f9b581e81092b305c852faf53940a8f15f0a6990c414f04c0fa7ef9",
    "515630e35d4398c9c79fc4ee08e1023fa47d8e03c6e7819c6d2ccef45398fa"
  ],
  [
    "888ab8eb4c31bb2ac5b54aa320dbe1a69c96b864e8a5f54d89c1d1a6b86c24",
    "730e148467f6a55ce22c5296f5380df88f38de76ef0b2de844cd3094aaaf3ea"
  ],
  [
    "75e79ff13a894e7120dac17b7429c0c32ce7828f726c9973728c0977a5f5977",
    "4960526e59c1c736561a201bc56f7d762641b39f609d273cc996f5d9197cfb8"
  ],
  [
    "640fe009249115d7254f72ecafb3006139e4bed7e9041af51458c737282d1d5",
    "3cc6c978a575246e2ce4f7ef1fcc7f63085db9ff98a1b1f3fe374087c0332c"
  ],
  [
    "6d6fd09ccab7c26de9b3906191235deb5c34685580c488275356a05e209ca96",
    "7157f81a34213dd8f91dea4f6df1bcfabc4ee091a3049eeeb3b7923d39b8645"
  ],
  [
    "5531ca1d00f151d71da820918f74caf2985b24dca20e124721fff507b5a5876",
    "518529643d3f25e47f72c322223ba60a63d6bfe78cf3f612215d9c19bf29200"
  ],
  [
    "6192d454e4f8fe212bdfccd5b15dd5056d7622ffe456c6c67e5a7265aea49c4",
    "2377a45dc630017ae863cb968ddb38333a70c7946d8684e6d7a6213f634b7bc"
  ],
  [
    "542fb44b4ef3640a64fdb22a2560fb26668065c069cf31d1df424819a39ff18",
    "5dbae9b0948e0361aea443503840341c322aa1a1366ce5390e71bf161f78f8c"
  ],
  [
    "299ff3e3412a7eb4cb4a3051b07b1be2e7b1c4b789f39ffb52cba3d048b71de",
    "1951d3175c02761b291d86b6c0a08387ad5e2a2130ccc33c852530572cb3958"
  ],
  [
    "628ce3f5367dadc1411133e55eb25e2e3c2880d6e28754a5cb1c5d109627e73",
    "ae3e9b7d50964e28bd15380400b7659b87affdef5d2586cbefcd9be7d67c0d"
  ],
  [
    "6ea54aff064895eccf9db2283225d62044ae67621192b3346338948382f5933",
    "6431507e51aadacfaf39f102a8ff387756e9b5e1bc8323d44acae55130d93db"
  ],
  [
    "28097d50d175a6235320fe8cfe138dd9e46895d189582e472c38ad7a67d923a",
    "7f9eab4133d7d09a7ff63368d6135c26262b62336eca1b5ca33f2096ce388ba"
  ],
  [
    "619fd09cdd6ff4323973f256c2cbdcb224f7f25b8aef623af2d4a0105e62e02",
    "2c95f0ae11d47eeae1bc7f1350f75f9185c5bc840382ceb38a797cae9c40308"
  ],
  [
    "641c18982ced304512a3f2395942a38add0d6a7156229c2a7c8b8dfbe9beb96",
    "6f6288c9c659b6af5ac975f4180deffe53d516399b2cc62f31732e9d4ba9837"
  ],
  [
    "58ab546e51fe49fc5a382e4064a2bd6cfc268904412f86c26de14f28a71d0f2",
    "124b7217943e7e328408e8afdfa7da00dcbc94a2bb85fd8e01fb162d2c2c0a9"
  ],
  [
    "a82c2fdedbb26c3c762a12f7e86b0e01e65320e0a25a8399d665f6e266bf74",
    "1a1de28e253f3e10f44d0111e8074f882d7f42e5900780ccbdc31da372d3fd8"
  ],
  [
    "744c725a7455a992e3cf5bd007bc234dd4668dba285f553f38350ad94c1615b",
    "7f721a87f48798bdc4a9c0eb88559e2ad7a74112fd901e70ea159e67a9c33f"
  ],
  [
    "434df142ddaa60f7881b6348d91687de40457de7ccfb07f0304b9e820705d0c",
    "7fae425e3b53f97dd1f5b20e49ed9fe24ff1efc341ba5e017ac89cf8df0cc39"
  ],
  [
    "7a1e2b809dff46277021cbc376f79c37e1b683bbd6bca5317014f0dc0e1ae73",
    "56790278a231912c334eff05281e08af1558e85516b4411ef64647c13bea431"
  ],
  [
    "4931b7990348d41cf8907be79f45bb7991fd18f8a57868351c92fa7a34cbcd7",
    "ca35091815cdf0837d396e25aad6052ad32d497a33b123256cffdc008bc50e"
  ],
  [
    "250b815d352fd89f8210b624b147ea7d0a4f47bcac49f3ac9b777840da93ebe",
    "1173f10e9691948b7da7632f328520455aadcba46e017f891e0a1d7da2bef04"
  ],
  [
    "2223b85032fa67292f6e1f822628e6756e5c3cc08fc252ab88d63d624e4dfb2",
    "55619ba96a7dcec77832fcb22cd5c21c7dcebc0280d730cba0002b67e0a8c63"
  ],
  [
    "249b131e04de73af9820d3e22492d9ec51bdc0c4c4f34d95352fa44dd61f245",
    "7576d3b5d136368ff01170a77d8286d0d1c7c40688862fb40813b4af3c6065e"
  ],
  [
    "6777915d9b4769027eb7e04733f8a2d669c84fe06080f55e8a55674dfbf9efb",
    "640d0ff384c9635e1af364760f104e058e3c86209fa9d2320aeac887b2e02d8"
  ],
  [
    "2abe3f237681052f002414399111cf07f8421535af41251edc427a36b5b19c9",
    "636ce4deaf468a503ab20ccb2f7e5bdc98551656ebf53e9c7786b11dd9090be"
  ],
  [
    "4d5cc5414758ea1be55be779bd7da296c7e11f1564d9e8797ceea347c16f8ea",
    "1a680c4c410cf5ddc74e95ff2897c193edaaecce5b2cde4e96bbae5c0054eff"
  ],
  [
    "46c375c684b30adf4d51de81e92afee52b1a3847e177403372c82109373edca",
    "1eaadc5783c90a0261306423d52009e991126b3f620e9cb6cffca41ca096f4f"
  ],
  [
    "2ddfb71f51205888118cbabba8fd07d460a810289bfdeeb7118707e310cb152",
    "1fd905d07b3933be886f2518246bdafa6f33259a174668808223cd7c28183c7"
  ],
  [
    "386f3879960713d41fdb3b1e41bbebf26b1c0e27a9a75bb1adcc1a0d3e8547b",
    "2b21498c0f34ec6f17c720334dc0f36021c2f87afbbbc8847d0bd536eb265e5"
  ],
  [
    "407eae62c6c4de3b942195afec3f45efec71ddb5e6edee3d427631bcdbf9b90",
    "436e7f2d78268ef62c4172d2ff1469028bad1f1d0f97ab007064418e61caa8f"
  ],
  [
    "1b881175e21201d17e095e9b3966b354f47de8c1acee5177f5909e0fd72328f",
    "69954b1a9b8bfccf8ec384d32924518a935758f3d3662ef754bcc88f1f6f3ec"
  ],
  [
    "7d545a82bff003b8115be32a0c437f7c0a98f776bcf7fddb0392822844f3c5e",
    "34b6e53a9565a7daa010711f5bf72254a4e61da3e6a562210a9abc9e8b66d69"
  ],
  [
    "299b9fcd4fadfc4b6141457a3036aaa68501c23df579de26df69d4def89b913",
    "b95bf2c2bb303c38bb396382edc798ca6a4847e573ce19b7b08533d1912675"
  ],
  [
    "551f5a4dae4a341a3e20336a7d2f365ddd45849351ec6dd4fcbedfe4806d5d5",
    "5865c977a0ecf13ce85ae14c5c316872080bd36f0f614f56b6dfc7ece83792e"
  ],
  [
    "7a1d69c08e68c80ad8b310736e6247a53bcba0183b9b8798833bc696a0fb6e2",
    "3ce803a20ebb3b120d5eaf0ad64bed0522fad1a0f2ce39a5c5cbae98c4438f6"
  ],
  [
    "28acacc0bc41d84e83663f02b36981a2c8272ecd72d3901164be2affb09c504",
    "7a5aee0b160eaff5b5968ab1a0304ce58c3d5ae0148d9191c39e87668229e5b"
  ],
  [
    "1f78cfdbcc767b68e69a224a077468cdfcb0afd6952b85bccbdb96d1fb8500b",
    "4772ba173c6b583284eb001cfc2a124104833f464ff9df096443e10ef3e9dd4"
  ],
  [
    "2774108962ca9897e7f22c064d2ccedac4fef5fc9569331c27cdc336c95774b",
    "9e13d79b68e8dc8091c019618f5b07283a710ddf1733dc674a99fc32c12911"
  ],
  [
    "770d116415cd2c4ace0d8b721dd77e4a2ef766591f9ec9fa0b61304548994ed",
    "42165d93c82f687635aa2b68492b3adffd516beb4baa94520efa11467a209fd"
  ],
  [
    "5e6e4ece6621e2275415e1fda1e7c4f496de498b77c0b913073c6a6099394b9",
    "3d92ce044fc77fa227adc31f6fc17ef8b4ec1c5aafc44630c0d9195075bf56d"
  ],
  [
    "6e69c717b5d98807ff1e404a5187a9ceaf0110b83aa15a84f930928b1171825",
    "1ee7cfc3a9744d7fa380ba28604af9df33ac077724374c04588bd71fa16b177"
  ],
  [
    "404318f2d2ceb44f549c80f9d7de9879d8f7da4b81e7350c00e974ebf2daef1",
    "3934831b5af70d17a3f1da9d2931bd757e6acf2893236264fc7e0d92ff1a1cb"
  ],
  [
    "20dcb6f394fea6d549b2e75748f61b7ec03b6e52319cb14163373a9c22bb9dc",
    "106a8c96cfb95a331618b7416d1498554730499e194a58fbf63019890480fc7"
  ],
  [
    "119000f277ccee013e6bb121194ec1ab5460fb6a96eb702a14079865f4170aa",
    "1737a32f5415e8720a5606ec1dd4756f02e7c6817e3723b453d091f2d192773"
  ],
  [
    "45d0fb5cd95db76d05dec3faa12e467a308eabaad363a062353db3cd2d9b749",
    "ae08691b5b0cdd19ec499132421638f470f493320e4003d123ab1da761b965"
  ],
  [
    "1257b3e65cdfb6367c6d0942327e799bc66eb221e70c6573a9862889eb51c38",
    "593309fd45755dd2cc4afd2b9316bc4638b0c5ddb3009694fcb7b250d0c8a2f"
  ],
  [
    "186dcf9950f72e868014a8accf14aa36e82a7a2a29f86ba37f6632da4189db3",
    "55684c9f7a043fc523ed78f756f834b4db823d5e4161bd79602c17d55a5cd8c"
  ],
  [
    "58791d5569f282f5c3b01ecdc9388df7ba3ca223a2dc1eed5edaf2a1d302fb9",
    "6298d7dd51561a045bb4089deda9f40b2865589ed433e56d54554f8b45e79f0"
  ],
  [
    "13fd87144aa5aa4b24d5a7bf907d8280d15937fed262d41084898cb688fc28b",
    "3fa54367770cc4479a857411ddcabe86627b405ce1cd14ad3b2863bde13abe4"
  ],
  [
    "48118139445415f0c1879224e2dee744ed35280ff00537260402a1741ec3676",
    "4dfa39dadaabecfc54ecb7a25319444f8e952782d863790e42a9887064fc0c1"
  ],
  [
    "4ad031bb9eda84f2fe5d354c7948d41558ca657a04508654721810ee72ef158",
    "620ebd5d0086b92c6009a42777b946a351c2c7ba852b57d3c9905fc337459ef"
  ],
  [
    "4a34abb016ad8cb4575ea5bd28385d2348e5bcc0cbba90059f90f9c71f86e8b",
    "4f781829ad83f9ed1e1b6de0e5f4ac60dfdfe7f23cb4411e815817e705e52c8"
  ],
  [
    "7fc632d7512aab5356b7915dca854c8b12b369ab54f524fbce352f00eb9b9f9",
    "2ce80b944fc9158005f630b34385d50c3ad84450a9e1e529925b3211dd2a1de"
  ],
  [
    "65ed10347503cbc0216ca03f7536cca16b6abd18d332a9258685907f2e5c23f",
    "3be1a18c6bfa6f2f4898ebefad5a8e844c74626d5baa04a820d407fe28bbca6"
  ],
  [
    "1a8abba1be2e276cdd1f28c912280833a5ede1ec121738fcca47dc070dcc71d",
    "21b724378bc029a5199799df005922590d4e59cae52976f8e437bf6693eec4a"
  ],
  [
    "3a99c22dafcfe9004ebb674805736a26aeed7ed5d465ae37226dcbe270a972b",
    "5bf67552af08e1e6e2a24bf562c23225e89869cab9bef8becb3669175a3c94f"
  ],
  [
    "4a6a5e4b3501f2b7bbdd8da73ea81ffca347170bdfb6776a037cdd74c560fb4",
    "5af167ebb259c2da88740ec559ee04052bb66480b836cadd0e2590c32d7111b"
  ],
  [
    "6890d95308525f0bac9dc25cc1189eb92d29d4b3fe61bc8aee1c716ac17b1e8",
    "e6f23f78e882026b53ea4fac6950e56e3da461e52339eb43d2fdb2dade7ca9"
  ],
  [
    "748f4cf4f027efdeaed7c7f91ef3730ff2f2bb0bfc2db8f27aadde947f7d4d5",
    "3a1cbc550699411052c76293b8c41a3a8a1ecf12cbbc029a1b2b6ea986fca93"
  ],
  [
    "7321f3f581690922cd0dec40c9c352aae412ec2ccdf718f137f7786ab452cd3",
    "5be5130c9277cdb76d7409452438ec15d246b211dd1e276ee58e82a81c98fd4"
  ],
  [
    "6c4d6cb7e7ae70955224b8a912ff57ca218635a2436b36cee25dce8a5cdf51f",
    "32f8c03c6db3246946e432e4148e69f5628b200c6d7d72449df6eeac0998039"
  ],
  [
    "1dad5f2e795ea6fa5177f110989516eacf8fb37bd6a091c7c93f1d73a2fe309",
    "56b2298c538180e99dea3e171dbb5c6fba0bd0a9ed40537277c0c2373a8e2c4"
  ],
  [
    "1610605baacc9bc62c4cc923dc943347cfece7ae241e746fbe6c2c878221dbd",
    "431a82d657e0d109d00dea88cf3fa9b999845221b7b5590a20c40fc71368c1c"
  ],
  [
    "6a4f5c787fb09a5be2b04d2eafa1e6f3d3c863ee22960eb0b64f6eaf6659162",
    "14dbc3eaea6146ee7eaace5a91ed9430dad3a47e9ca2f68b455171f8fe6a7b3"
  ],
  [
    "738415b73e55412b0e582e45ff0d7bf4b1bf2922db581783fdcc75559f40e",
    "33825aeb3fd8459999eb418d15102ba5864b069c6ea517f0c6e9eab8d9aca47"
  ],
  [
    "2603e72ce53985c70782774057a17944f7b4ce224a809be4e2b5af3606aa1d8",
    "92822921809c42318f42dac4d773325f41c43069e990adac7818a45e2554dc"
  ],
  [
    "181cd967ab4615357cc96c82eae9152ce7598c1a1dfdd91a458bddb016ae9fe",
    "5d562fdaeb0e12647e230e50eaf216bed52fa73c6b7378821a3bfc4cd66d4ff"
  ],
  [
    "1121726069b9ef5954ba6490100b226e0be53fef3e071b7c58a1286174b789a",
    "4b25594cf4e9eb2d14b3f52f2661a9992234fc222c0a0d44517cb77deb9c16f"
  ],
  [
    "e543663969b915337f105f80995a77b356f1a51d8b4a4fb12d44364130e873",
    "34b2e3c009fdab4cb7349a580df2e64c0098a123280078e5da6623a9ec6b44f"
  ],
  [
    "4e2f8909bb62de5ef65600e61bbf969293815296b6e23702875e049b3ce5c45",
    "3cb81f2c21f22a7add26fa38a9ce5d9cce1bb251bd2698f90c34ff0a84f7af"
  ],
  [
    "37b546e403a1ba970c17b67c2f1361ab9c803f8d2b5cd93803014faa08861ed",
    "37079184ea46272f5809b523d060686633f7995167897a153be1772fd6566f6"
  ],
  [
    "27bddca77f7bd7f66b3693567a4238f2e6751d95b0bcb409f6b24d08f84798c",
    "6417a85cbfd6fc02df560d3963a241a986baacdfa423f65d7227ce49a96c57d"
  ],
  [
    "2de71a39aa043057d1bc66e45f804542acddf18f7a6d88c0d7fb0ca240debdf",
    "306c1ce39ab46300f7cca0f3a2fbfa77296a27e24bc66b0b8044968ec0ee413"
  ],
  [
    "307c877154364c0c03534e7327d5a88e1380ceef6481567ade37a14ee7c1a72",
    "3404bc7dbfb33b95d922d0693aaf9358f77888d7d95e773c38d83dbe2e5f995"
  ],
  [
    "79f09ff7c60850e5f5ea020722659a1ed27db4c95dca131f99552f785c8afbc",
    "40429528c099349b426ddbf129497176951a64a53db5f9d8bd2be0252cb22b2"
  ],
  [
    "4027dc6b56d446e5972f35464eeac85c5254ef377c902d9fe37aea841bb5292",
    "7c3ea37689ef679fa2f5c7e031a78e23d484a8317990fd34d44d95cc1db3717"
  ],
  [
    "645dbf78a3c228c4b7151450b5e65edb58e71f37e1e4bc5f471e0f1abd6d9c2",
    "15cfe7850f327b256e23b00627451560c5c6ab60db78d45b7ab286afb6f13ab"
  ],
  [
    "1503ca373757677ad1d911a2b599d01c46eb879d1ce21ae171c7e439846a85f",
    "583eb269b7030da6a0c324026919de3f9489d2ff6ae0e6320c36f05469ad66c"
  ],
  [
    "66e1819ba3ec4ad4ae9f7d7588d23baa004e29d3aad2393d52af204a81626ca",
    "505249980cbe6273b82ad5038fe04a981896f4117345ac1abcc67e2525c0ee4"
  ],
  [
    "5ec20dbb290254545f9292c0a8e4fbbfb80ad9aab0a0e0e9e9923f784d70ed1",
    "bdb1ca3a859227cf5d00eaae1f22584e826ed83b7ccdb65483ed5213dc4323"
  ],
  [
    "a5c1a5011f4b81c5c01ef0b07c0fbf0a166de77280f0ae241f2db6cba15194",
    "4444521fb9b33d7dfeb1247d0ee1a2b854ad166cb663d9dd2e686909362a689"
  ],
  [
    "1f35335de40e00c62642dac2fda8b30f071986ce4f11db849df11bc45ad4e0c",
    "7801a2c761b90fd4477ba0be9a775003d5dfcd959b1ed198b4681f15e7acbf"
  ],
  [
    "48db4798cf6821c1ffb8178b1d3bb6020e04186c96aaf4670972d367f4ed5f",
    "781019494df95b888f1578f1b4a3f8e125ea60eca47ef9207a10630671217a3"
  ],
  [
    "17f653d904210148a8e74d8e719a3061683c164aa6d79c902a19f185ab437bd",
    "6780e97985932c3860d810af1e065d454b1cb4be0e7ffe2d8cea7d52526e223"
  ],
  [
    "5c4d0c7432f9b0070436240f9855adae1467cdc9826952ae01b68cd52a3ad89",
    "1c5747f968ed91261b7ae9bf1023c999da9816e37de602d6a1a50d397752bff"
  ],
  [
    "6fedd7639fdaa2f7bad4ca0b391710f6f8a7e890250ae8ae4252bb8b39a1e58",
    "436a215f655a3fd3778b2335ffdc9aca6b98474e43d764c1f8362830b084f0e"
  ],
  [
    "7fbd45a889c5e9d127bb4f8474d6be7cb9796bbfff923b75e42a1ad4cae37d6",
    "484bd12622a6ba81cd53049c550d9ed682a8e765b656b1cbff9bbea637bd1f4"
  ],
  [
    "17d984d47937263f7966a3e7b1eea04071e678494bd749c9e02b48b3234f06d",
    "7b341ff08722c4e161005d0037204a7a2001fdda7af2cc1a0b04a027f115a0f"
  ],
  [
    "7f1822045db45ea07e1519c3ee1f7705915f35fe4dd8db1e8921b5d1c740edf",
    "33d41e06b93320ad1b3d9580380ec797a05dac3f1cc8008899110ebefde2f78"
  ],
  [
    "7b19453ecb74b7d0e2a66b9890ff73bfbbcd61a266abd6d82dbe665bf32f34d",
    "6dba2355420dac582b1f349609ea1c89b89bba2d1a68a0642f1dd12d86e73cb"
  ],
  [
    "273e82a15f395ddf2489a95685bec8bac62c4b459d1b28987d3cb27e4bc9128",
    "653375b48a4cf5d5b101c9ef533039bedce5dbeef3f59e8f168bdc99b06ca5f"
  ],
  [
    "3006c9e7fc6a553d8eb4e8a47ce9f10d1a39576ac255ae9e0a4ce3869e76212",
    "65fe9e2ef2aae608be309332d464f57e28f1df5de1a6a519751b056971f932e"
  ],
  [
    "5e8f384c8a4607fbe9789fcc52d54249d304d698562597d114c1d81452d3dee",
    "3c8bc78066b5d947dc1e405e326ee55ea606c7988f666748d259850fa259a22"
  ],
  [
    "7841b2102e9aa103fb53a642b3e167b21113ea44751ab38e0b5ef8312654db9",
    "71bf5c8308fcf9c4a7847494cd9bdd946fddf7d3a37e8bb0b201ff2343deb8e"
  ],
  [
    "40f68027420c11e3ade9aae041978dc18081c4f94943463aac92d887f922a62",
    "499c6062594a6c7e21a3cb91ea451813393bff365a27a08f1a515439b83cf42"
  ],
  [
    "6ce77a50d038b222634e87948df0590b79d66087b01e42b9b6d8fa30ebb1465",
    "35f5c46bb1be8555a93f155a174d54ec048c2ac8676e7c743054ddc52709d37"
  ],
  [
    "604f8b9f2dacb13d569262864063c2d4bb2b2cd716db6eeb2b1eeabc57746f6",
    "68c6799e24f3b44eec3049973445174727a66970f1614a782efa2b91ab1e457"
  ],
  [
    "73d620f3bfe77f672943d448d7dc05327adf64b8e7af50039c469d7f7c994c4",
    "4859deb36eaf0c802f0d1514602368143a33ec6ce8fd55248b59025debc6afb"
  ],
  [
    "3fd2bcd1c89d706a3647fbd354097f09c76636e93ae504973f944d8fc3bcc1",
    "677ef842cf5eb2444941f527abec567725e469469192354ad509a26ebb3d0e0"
  ],
  [
    "39222ea924ac17b533c72ffb2c47ffdc11d6a7f7c70fbde3a10fb0b8f35eb2f",
    "20dc4bd1089019bc1d7379b4feb3eae6eb5af59e9f253845da9fd633057e952"
  ],
  [
    "326f58994e1347f62e4102183215b5db956378d2f61f14aba4dec94577f53c",
    "7a03284c296003bbe05178a1d82efdb7b8125511d63e20e50aed789c2e52e1"
  ],
  [
    "53aa8939c74d4ee58f03bc88bace5a45c7bfcf27466201da05dc6723a5f5632",
    "2e32535ca7732904a048183247b04b426ecf9b39fc393a9cebe92fb1dc7a7f1"
  ],
  [
    "6cee1a03145e93b3e826e6067005f09c06099c98198c91c222407ba5c8c132e",
    "beaecad1274e7c6e5476a100c271aa1a6f86ee5a9fa5c2f26124d5886fa63"
  ],
  [
    "3ec659b8175e1be1bd5a252108714776b813e330393f587814f5f1f32a73332",
    "529a5cf9f8c237ae69a94217d173c8d19c156952041f5c980da557990863fa7"
  ],
  [
    "3d66ec5963d0c534d4139c8cef2e1ac48b3e7965fafabf58be26f903318af4e",
    "3d3f2de7a95f59b683725ee6283cbaf31f97c4b600df9a4621413223a468740"
  ],
  [
    "7fb38ace8e0932fac2ea0d3eb676db8d684db1817e2e4d59da7996ce398b4a",
    "68f92bd5768cdd4710249f9d49ef1d5654e497b9a4ba10bd2971366d83fb400"
  ],
  [
    "1c4a49314d6b4969cdd142c76ceb7682bfb868ace7f7568b0fc8635bda5a9fb",
    "5fc0519f1f4cc10b5771312458748c036313b87707ed0540026ac64a5955aa9"
  ],
  [
    "3073c95d08d3b97caea5f0be16b2789bee766f76b7e5499f8ce8f96abb0f344",
    "52a8974b4eb9a1f6a0ae2c83cb4715bf18d73f057255fcb3f63b74f7e78f590"
  ],
  [
    "44485b16d597a5de3604df6f7ed7e00b8aeef9e7e8dea8688255153b8bb16aa",
    "6cccb0ba170123266f24b5d93a744397dc2c44820edc4f8f5b9a0f5c9b3b940"
  ],
  [
    "7618f77b7b32d512688dd62e0b48231d9574c6361e8be353a7dc04f7c3a115e",
    "78ffcd16d80636381ca231aae70d99c9e20298b4f5388fd823ea9fa2b8ddfd9"
  ],
  [
    "7dc82fee1ef95cf5b3720fcc07f63246654bfe39762627839da40e51c75654d",
    "4c0ccdd70955da74558de20c88352df8a02aa97e4d5971c500e884740a8cb62"
  ],
  [
    "7fa5d460dc10cbb418b444d9bde97e92c70a99a222b99f244dccee7e62cc04c",
    "636163901baa5b7576c38c43407af578b8c4607e01e86011ae2dde587a89f84"
  ],
  [
    "758930d46006623a756c89bd0cc378f6a3c1f43c9a0edbb42274c35e75c16d2",
    "1d74dd9f81c2fec811b8cbd6168a745b0a111932b2a345265ef2853b50b6245"
  ],
  [
    "7332ee0626b044d664ef228f8cb84df7c643e52f6a2591ae1c9007ad61ec16e",
    "229bd8e630572cbdee54283234cf3e9f060e6382f99943bf234119d47b54470"
  ],
  [
    "78a16ef803aa20a075bb2f66c61bb2dae5698bebb94a0995fa74c3d53de1614",
    "246d588b68edb6fed96c128349908c42dcd64c46341b205e79f4aed9b5d3675"
  ],
  [
    "6e1933939bd03b67bba753cc0cbe7d2f25bad68c993887ef8c9e2fcd59b0647",
    "599413f7c204a11a5ce315eab11299ab7326603412bb00bc1c59ff75a37d6b4"
  ],
  [
    "4a79957a5a1888ad063b51c69565a2b48e8eb917183e220a1c8d3374526d30e",
    "1f092de0e069bba7fc5386e2e9a114c1618f88c4b95e220cd35ffe96f99fcad"
  ],
  [
    "3148aa3df9ece39aca84f59489f2710522216f14be6055ee0027529d1d55e2d",
    "617e9a52a92975db0ba1977f71116f7058a0d31b869ac7f3ee2fd80b0c5100c"
  ],
  [
    "5c1188e72384160ae39d07328346cda4f6c12d227448e6236f04dc971625287",
    "1643006eb3a3bc6aafd5f685cf054f2a572e6ca58c0118bcec0b833741f116d"
  ],
  [
    "3f72efc93c9b71adc4c51d8fc69d3940b20d08733af2b7d05140fdb1d1c1004",
    "7399259987c8f4ebfab46e522380707e58427d3962ee0c2a91760813f76d232"
  ],
  [
    "3129b34c03c51aa8f611e91d5cfcc9bd3ef108ee66e6d3ee35a0e0e50055bb",
    "563b18b5650085efb4cf179a029e6afff27b1d3091cd28eaa68d24fa1f801c6"
  ],
  [
    "16eac0f9fb4c67cf89a7fa4ee615bbe731d8edcb709a1b9b50c7d873a530f52",
    "7ff8288b6e199ca8f316192881424a37fb080c29daa76b1f0edaccaf580a80e"
  ],
  [
    "75f6b6028c43ce832f65d7e8e620d43b16cba215b4b94df5b60fc24e9655ee4",
    "35e9ccfaed2293a8b94b28de03bcb13eb64a26c831e26cc61a39b97969a2ff0"
  ],
  [
    "3c6152fe093bd6316897917ec56a218640ec1b2148f21db9b14fc7a5ff362e8",
    "6eef2df27ae7d63a28856b07b73e7aad7ca94f317201a1e675ffc6f9a1710dd"
  ],
  [
    "54e01b5fe4fd96052aad55b3f26b1d254dfc7e2525fffb9ae0a77eb8cc5579",
    "7c3d39232ab333675b219abc766ed9b4782c840e6b046614dedb8a619696eb0"
  ],
  [
    "d1e63f8ea8a76429cf254a6d3b668761f0dc572d4bfac4fd56d9eaf58fb6c0",
    "2bd0a84d3908a63085824c9329a0983913006ba155b56a58eb3f9becab29c45"
  ],
  [
    "2d6122f2a702edd4da7385b1580796a71d13bd72be94cfb3fec01149c006c2d",
    "70eb282fae992efa6f5915e578b640653549f23385ef3a29ab29b1b9b8ad63b"
  ],
  [
    "752fec14beaadb5ddbba6b3a17fcb86579fa588ef407fad0ea07dbb22a640d3",
    "3feb6728eca21a1e84e8f9f23010387a53a96a1cb62d86fb37996150a1299ef"
  ],
  [
    "63f94a92f27acde8f5ed949b459506f51d70c85bcc61a34d647264ecc53c65e",
    "37e5dce0646ee66f4fdb93b82d54d83a054948fa7d7fa74ab6b36246fc7383e"
  ],
  [
    "d6aa909287a2f05b9528690c741702c4c5f4d486c19a46c38215f52ef79c7b",
    "5ebe1128dd81093df4aca0df365d58adab848d1be1a94b95eeb649afd66a018"
  ],
  [
    "12866812b3053e2f7a9572bdaf5ef2b48c6fb62a0eed9ff0356df50e7d05557",
    "6785f7eb2cd1c120e4c7167b46861d10117040a2e9f2ca86a71e9d67df90613"
  ],
  [
    "46a730d05330b1b13673cb8a1b8f45460035e4a9f1a1751cfba099c4355c1c",
    "76fb0ec6cd16a8141cdcd875c8b2de9fce42d296072643d148ac7e7fa7472df"
  ],
  [
    "4bd4380a22900bd34835e0a908eacf4b6edb61eda0cf483f9212453b37e7516",
    "5e9551cd20d8d7ddbf4366880b7d5267385afa1966ff30da4baaf273b009d29"
  ],
  [
    "71f1994ad40baa2922424ae222663a64f93d8b67929e9a10f9e4c1ab19f3833",
    "85320fe68ec0d37cc19fdfd03589d66906ffa4046c80e1b094a85f27676346"
  ],
  [
    "5a63b1bf5232f28f808765c6be7ce1f81c52145b39f01c879fae0f4303bee61",
    "3bc5d6df68bb6d0577bf9ae2ae59ec0e9b2dc7dd56ea179fb38a41e853db950"
  ],
  [
    "161ded55ff1087032381e6c1449704f63ad2d88df82dfc44a71890fa09b3941",
    "78a52e0013842037274ea75daaf8eb4afc04ccc4b07bfaf3f5ee47d165e01b"
  ],
  [
    "1bfce5229c5fbff5c0f452a22317fcfcd9262f23df41840f84fe7d44cfba1a1",
    "66b387872c00e63c73006a955d42cf49c46c5708fc9d1579b9ae38341b24a3d"
  ],
  [
    "56d47dadc9cbd1dcb2ee3efcd5d4af5e6aea71df10815c68b54a14e81d11b44",
    "47e966ba54df48e9b612a903685e0060a67e4725402e8cb4cf654e54e813a3e"
  ],
  [
    "4b1c44438afd4ddf20a2cf612df2ee494ce84c7274c5529e857693e73018491",
    "430403bd31d8f0677e06abff7159384560f27b9622943fea1a3192f14bf40d4"
  ],
  [
    "7f7281728fc2214aa1dbf13176a4624b53814734abd570eb6ef7c7e32379606",
    "312da47be347fb3fa2c9089b38df372560dcace2effeeacab4d96ab11567295"
  ],
  [
    "16a28884a1be8183e0d3fc0db84a9afbf47126fd3be548c2a584aaafbfa7dfe",
    "7c3f57b3b895564ba562c1cd80b71fda6d2e611665c6ab87744f5390858fe24"
  ],
  [
    "323339f37b327a731232a9580e79952063c7c232bd1380146d8a83c285f4b8b",
    "4f16be1d983c7232f92cce6b9690695978d42cecc8eeb8c206e125d1098a265"
  ],
  [
    "624d26cbaa197e104eb83cebf2adeed09a5cdad359993fe5e3529d4d0def21d",
    "261b7da3cfb55c788977e0d8d640e3e93ae5a325d962ce85c816d7d32cfc430"
  ],
  [
    "f24ecb7ee83a3e28dab54a330dc93d0429a7aea36412e922dce8fbff40d60d",
    "b043e36a258d1df1d21b0cc7be9c4dcae1bd4ed326c110e668ac23d86805a6"
  ],
  [
    "686cea46b710bde1231483bfdbc700cfa3da6ecd5841c0e0c782f9ea24328ec",
    "7eb7407aa58edd6911c7c7e8d1e03bb52ead4a2415a0c33325872ff3a521dd6"
  ],
  [
    "3866ee1186264549df3dfcdf8705c0380c9372eef6d4081c2454d3aded1720e",
    "634c6d3e8eb8af652a4be73e3b613452c2213104ca875b66b4b15ee5b1716af"
  ],
  [
    "484c687cd2969a1d20a58cdfb9a60f280a473284503b1ecff5de514aaf8206b",
    "34d44d26b7427e51a646d1b924084762f5b461685450f21d6a472de565bebd8"
  ],
  [
    "203561333771fa0fe22c4033349f7b877d15b0542a5598e81e067968768247a",
    "2b6a533aff6e2163a36a2a89cb7415848bef48db40f952ffd380f47676707c2"
  ],
  [
    "2ffa6cca6233695760251206fc5e34c8d3692498589478cdd3d5b09f0b7c05d",
    "6c57d605478fa9626c4ed769554d075daa53e1a1d0bd4d94174d3bfeeb11ad6"
  ],
  [
    "5dccf0fa46a5571f204d0b033b45f299cbb3d9f80fded57253ea4f1c64faaef",
    "30a38e131ee8756ee5ea2a3e16618a5dbc28b5b9311308bf037ecc2039dfc7d"
  ],
  [
    "57b0a2eaebeafd950221facdd24790d7d1ab8883e5c5d55635f0d14a1ee4741",
    "7b41cc478fa6be38417271db8ed12efc0da6982552c1496025d2df0576bf4ad"
  ],
  [
    "611b5725101f611c387ccaa13889ecf3bb5595071a179ce350029bfca4ad7f1",
    "3129755977abc8995fec7eec1123a1561e429fde37ff36af002d3211831ecf4"
  ],
  [
    "1c06bbd0c52fdab9fcaf680c7a93fb821e538a2ed79f00f3c34d5afb9ea6b31",
    "3873d3bdfe0be0157bbc141198dc95497823cc222986d24c594b87bd48dc527"
  ],
  [
    "275cdbabc989c615130d36dabfa55ca9d539ed5f67c187444b0a9a12e5b7234",
    "2b7f723e68e579e551115d56f0ae71a3b787b843cc04a35b9f11084b006521"
  ],
  [
    "6cc702eb20f8b5940c7da71f8b1801f55c8c2d8e2e4a3c6c983f00bc1ffdd95",
    "5d15b3727bc66f3aba6d589acdd139fae115232eb845abe61fbdfc51341352e"
  ],
  [
    "44defb418700cee8c9bd696b872adb005490512d8bba081f8f99a9f15cc981c",
    "3b2072cdb1d919b2b65b5cb3557f0a3381d7ca293c267ca4a38f83e77bcc96e"
  ],
  [
    "fd83ce77b1578b3a9b8c3cbeaddb1504d2fd4a19c901c21ac65961224e4966",
    "110cbe64fc10c6b9c66f15ca406a35f50b723b35d83c5eb9797a57f8395f4f9"
  ],
  [
    "9dc6ff90e341875e113bbfb507724dc7095a280d2f32cb6ba61a1e0c2d2aef",
    "4aeb622896c852c2747454e8f172c9482955a42ecbe522d6ce07ecde79d0a51"
  ],
  [
    "71c58b0e47b9dd9107ebd8a8c8fa9f0534e78231bac612c1ddc7a94edf33eb7",
    "7f90edaf4792bf8334adbaa0f4ee7c654312725af188682d75f34874c4eccb9"
  ],
  [
    "1f6de1f14988778ceb2dfe844f92394f1f1e72fd1581ceb3bf336c95ce50345",
    "4f6007ed4e022d2ee9fe4ca8207c5f6c766c4f3b85260e941fb24ad0dcbf0bc"
  ],
  [
    "3ddc3ac25ede4a67a97547ed27dc920239b585fb3624177e2e8d59eba678115",
    "a9afd8f8bb759cbd1dff2addc63f47da4ba1291ea34229c09c0637dc5c8d24"
  ],
  [
    "c56b0269d8431556e471cab9d70edda3a37b391696f107b2dc370631de51d",
    "729c52f6b134f733eb750c14bd9f95c077f0f6f6ff4005701e5bedc6544599d"
  ],
  [
    "44d32ce19ac6807cb22e4f25fe1486a36a13926f147fbfa054b63ff0446177d",
    "212a21e8c124c9cd37c80d2dd66913ceaa6b6f666522f115c39382b2d5925e8"
  ],
  [
    "35dfc16f3ae6ccc06a267bf6d931601e52f3e45359ffc513570b65b96adc4f",
    "74311d10f4bece01b5ae65a6affe5c931463aa1b73a3320eeb41bbb7bb1ff62"
  ],
  [
    "e0acd9d2d907031b319b80121dc90699d003d220ea785d50e5033cdb3b1a03",
    "3911ba78d6e507485d6374b0f7d2e6198f6462a7d6d3cf046404a07af690357"
  ],
  [
    "3c57918ca254c0cb7dac251ef4e10c7d82327969552eae15d26c4c52660922a",
    "5fd5f5ff3f14e671548074114c72c48409df8a2e71fc8aa3c8acb506e2a88df"
  ],
  [
    "222ad8b61e219ba2b581f606b7c996516850a46a3db72fe1f72b5a9be6c324c",
    "72015a5e2db648112abd284fd867b59fc5606645177d26cf6e9a655c9912d42"
  ],
  [
    "3c86d5d774bc614469768ad38f7be9a53e9a233942c5c553b82e49aae684764",
    "480febea8229e130dedffff89c11f3c43e11724e6bd89d5566d78752859d41c"
  ],
  [
    "adb73bb8352d0c10175df371f7868ef2c9e0c79ac788430c480c0f7d85c187",
    "60b564785248111502e6f39c4994d6293fac22bc25f4d764b2fb1957d3c9bd8"
  ],
  [
    "3836ab8b46cf4f453a22532c886940b982029b29c42adca90ded5bf77e6bcb9",
    "7b15e91d6355f147b171a90b064a9d8b2d7bf3699bbf4987664c61c950d8996"
  ],
  [
    "12ed96af1a97c45ec31f1531e96f6fb28a03ba52ab8484545fbe0dddc97bb32",
    "6d1f522b6c6cad0940cff8e23decc72bb8d4164696af031415508b025aa8be1"
  ],
  [
    "27382994ae5878223ef802e9b4882f481a1b4008f1eec8484483471f7aa742b",
    "c31750d242b3975b0026a0e86ccdd17d0f680a8c6f53f197fc25eb1f777917"
  ],
  [
    "431677eba3715455bc235557518a74f3b111a88844ef13e159ad44bc16de3e6",
    "30000e1eb6a17d9df776981e65c6e500fded1ac12003adc9446b269812c9197"
  ],
  [
    "4b563e6f42589671579eabfa2cda5502b361c46a5ac8d45c8ed44741a925b33",
    "627bdb41678443fdd1aa607709e9699b652308615f4bea760a3b79ee0d9ab5c"
  ],
  [
    "2932fd3f81fc973ca9def6b7f1bb50f980fe589187cfe9e9f52ba4d356cf2c8",
    "1e6bfd00fa976c4770263a227048214c38850fe0f059e7b3d2c7871ef07d68f"
  ],
  [
    "e44e4f3d96d9dec775b996be57e57fdc28e7c68023109b221c414a244a0dbc",
    "58b1e52fa274812e5184e00e9ad812bec2463140adfb4bea3b2d665867dcc9"
  ],
  [
    "7fcb89be1f4bec745887bb891e53fefd665c53d00a9e74de16b8a7e1f7adfb5",
    "74af0b06633f779897e199609c71cc5649bbb65bc2c0abd4c678f0480c198d1"
  ],
  [
    "62a381ffb904ea3ff4d451d4c8459457cdbc3dc2fd2da646a95d8c1e90c0b7b",
    "1ba058658e09db9e319fa73de8ab4a992b71e4efc22c273725bdcab84e2a315"
  ],
  [
    "1b0fbb7a84c67e668450a54449c7a46261a2d355589f8b84ebfbaf9a77ee938",
    "44f8fffa33dd33a6146c35d196595e22cc4a215f61ee9197cd751400970a1b"
  ],
  [
    "78fe920bd96a356d4d95ee34adafe8fecf071d3107c36f047b4024ddc4b3eea",
    "6162f29607fdbec10181fbac6e57d5cb41b922c5791fb24bd28bcdd75d16c41"
  ],
  [
    "5629b849e026e65d119ac11821d7ab7efd9c52226f75c7427505d6818bb0c8d",
    "1539c0f90970ee8b490e45bbe5568170e5708521a0e59f976be680595906feb"
  ],
  [
    "62bc853f349bac8c6e5921d27ba85dbd9ba20a375d70a7bc008928f3e123b04",
    "6acfeb1de05ba43c3ef1a9110a983a320e77b3ca294abbc04aeca19b194f26f"
  ],
  [
    "4cf4bed663464418285cbae359b5d84ec76b5997d24f3640984c7663421190f",
    "941f818e3e3e8fb1568da85217d17f9250ebc948379014d900a7b1a848494"
  ],
  [
    "52ff3d9ffe9a302f6dfaaf74bab57c08027d5cb699a69b30830540c0a2d47a1",
    "987dd8876873778d933fbfed37aab2f7d6f669c37024f926b1edcb2ca55782"
  ],
  [
    "1109ee32f0bc53de6bfa457060b366e909d7c18061ec9845f46ac715496897f",
    "38f36f172bdfd454b9285f86e6bdece8fdffc95182c7d801b03c671cc55139b"
  ],
  [
    "4b4482f1d84efe23dadf3bb10df3dcaa251312dcdd604f616f1eb540e1f3232",
    "7c9c149dcae9135f940fb54482f9c3cd8193721643a6e23157b8020410d439c"
  ],
  [
    "69cb459b9e415b7581ca163611c470d875971d5d7949de732d1f0f200544a73",
    "a7136fa9dd00c0469863b7def3f83a5611ed628810d7e807e7a873da5a9897"
  ],
  [
    "b66a4e32ac9a4baa8f64780acd94ed3628b2b0ea874ba4dece629af65f9e62",
    "24328ba9996a24389658e3467b8b90dc3927ef8419fe28b3f55b1c1aaa51915"
  ],
  [
    "5ecc3080062dd451236de0e4eb91c5c75100733364bc5469f5fa76f79021ecb",
    "6da4abb9031a27b5be94529324fad8026e7d871570780081b0f424d4fe543c9"
  ],
  [
    "1e3146f00880bb22486d5bc73e54367d54251f4002bcf342d0393b05a4b9ce0",
    "23b6fb8e945d3205f633ba724202db5a99305f807137edf942cd60eef867699"
  ],
  [
    "2e1da8013285598b899f026c6974185db12c97b4c63509769d3d4ad1d18a4e5",
    "1e7e7b668674d1593c39d58bc7bccbf568208732b3519bc2cdf93db34366862"
  ],
  [
    "d26c3f389d81709506f184b53871497c8d36c5c9eee8e3737358204c1acba3",
    "34649c3d39f3b825947fedbca215ae30c5a5995e93b1c8efca4944cf85a082a"
  ],
  [
    "91300478a83595d548f32f259033291fc7d083953b0b8bde88c7559660c563",
    "e5d2bff57fc6551e9b80c06ac7314a71907cdcc66ce82f2cce721a670df10a"
  ],
  [
    "1f7abcb9d462c63ffe92aa56619ae8590089cca4d93ee3e5f34a63882452cc7",
    "7e9f85c7b7ca6e9a4f3a026d1048adbeef69ea9d876c6f647c257b879a81bdd"
  ],
  [
    "4d2caa1323012e4c83b0ad387308b8aef5637bc35ddd882e7f5e41cf2ca410f",
    "47150e808c81a540b6f8864e9d6636589cacaa516f82caaa96506edfbd6f0e"
  ],
  [
    "3c10a6083c38351deb3e6d1b386827d0acf48979b66b95249eb8700ec26b069",
    "47e34bfe561d903cffdd1d849b85aa3cbd31cb4a9bbd8cc2e5fd2f95016cabc"
  ],
  [
    "758bd54868eec045d0b4d3d2bc415d24bce13fee47cefdfda46425c109b657",
    "3392a7c66ea3bd7b044680bbe9f78ae86752097404c067e9d2572f55330df83"
  ],
  [
    "19e718e0ca1d2d6fadbc6006ee7dda7a385430e29f5e239cdd4bb7c3fdcb2f8",
    "5c68249b7fe03ea2e13481a63b6cd4bf74ce42009a89fee0b3f8f968b3ec709"
  ],
  [
    "28077f57ea62401806367e6d54fe45d02de5b072db787ffdcc3854e12a3e855",
    "14f3762689072f5fb41d03e94b01808c739f6d42b7b785b0e464100b150efd2"
  ],
  [
    "3b8a8cefd017363ce867265af3293cec081fa589fe561830f0078778cbd338f",
    "69ccf2383cb7b4f9c806d72535812483e7c5e9a1a5928529d64ca7e085e758d"
  ],
  [
    "77878f388d22161a2953e5aca6bac1ea480e102f329574b4b201640d44a296b",
    "7eb35706a90a03aff7c2fecca72659136547cee98038746db5aba16fd7178df"
  ],
  [
    "97332e6da70961f2ef31b7b628f1018d21db8db015922a301fca7d6fc6a8e6",
    "2e37b06f639fc7a82601b744570a2619e543cbfaf60e474107fcaf4686d3223"
  ],
  [
    "a81518d452d3aac48bf0386c3ff170ef4e684a4def242c964e129c64f4d647",
    "37506e44c85908ec7b7adda9547fbdcc2e3605151fefa77fbf127ce3bc938f2"
  ],
  [
    "e80336b2220b1d666074f6b0dac85353d0e4c2e8bd0f37055a2236a6a9fadc",
    "1cae76d73eda7a5964c5d9d3ad6748aff51f5543c56441d2fdb7b444a39846a"
  ],
  [
    "2c01fd8430ecb44e066f352c4f697fc9fda177dbe162f82862d7b9ea8c918de",
    "6e1dfa99640fdf5b30603d34c7c97c1aa6e6b7f3a2c52a21fc64b0fcac7d591"
  ],
  [
    "744e37b511cd0ddcfe15f3581947014c159de81ed055d15a13c7a2d1fa39f0f",
    "685caa8ff6979a6c63640ac638a3f9c75737f2031bd55322a47384357af164d"
  ],
  [
    "40e627ff84e1a7a9068b4368770f5956128a4d9e9e33e9cf5e24d9a242149fd",
    "2465bd6cb20bbdf810e2bc5c3c458cecf4f3aa163a7ac99c2579e5f33417f2e"
  ],
  [
    "5f635af7f554a17bceb6ccb6e637abf89ab6dadd399189b0a0390e87b1896bc",
    "2aa6238a69f89665646c0e3ca2ba5f709cc6e14351cf71e1b00ec45201417a2"
  ],
  [
    "5edad3063c9fa8305978d7e6a4e037c9fa519b8023c7608dfc3b66e5c1e8985",
    "49f405d07d7d01919da51159ecdad1031a5ac208c026fdfc14d38f633d92183"
  ],
  [
    "2fdf2e8a45858c12926a1f25a62255fb2d02d0149a15ef669f859806683e649",
    "61cfb686bb31e2524470d4ad2ae09e3cc91b16305a21d748098feb1d8ce3b3d"
  ],
  [
    "ecdbd7c37f1dffa3943977278da3bb429afdf948b4ea6cdebace3d3be82381",
    "190b67fb34f7f3ad6afd3d6b6427aa327547d8ac0fb4deeb0feeba1f63d6c60"
  ],
  [
    "233021b483f578dfa5222f8cccba5766ceee0ac65f6d4a3b1673b302a21fb3c",
    "7d4b6d44d175d4b593f06f5a6dcba2cdbc4eaa2097abaf613123546866cf4ef"
  ],
  [
    "42db4e953c2a7a743de9fe20c5798f2247f51db4eabc6f40e86c13909a310ce",
    "12c1a0764a0b9f3666e431923ce15e7fcd0ded5ab153f0b48d362cca1604e65"
  ],
  [
    "30d539e2b545fb957e40e2255f6463b52d227c9808472cee6a3d521aa283a44",
    "5f9eccf747fe6313570f99e845db32b40070acee9ce9e34da7f3c29ca53a07a"
  ],
  [
    "4bd64e5ade3e2733580a6116b4af328751198e7128f9acfe3a3496b545efb5a",
    "4d584768900dabfc0dbaa086632b8051bb3905ef79b84d96c01514441d0cc93"
  ],
  [
    "62d6e771f02e591557197d13c3e77dfa2d1794ac1808407bd8227c4be31b466",
    "5c6f5607c1808e899ba36a425911fa8566b7ea9cc80de8a80538c0fceb837c0"
  ],
  [
    "5ce406218cb2852b1d2fe1836b19462f664631785216e87ffbce26030e2101f",
    "5225f107743c255ab50e7be4a090fe39478d1ef4ff558468559d8cfa87bb94"
  ],
  [
    "670286486e8dda3dc66b0ed3149be7697d3e06c8279844079daa7e42d5af728",
    "26becabe7430380c56e320f5ae3329569cae7b0af06fd5327ee23979d200eb0"
  ],
  [
    "3ef448df33a4394c43e93e5850cd0c5a6dcb18ae1cd865d00fe8ede9336a9f5",
    "56711f6ab7e0e4f7365ac34e284ac2879f40208c46f6febcc1dcf7146ecf015"
  ],
  [
    "4b63fc130288e92f2d6ba238caa7a6364804e29829ac037c57df32fbf762bc3",
    "1eb8c80af55278b4113286c038fff2bfad2da62763bb03426506b869139da0e"
  ],
  [
    "4e7e998557b29a95f805a6e2e26efc1e970108272d4755738c04f28572295c0",
    "97cfcc2f447bde61bde71049d8200a74a3028b21703bc139143d81a3623f09"
  ],
  [
    "574b67898f02964c408f68e9470e7b615be037e40b824e6617f89cb56c21219",
    "49392d5f8e6740a1b0b7444f56d7a17363f8656c6e4c628678c86223f2e46c8"
  ],
  [
    "7e8cb50ea5d5c1b09e219e7305bcb601d99b6d7185b1c388aa8e36fe1e56554",
    "47fefa308645455c12ccb5817da338f0c4f423b341aff4a9d158891a4fd69ba"
  ],
  [
    "67266dea9e71b4ed2bf24a597a823dd048cf31e725db511edceac72998c9ef6",
    "39babd65850befde1f7c28e41dbdbb4caf82bbcf3bcb5b33161f1c2960b2d8"
  ],
  [
    "63e99c2cb9c74eb9227d48065e27abb8f606df8fc83b2c44e4ea38b046bad2b",
    "60494a53dd13ecf34e08079d343c88fb655d6d810785af81f08d5aa9bcdcf9"
  ],
  [
    "3cf0600b0f5a2a4eb78c487cd385350e8c7848e3f6983231881d7f1bbe28543",
    "56dee4288528de609976ef6b903b652127c37b0590e91a2fdbebc3f11df2628"
  ],
  [
    "758f09245fa4b8b23d290ee2b3bfcede199b4fdb11f3cf2502a8ceedd61b129",
    "622d9baadfde781e985d9722e0a04715666769a4cc7a9bea0b96d6386be1746"
  ],
  [
    "38e1a45b81492aa95d7abea2b08b8c14dc0b8a41108b036871fb737910ae18c",
    "145c611262656385e5ed6243568cd3f9f59dbfed7a01ba11e22bb8bb272e08e"
  ],
  [
    "206e54ca53a2f155bd4fc45bf2edb77798ae6623defd4cf22f2dd4a7d119dad",
    "6c94e7f0825ad81680e4cdbcaaaf4df806d57a0d1fb2331926c3fe2b79d22e8"
  ],
  [
    "56e98d2862893caebf66180e84badf19ffc8b53041eaaa313ae7286a8fac3d",
    "526306f9c01afd6e0c1198ea5de17630f5a39c4ecd02d8e6f0d613c355995c6"
  ],
  [
    "4fa56f376c83db33f9dab2656558f3399099ec1de5e3018b7a6932dba8aa378",
    "3fa0984c931c9e38113e0c0e47e4401562761f92a7a23b45168f4e80ff5b54d"
  ],
  [
    "450cfaadfecdb8a2fbd4b95c44cb1db723ee5ac9677c9c188b3d7c8eff4ca58",
    "1a552bdfc0c81be734f1f6ca9a6dd3ab4daa61c11fb53ebb7046eee25d617c7"
  ],
  [
    "6fe20e5c8a8004e33eafc84d16ef770f2f0b7bace19adaaa150f987d295a34d",
    "28a35040a2ebe9a14a162d3208d5eabc6e2f3a8310f926bd80be65aa71775e2"
  ],
  [
    "1bd65f45a35bf62ae8f9ffcbd7de2976b90518b6820c219f039c50043bb1edf",
    "fb5f0f8659f9b6ed7cb0ddd7999506d0c20b26bbe69d1915a31842cfac41eb"
  ],
  [
    "4ba4cc166be8dec764910f75b45f74b40c690c74709e90f3aa372f0bd2d6997",
    "40301cf5c1751f4b971e46c4ede85fcac5c59a5ce5ae7c48151f27b24b219c"
  ],
  [
    "21cfbc678f5a279ebb6ed124273c8df37eaf12a2d04180403ae6b5ec0b1e1ef",
    "4478ed6a346d899ad7b0b10350270aad39ddd5b68529297e4c91a54357f0a7f"
  ],
  [
    "350bfefbe3d864eaadac9cc1195c14159bb736be743aed7380d2384cadd2046",
    "5e2a4b3ad0e1d7b9b8ef72b10d68a80e5ee691d7db591fcfbaad6240d41da8b"
  ],
  [
    "529acd569127f73c8d34345f87e96cebfb48ee12a00a3861cda209337ed94e6",
    "3120671a89b705e5bfd99b0e7fd2118b4914a3ac309b3d74527cacb5ad7491"
  ],
  [
    "55d3d7956a97d10e65a4d8ffeba40deaf0db0b57f8e022cdb3df6df613f5c6d",
    "159e59a6f92f48fcf85aa96c1a03749a4c4e2cf9e2bc94dd36796daebd9b8b9"
  ],
  [
    "405f019ee8f2e972a005c549b0884b5051f63d1e78480b73208dc07d8c65a1f",
    "4301a3d0c285ad309ff24a12c100ead7f48ba1368143712f32ac141ab4d9e8d"
  ],
  [
    "376d59b298d982f02dccad0edd5bbd4e5e8fad7898750675ed0856850a7babe",
    "5233b12bbc50564eb61cc098a17d3d97f06ec7a230380e4c5d3b725cc318eba"
  ],
  [
    "2f55624af6109ef04b2ed035a44a904ace8627f55889f011f768aabf4de9a38",
    "7f64209ce7dfb63337ccf3d8c14f4093295f86996cabfee23b1655549aca089"
  ],
  [
    "3b8965e942bed2714bc2e685fb103496e1e3595ac6a343d6df45fb5ef6979ed",
    "5b7cac7a165cb69ae103dd9052fb39c00ed0aad47989005aee53972d82d45b5"
  ],
  [
    "7abfe3accdec1eae1a50049efdd9a8eb7c2921a08e8bf1fe606e9d5a4039ec4",
    "3af178e7e831f8148244d2d2b284a32991852db6212ad0a9d77540ef648a5fe"
  ],
  [
    "4983196df6ad7d6f0a8d76f86af3863ad8611374a03fc0fd00793181dbde9d",
    "204c1f91b70f975a21d24a8face664e496f00f602daaafa69a3b56098a4cf89"
  ],
  [
    "79e2b91c1531a3b16dbd53e72d94e16bf265cbec261658151acfaea3718ea72",
    "3d9bdb47e8b148c1c5e9e694ffbc2cf71aac74ae1a85e8d8c3f77e580f962eb"
  ],
  [
    "297efceec61b3be17565843cae465c52524b4ecd9331a4170f54f7de8c4556c",
    "6ccef1733624cc8b973ac63dd54e7a53604929affe81c3439525ae5ed6af993"
  ],
  [
    "44f04b1966264a23ccdc870c8563ad2efcd4c8087b5469b90e792287a5581c7",
    "1c417f0e9829fa3d3cbb7c3cf4dc7aac04c5bf66ff3f86b833a42c533aed1fc"
  ],
  [
    "6ff83f5d8b51db3be0bda80eed2e2adb7037f2f58f705e88f0f98197431ac26",
    "64f59b8428894c2b7afd740866065ded42e716c7d48accd3f117f22768ed9fd"
  ],
  [
    "14aa8187c9559f77cd1cf96b2dfc949182529936f2b0b4050ea56e134073b24",
    "5f36508c68b1dc586f3fd3f4e2bd29c6d8258491b8a6aa19ede811ce0d3d0a1"
  ],
  [
    "95e8882a68c5000d1c2be7c0b43e7f2a6f8de906485241f0285a5c73a27a83",
    "1e4cb67207ab73bc1e5d19fa2146fde6d03021393b77a55df4ddda1fd28f5b1"
  ],
  [
    "2ae0704dacb3da47d564514b4c3543505b403ba09a248c6e74593cba1867ff5",
    "5a4b5818088dc9ef4066b90a8893ae80fc89584f987ec1928ef9d72cea2bd67"
  ],
  [
    "61a10898a76fb99989e51c0e823cb60b95ec7ccccb917c42b2b28014f5fd94d",
    "23d8ec1de45366d3b86c64c2da05a2ce3d171adf52ca5522e652ffd0eeee795"
  ],
  [
    "79884133c879cf07734976fd64de220c5a972e04c2a3afb74c362d6c3beecbf",
    "2aaa0e6d4891b792b5643fdf09873343cd0e3fbba3cbd0601b481a4083f32b6"
  ],
  [
    "45f73d2fa82be6c5ccd0f62d2237efe8727c479967d27cce28e42b9a44bad5b",
    "2fa4932215f72d56d8be5205c5851c9b3e5f2a14468e4a7acace5437c6b27dd"
  ],
  [
    "37f53f771850f52f9c8f87b53c6bf0c93c2bed76f5fd1d5697356d0b2325007",
    "50f1a052b79b446fbc7b93ffa1a4515f6c3be3a76a2b0bc5eb8ff327549960c"
  ],
  [
    "71bd6d23e0d2f312d47582efa609101f15b9ccc571fca8ac4fe3457c67fbc9b",
    "3b3fdf86bd4c7fc26d60540a6439b4d179dcbf7b91efb0ddc60dfbff9a148c6"
  ],
  [
    "78219ba049438385b829c13a4993874a4a326c4143de0dd581c7b9956f99b06",
    "5505f1268dcdd4ee01b77abac3bfdcbf3f0513ab097c69ff777b4a631aaf256"
  ],
  [
    "b81e924a86536dcf68bc5a2ca2065a61103ba6c9eb0ae4cf8cce9dbe286f15",
    "653a6dfb51acfe8a844fb8362795e5549d424aed88d3a090366a44f840b5b83"
  ],
  [
    "441c0d7b7aa705046dc0e07ba5f33a7d9df23f694a05192ff8c2d7be2aa3fdc",
    "4c06568c0902bb99d428bfa0a946ed0f0ca0a51fbf07cad88e06e9c78e38a59"
  ],
  [
    "2569c8c78b6d6b92533f29f767c95720d377fa63ad5a3b9827ee0a74b0488aa",
    "4b59c81d3cfe08834f946d9d57614f5366e0bcd9349475aaaebe01341196fe0"
  ],
  [
    "3f2fa285a0471647b214eac652bbad9d58a9f2dd2e812aff0210d0d8a6eb32f",
    "4cdb18e1c2848c2b52c1a6557165bd1a8f55c2f7562f5cc0b326f73c25b696c"
  ],
  [
    "5bb5141ab4fcc5290ae9151b8045a2cd8391547ce7b3b33cbbb10f8fb538092",
    "5a36bfd52acc6a83a9913b937ec086cc27fed030b5fa70dbc5d3c12c9515f56"
  ],
  [
    "3f3fed272edf91aa7f8ca5d70005d390fbc67830ffc69c5fa3ae17582d2771",
    "459057e0883c44d8776fa217405f443e5954f08c4a5db68e437becaa664a999"
  ],
  [
    "5237ca6656237a717a739a4509f70db1b9dedbb6cd232f60c9bd8c4563a6b1f",
    "56c7799dd02896dbe7d69dd8bb9718270549592099569d107b7b49c34bf5a49"
  ],
  [
    "1cf6b8499ac881e0b2fc7def9bc1a28937033b2fc52de99e75909a620c7a281",
    "5769cf4f735366fa386b6858043dc99a100f86fbc77b16d57d77766197ba27a"
  ],
  [
    "1b74b8a6b86dbf9638cdb0601e1a332b8d880753423d38c3394902c57f15e40",
    "6bb2dc10d2ecbb913219d0ebdc8d3337d644ed8b6c4e70637ef4c7e50887488"
  ],
  [
    "61e4da415661bba52a4737e2bcde1a837787c4796b2e1854778534f1582c29b",
    "27c43e632cb7652e8508c9c38e3b4ad0d3dd6ba748d42dc84ec2685e64b9aad"
  ],
  [
    "7c460a204d23f20ce86596dae6ac9b36734e4a9f7c5b43262c97a36c6a41c6e",
    "481a11f9300ab4c4bf6924c5ca884728cc361247377065920966785d043fbbf"
  ],
  [
    "124ff5e55e4effa40daa5b9618d75c49c8b6fad95cbe8c0bfdd83cb9bed8316",
    "33a2ea15d0f71f58a00de71acd7f22ccf9002115e49dd1f7631faa0d32f9987"
  ],
  [
    "61c9f8fc86715e95ff43583a865c5a6515f93381839d557ef884a68637eaf4c",
    "5877daaa42bbab9083b571e12648a9d62ced4470d71653092b6546f4a5acceb"
  ],
  [
    "70a6b9a9e5d1fcc07dd9ebef6d8f5fcf04c6cb34932d0fe2335330ac6dc8d3d",
    "3f0cbd332ac56922e886656bee74f6e9bb4bb88f7af7bba9098678af1f38fc"
  ],
  [
    "41db8a0f1ea78443a39e08a54323743c8897eed1ddc28f41aec6f2655040d9f",
    "7d4bf32f8f4719c2e4af8b7889f3b65cfdd033dc2f971798a12170f2b26efce"
  ],
  [
    "62f035e01acdfe841104942d6c8c07f0fbd618cb85998ea24bcc24cfac1f8",
    "1caa886104b7d753fda93645a746989794cd825c62473b526ea34b3d51b5771"
  ],
  [
    "441c6f016d270e86c19843727b83b864cec060cafc813b23d7e41e5abb1a60a",
    "29fece4e40400f3acae0586f4fc8ed535e805e472123ec38d662d8a0b01c086"
  ],
  [
    "2c791ba0fb0b66177815c98191fa6188dba9c795e34a7c3c8a19086215e3cee",
    "11123151389d4b330db6a665a560407e7cd8c3807c749e2b0cffd9c3074ba77"
  ],
  [
    "5292da4ca71ae75ed0554c267747e39c7a129b3b863e1af3ebb3e368439c4ea",
    "63af6a5016deea8cc674c44f16c63c1db31f09af4fb4d2ea7917c28116661fc"
  ],
  [
    "3367388d5d1b7758dc3d92e244f227bb8a54e3d9909e7b7dd62ab5965e3efc7",
    "7ffb4833071e4b03ea755ccb9938487a478248fe9b1158a08f1ac298801c092"
  ],
  [
    "95c863314b7f18090f8eee602403be823a367a1b416d54c32e5f914e67d922",
    "159c2824f899171deee23e0ed520d4825bd667983df0a8d45d3a1f7156d91f9"
  ],
  [
    "621c6e08b3c57404644ad49ac7629832c141273fa1f323781b3395393fe985c",
    "65d1eb0140652958c4371ebec791e03317d6b2e689d90e304666f1b610783dd"
  ],
  [
    "54313129bf13993952cd2b31ed06013aba85e74c1b8a00e062031f32188a84e",
    "680129efc9eb8ec07fc180e8f6877e5f0f9f44e3000a2c586ed4ce49d12a313"
  ],
  [
    "21ea57a1c8286bb45872e78617853c47b89091670ba51c124afa3362e7260d",
    "7087e5c1536df233ec9bfe2f983e8d7622892b9bf64c450c9823898e2cc2fc8"
  ],
  [
    "3793b05b99e7a57d88db4ed0dbc3b771285abcd9052da50f88595354409f3f3",
    "12164105041c056f127e737c7cd63981e05f246bd2b6b65d1f427019c7c3801"
  ],
  [
    "befd345cef5fcae22ac37dacd6b9128cc58cbba3e3fd774e11b421c2ba392",
    "6209d25f24f88f7876ca604db23d05f78e6b3b67fb033f2f1bee221f352b8c8"
  ],
  [
    "15fa536045fda4c65ff74f10b4e669ce88b9996c6772288289d3ad725987fa6",
    "30e0c2124a35e265e931ccc66ce5ac3697d982814beb407144ff6762cb691df"
  ],
  [
    "38b795bd77ac573576dc204857a488cac2cce19809882631ca2069598c577c8",
    "786ba555d55ebef688b068bb9186a34a08cb00bdfef51619bbf911890ae9a13"
  ],
  [
    "6c66853592196c3eb8d9526dc155205e2c64097adf8684bb0e15eb460ce1c72",
    "1bb4ebf654f4250c8dd1061a4e1b464b31a8a9999ac9960446ef8108a66871a"
  ],
  [
    "5b08dfbc87ad9c00b88e78816973ad2f9c10c70f2156908892cc7b7a2a1fd30",
    "1151f407a77e2556073173d8f5c9ff561d8a23742121ca15f7d0ac391af50ea"
  ],
  [
    "309190eba106aa6ead54b5ca5817969aa68b4b4c627700799a49fc6bdd32ba1",
    "505b6a2bc7b0d78ca6ce2abe7dfb7312369918a4599cccf8a615f6701cfd851"
  ],
  [
    "89cc205966af08acc8910d563af7443d5dfbb5d88dae79c013c678c65dcecc",
    "1f8cf955694b246a423ac725791231257b88936e00347ecaa1e17045c0ab540"
  ],
  [
    "480086b61a80c36cf1e1a350baf554e58ee8d9333186b70c9c512fb9e9d5a84",
    "511edfe58f8d36a6170df743731da1ff525cfd5108be20e30ac4183d1281570"
  ],
  [
    "3caf14fb1d2e90a13ad4eb091250fe37133aabf6029633e905e5a93ead41dbb",
    "49122aff6059dfda19e4b973aba5ebe3804c91728936c6381c1ed1ea9380920"
  ],
  [
    "66d1b8fb2cabc46cd79741ce1cb7326077ad8ea3227a6427244bdd3806bdadd",
    "4a52eb74f4d5371ba3265dffd61c844f9e68d4ff0b44dc4936182f9280bb66b"
  ],
  [
    "373330c5afd53c31257fcc9050fef873e15ea9f81d9810f30744309b04e02b3",
    "5889806607b3dc97a9c5b0c8a2f16d1792099a22866b879ca480cb89a11ef5c"
  ],
  [
    "26840d0ec69a22c6818ff64b8b14633b531508c866e21d1dc9239778ae9e8c7",
    "157971f9a6e3a24d3b307be0e7c8cd352e2eb5cad33cf276270c0f309ee63fc"
  ],
  [
    "ebb84848f1c38c19a754d1b5d9460e39624dadbb30800987c9419c0f933b9f",
    "517b297cf32f4064e6d6c8e761ba8db89809604a701c7b3aa1a9c6beb370ea7"
  ],
  [
    "25780380bc0795ed0dca727c55240f1d63593e552d224adb40df2d3721c0f66",
    "10215fb5a893e0275e9f1f66b217dde35addee91ed0e8f7d79531a2ff57b8c8"
  ],
  [
    "243e1581cd1abfbf18c31c19a4c3d1cedfe69a40bb57b607c9af2717eefc742",
    "1296c27929f14535718c3a4ebe045f00afdc60afc74c7d398d8ce1b6609dc0f"
  ],
  [
    "48babb8649e054bc8e0b902c89e6940c265f48464520649502ef1064eb94562",
    "3235be7852b0526d1a16f6969ec0e5b0e09cedaadc65863dea4e47f4f398264"
  ],
  [
    "592db7c27e63489ef4bcef2eafce89f40067cd9a1ba48bc3dc76b5fc62ad9ca",
    "48b7711b570cd9ac65910e75e752f4b751fdbfb4091a28f59b8c046d3d9f8bc"
  ],
  [
    "31d133456222586ae42a9ec7ce8539ee04afbe0b2ed00a2564dab0798d9b55d",
    "a77c52fa1fd718db5c83e7fda6d7d4d9aafef9ad95cad621470f2b753729e5"
  ],
  [
    "4651668379883521e7983aafcb93811b4a72ef2975b3277773746708ef3e3fc",
    "512507f3f544d80ba5d47f73b571881e8d70d7b1d305b9704bdad036b7abc47"
  ],
  [
    "26069e359b2e847affaef604f772f36224608b7642245d0e643889ed231bddc",
    "75ae1ec379f074ebc91270077c74b4d34347ce183b676b4dbe100bfff143b9e"
  ],
  [
    "3196d01d1fa11dc3803b4813c4bbc6326869f61410f2bd14bc0f570d875aebe",
    "20313217cac79875bd2a503db1e86d1e5559911667a02524759344468d9561d"
  ],
  [
    "483256607f75f06fb126addc60cadddd602154cc4782bcc08351a48745d0b97",
    "2950a7e500ebbe9775f08be37cc2e62ccf9030de18948d1bab07a4a9173f75d"
  ],
  [
    "65f07b6050a2fc6eebe2c29ffa62f764060f7f9d3c82d2cb5e4e368aaa442c9",
    "562c9654b646cb84a213b41de203c871b3eae0a05c9c105a66a53c319c06373"
  ],
  [
    "284870f6181c43f3b01d94baa9c5b6ada0deb861145523ad9169580eb7bed35",
    "5e03e6c40c1cfa3cafb01fd0622349871832a9d35499d06408a83edc1b76d02"
  ],
  [
    "32229810a52137f0e6c3d37595c46f6132822d4b05f42674b48d7a7ac3ad85",
    "7babde959a0cf2c53ee59fc52c77c3adf899453f077f441965629f9aead30cd"
  ],
  [
    "1ea8b98a6b85e74e0a2fbc18b206e290f3ed94ce99ca665e8e2351dfade990a",
    "478e93c4724115fb1648c8d5347422adbc1a0bbf962b2312e14aec80e1be742"
  ],
  [
    "270cbaa08c79140c85b864475a0bf569cc03ac785e57f543dc444f37ce746cf",
    "3a9b8d894016680ae9d1bf3deb931d8987d4d8d8bfed45b81ccc595ec79046b"
  ],
  [
    "6943922708b8ae5b40dd7031ef2e487abc4ac39a3591368285e83d6c9c51f4d",
    "5f157c37d09634e8cbfbef90ea50af59815d011e419a691c67ca3402b5efc33"
  ],
  [
    "48ac6a80979fab4912cf0cb557d917a0bd68825d8658ec100496eaae6ff62e1",
    "2b6931350ab183402e39476340eb1177b7006f7a552915581e29a79bd7203a0"
  ],
  [
    "e3adf9517d92ef22d1e2a787740a292ba32d5ca69faa9e8675f63ed816dce5",
    "36bccf69bb12dadd610145a3399213248d193660d8dc90a2e206f23bf2c7997"
  ],
  [
    "5e6c8ae5afb2fa470f767581f3d578cf6a49547e4b78665edfd45776948bef8",
    "6cbfc11953dd7e195d2ce74e52a60df524767b44c4608bdd755be4bc85eb74c"
  ],
  [
    "15a576a1242d39300f0db3ad770983825988da0457718ecd596c63a0a0eb4a6",
    "69a42e5f6f5a63349b57683a4609bba90f556a1680fa1ec3b02ee7d3211f903"
  ],
  [
    "274cd14e4fbf2ed07402e8ad8075b320c5f76b7ea45ea36af523e95ed63ab50",
    "6ca640f9557c5f2d8b27f6ce95b108880ff4e4816b26b70b6506114389ce656"
  ],
  [
    "4d8284e132e2fe81c5f71be1e3c79ab51b229e2c56c323e207cda179999d123",
    "116cfc00e9fbee1cf16af6282123cdf20eed13021c2037ef4c86f94eb6e6cba"
  ],
  [
    "4056194fb5643e97991942ef5b63cadd89080bf57a01489c4398aca03f0980a",
    "2e2cddb434fa6f6da7859c3d518f0ced8795eea043a6c9613fb3e020103339f"
  ],
  [
    "5d119d5c5ce532afc0875e0ee9b026d878c8773d34237f90a0d0670da6f01b3",
    "4a79fc025ce076b6a4742fbcc8cad313d0a8220c58024a41a5a674c0947e64b"
  ],
  [
    "11800ce4061d99b9d53fd4138802335258f7798c5a935c9979f5a949ce1d483",
    "36745a4741a5c7290eaa8f2a3f9ec955ccb7ca323272e5d35d35c2a724ffac8"
  ],
  [
    "4302525bceb97fa642fd5560a4a39fba3d2c06f68e6aff3332ff1854439ebb3",
    "e31edfd081ce82f8177b2d7d96e69851d09e908c2517114ffb37ee12c0ac64"
  ],
  [
    "2f5fcbb96f0a66fd3bdfbcc78bda361cb812570f50e7c476533d56eee01c0e3",
    "527428a34855b5695c479d8fb7e831a299f7897f36682a74169cc60d160df2d"
  ],
  [
    "52167df045ad0dc999b98de3d035aced9da4434211149b8cf4bf20e774580cf",
    "19051d2a1ad3fab190c5dfaf45188b49b4e90cca22aae54f0a785562d3d3f41"
  ],
  [
    "541b5332491dbdb2b6f6bccceb7634970c046963891fae936dd950f4432b961",
    "78fa54da996a51e3a9c06091d58c2405a806649da2bb1f323807c4eec50eda2"
  ],
  [
    "5f11e973da659b7738f87ca5bd4f3bd02207dd3c8d978f0d3e83fe81030febd",
    "137aba7027069f62d25caed416e13537687bb1428e71e5f0a0c52d52f2e65bc"
  ],
  [
    "15ec941ee6c2110b819b5541be52981c09d83484c9dc735c43f39f5778718b4",
    "4561826142dc5b56acfcf605a78a4090472bb61235bcd605a765e05d0a7e549"
  ],
  [
    "68ba398736d659522f484406110b43c68158bf4992094acf797a38979c587a4",
    "7c1d9e1702e28afddf22fed7a7a79df4315c174d0c6c4f4c75bc77d9b56777f"
  ],
  [
    "67889cea31c81a429fbae643a4fce0ecd690a5c32b99397e39ed6d7a08702df",
    "7ea277c80b671146c9e455b98f42f45b941ac95ca2d15c8fa9ea82ee9b45e01"
  ],
  [
    "596f2c68390ac26505d3c2eca5c77d46f8f3acbed192a2649d8c525a58d2334",
    "49f3bd8c62c610d5c19c52d970bde24b270c4ff7ae900453b909e72483974a0"
  ],
  [
    "567779fb8b0afe592cea284629e3621ccfae3c4d7d3dc559c9fed750591a395",
    "6010bdc33f1cdb374facefff537e7910b72a1120502f312a7ce41df0d552ddd"
  ],
  [
    "cebed0233e810aa6a29a8b0829d28f1c92f303d14dd73d6b12da98117dfc7",
    "4bdd51e1192a00df23aa8d0673e4915877ca41ddb8c9eaf21d39dd167fde7b7"
  ],
  [
    "4c7085f066adeb6781596771972b188177e63f2e2b3788d03e033cdd5af1f06",
    "2929ee89f525862b0cedb3ab9b5166e1680cb77fb4668f10a6a3d76b5434566"
  ],
  [
    "760e341bd836899c226176f47685f69438270c150c6fe7744cd723cd1e72359",
    "1bf09f2f1aac1a10ce8bdf20d5d178db747f01a4aa0aa8a5e4bfeef562cd94e"
  ],
  [
    "6016b94c00b54920027ef64902c61478244b1936337d2ad41d9a8d43dd6a4b2",
    "3bf3dd9bce7f6d6f120de87fcbce6219340b59c2c1d75ee0d45105d33aab1cd"
  ],
  [
    "4929e44ff692eb944d1045bee96e750219cda3bda0500029f0df49a1db30b5b",
    "2e138dcbd092242699004b4ce98764ffe4e892841f56830af298581cd1e523f"
  ],
  [
    "5972d0e526311bacb70a04e88969b6c63c7399b578f0dc28bbd00d65ef01da7",
    "76b22bca9ac12d26530e7b0757e646beb3bbc5680d0f3f82fb8ee57ed4b5e39"
  ],
  [
    "2ca0a42a26e26934ca2d48db960b4719113d87c5e57fb437d557c5eb4e03ac7",
    "62778c02561d4ec5d83a132afd7763a8349207c6b5d01fba70b56ba660cba2e"
  ],
  [
    "5137ee53f076e21a2c23da09f63c0d275408c31e4634a6b6373be5cf13e6c00",
    "14fb446c077beb78e04de3282a63bfde12f9af85caaca4ddfab506cee31c0c1"
  ],
  [
    "7d944853d1627b63f560aeda33acf640d35a4ee4d23a744957a2dae9d5b7c6c",
    "bcb411a210710acbcb9ea12680d89e3e4e652228b6786d3886e95f4d9e6970"
  ],
  [
    "37d412c2ffb173a728477446b60b2b702d07a5243cb5fc8963e623a5ee75843",
    "672c79968908f92cd0cb0b4c65ba86e8f359b015623a89441e1bf859bba84cb"
  ],
  [
    "5b37f472aa80398bff12cc74c8ee784c4fc89757292580d3a498bff17e9f114",
    "7d79da1aab9cfef58a5f3d1c9ec466956a45f8d2af0c1da6dd4c93f720fae6e"
  ],
  [
    "25c09b3f1188c562571536202eb0f5fc4b9a7590417b8ea58b4343685d88a63",
    "3d5b817c73b37e9a1d24ca923351359b42ced2f3cafbcac8c2d6322dc767bb"
  ],
  [
    "32e60904e73f9756f71e0a918d302aeca17cad4acacc81bab15702ab5ff78f0",
    "bcf4c0204f8275072f98a65b09ac58b87cdc9c70c4edfe99fe18870a3a5459"
  ],
  [
    "49c35575996c1517d2daed90d2fe4a58e674d6b4aaa7288d0642c8bf59e562f",
    "57eeee00adea4ca80eeabab57852cbf03f1a57e21872cd44221e0550b9193b8"
  ],
  [
    "10e1776b4c2a867bf1b028c6edec224cc6616c747e272f49e69b67b02a893dd",
    "8d45d62ec8e627b56950f2f7622a0438647f9e9f28e723e4a37cebc039a1b0"
  ],
  [
    "79a93a75ecbe943acc964fd39ecfc971dc6555b2bc335e7b53f52f4eb16cd36",
    "146132a68ce2ca8b48363612226771ac547eb3cf52b6eb7981718faac08aa3c"
  ],
  [
    "6b22d32e0590e169504e7f19864fd646d0994e7ed3e578a5b88f6e095913439",
    "68c3b22d859fb85e5c8fa0a8aea932285945b230957e603394333e9ad5acd82"
  ],
  [
    "71ce5ec8286eb8c93b8481c6d19cf0a288ef4da4397e9c80f65023e516bc097",
    "54470babc742780cd8a05499026e738ccbf81d4170d1731734de68a8e5b402c"
  ],
  [
    "27beb13a43bc6a1f6ce046da438b0beac5899ff4d57962dcfb6476b563f74b",
    "14074e9e93ee45394dfbe833998b9d1691961f8ba3166224b36404448c61bb3"
  ],
  [
    "6b1de6c8f161aa6509a1dcacf2c0aa1bcf6ee9d9b40e032a9d72f77a6fa298c",
    "5e9312eb5b59d6cbadd7d3dcbc39f1b5bd9a8346fdcfdf1107bada6f9cc048"
  ],
  [
    "32670fc3fa43bf39974ba72ea51f0d045d92d084a81fe5282dfc8309aa900b9",
    "518fee521bf1af62356aac3b7e53fdbf57121e030c6e9572b3de69912ca4eb4"
  ],
  [
    "4b9ca363eabed9c66091a347375f7065cd28f49f914447de7cc1461f1375f1e",
    "3a1a3a2e5e7e72476befe2571ece708052d740d02cbe6fed58740968ae609c4"
  ],
  [
    "4cc6da42863a3deca62fa218b7a3b50e034eb4bafd393eccba3f4cbe192ef10",
    "20bfa683c884f203713953b26d2821287ecd305fa2cb70570474533fc07f918"
  ],
  [
    "87705353c44a5ccec8de65cf5433be6b3d9bd21eea49b60e6c907cf1a67a6a",
    "112804b13eee56e3b01aff75fa08fa8374c44fc461aed8a30ad54acd09c24eb"
  ],
  [
    "6cf6eeeb9d339c0a05f72fd5af73fc7588e6d957100ee8999109437bc126cae",
    "54fa257cea22032eac272fcd034dadf2e00d602ef9e519cf7072023c130aad1"
  ],
  [
    "19b32925048c5519d929650c833661b452ef7be7963fab0b6b328ab7dd7a28a",
    "1bd0c14a10bf9b88ea61011c0b2e64d07da151c6203800d5a5d12063838a510"
  ],
  [
    "12a5fc5559428bc3b4eff97b21b63668b866e0722807f1db1f19696bacd9b0d",
    "4c2eb07f0c24047a3d73b560144f3fd32c99d6dbd9fc7cd2fd2a72a6e4b24c7"
  ],
  [
    "13662b7a7d390aa76eb86a7c3bff6d9913eb28db6bd1a7c42de5cdad2e35ce2",
    "40626aded7f56f82cc431ae30527b096f57fbfbc04d3e12a5abae3edf301cf1"
  ],
  [
    "255825bd49b8a2cce114360bd9c8fe8c641af64c8e7710107213cfcb006f43d",
    "3619cce4482335232f9e76a1460be9d296f2d468d26e4f95a78c71524fe59cc"
  ],
  [
    "7f83009eeed4f12f54d341bbf06066480cfcdf51dda103ac54d4bcecf6b3b31",
    "4269519d28faafd7fd68bebfd8404d71ba05d62c4bb6d65d24aa6802fb84ab6"
  ],
  [
    "2f325650eb316646b4eec903fe44828fcb11054f1bd42ca3a77f7e734110b35",
    "44f976082271016f9048e22c507d97d628722bb431f8d5cc1890524e6c386bf"
  ],
  [
    "750b166bb6edc0ee80fae39c7c106879036738df2d79fb2294e1c21e9a24d6b",
    "54f8aa297a1afafe2a17a3254f45861167414327e918d17003c6aad01d0b24c"
  ],
  [
    "3aedb10db9cf3285cdeee375879396fac1fb50dd259e1716f8c01e66f67ca72",
    "7feb9400f621f58c21601f23b7ec7c94a9b6b193c1cd74a8a60846aedadd359"
  ],
  [
    "4ab7151702de76faa493e7a0b1ac20ee4d10c33b83fec9477547cb1236973eb",
    "63f1f122e3ef3acc46b0915ac69c3f5772879799cad889a817f55f5853d1235"
  ],
  [
    "1675ead0d20e5bc3a7a7331999a87ac4c916ae29669e54197bb02aa6364520f",
    "4d1122da90d49e491922d9b533a6a668e2f65a2737ebb391ebb29fb7c1f8a9d"
  ],
  [
    "2f7148111ef53c613157aeec12e16a20f13481da4390b6ce18a85d1d8547087",
    "2eeda779ab395597651d2a0b833ccf53b10280750139916ae2baf4ec57c633d"
  ],
  [
    "4439c7810e7b2ba772b701ec3acdca0b80c9df23047710b87f7dc3f13b337d3",
    "5029cfe704c602a8a4662af0a5860ec03fb88f046d0e3400f2ce7638014c621"
  ],
  [
    "2248eec40b5732a6a488b681f093643af7937071bc73118acae295a32b51b05",
    "1577e4aec30a97b648de4d0b19cf8891151b4eb11f8de9c6d7312f091552e19"
  ],
  [
    "4738424e558d4e0d87a3124ca02ea24f0adc6b7a9768b0d3945ed2a6104857c",
    "33576f92aca3f0c8ae689c3c274c2de6b918940d86a6852e02fc99e35d1614"
  ],
  [
    "7829edd8b866ebf7baaf604ed13d19a9797578f44bbc51b1cd67ca53803e96b",
    "5559040a6083f2af1f9133ccaf5bc2ce06e56ddfc7dd410e9635c0116b62722"
  ],
  [
    "7f927b881f2cdc05e1a69e40bb714af47b630d1425f08ab5d574ee698f33d51",
    "26a465288e96572de303203bd38f4a03031e8158da0591cb037c0a5111d1056"
  ],
  [
    "36a65598552f8753580d1655417d645a140966e10a1e1663015f9fdfae44881",
    "33d5bbfaebf59eae72b89b1aea12ab2ba3c9617f8c3baed1ec16bdf668381b5"
  ],
  [
    "403becfa545c826782026ff409cc16c9d4fe428f1b5b6e630c92439d2fa5fd",
    "47bd6f2bf5d74f710ecb479c79b01fb774fbdad590e683a415cdedf33f71dc5"
  ],
  [
    "3a747826d241b877d3d56b16e0b810cf088eda4fd6048da174c9991a942a5eb",
    "2c7ba19b0a3486a2cdb84d4a388d34beb077a0e467ba44590166f93f6a09d2e"
  ],
  [
    "3d60cd375842714b37bda89dd1f13a7e0f3ff133b522209617d031bce05a537",
    "f77f216451ab01ad5226844d2162a7f32744688bcb4325445539e2ce5cec4"
  ],
  [
    "235bf66f67c9100e7f0e22bb299cdfaa603644b240e0770aec7e7fd163e2a65",
    "37110b3fa83ece3990afca2bea8d5ebb3c7aace60a0147f8e6ab733e2f2b4d5"
  ],
  [
    "3b796d4eb69a55471fa86108f787b3604874e92b6887a7667a6c2bfbbd9a42b",
    "4912d6dc0419732ef82cb3278415851d4e2d7ca89e0f4d7128cc9de51b810fe"
  ],
  [
    "48d53516dd51e49faa7ab46c8c10db1befd10f23c6a9d9bc3640a2f0da44518",
    "73a2fb3d064adadf21aa1362c04affc660598f38a9e069b3afb74d0a99ae9ee"
  ],
  [
    "48c32cff161ed145da0d5b73084897647abb777adf65738559ceab6939cf3e0",
    "3d99308978e828f857c382df32b472bda81e8ec8e30c8844077ba6d6d2ba903"
  ],
  [
    "2947ff091a8ec9684affbc9a62e09e598841c4a6dc638088492aa47dea57097",
    "19a2cc97975e547f97a4d02e42f89e6ced6f5a953cfccdec347867d26926541"
  ],
  [
    "1960d85f30475615f82484eba0bdafb7ea7cac3809f0518a757d66f02b01676",
    "36c8f77baabf0cc8805d993bbe62041fcf4e3239cf9d53278a4fbd91e75eeb7"
  ],
  [
    "2765f28074d21d5a055340b6d40092d2bbef807e02009fabfa08ec0b9bdf38b",
    "7fb189e0553d5df52b6843661814824b3f3cbebbd54988f042fb256c6bf30b"
  ],
  [
    "348836cb2aaa00212f4b1a4e2d7fc5417f246bf2fe5c9a16ebabda449e2e08a",
    "3f7276fd7d69e0d55ce5ee1d2d830534a27227fe0b6d8a36c93f9a78b872969"
  ],
  [
    "7afb9d34b6a42ea8c6d870e4b8191c274201dc1f93a1a2219a2392b7e345a31",
    "42bbc20dc7115e0758b364a110227b16b64ec58fc535ce5ff1a9ad8b8a09fdd"
  ],
  [
    "2cae0c2afee1767fd4c66f52e1f176d217e92e89cc19eb36d5a6c1715f641a",
    "5335efe2d9bc3667d25ea88bf76438a4d6ab9ba5c512f9da7d0529b79b62d83"
  ],
  [
    "1cc5fde334707723c3a06f00c106db88664284a2df47bb6b144d9f960aea3e2",
    "dbbf610d100316938bcd8bcd078513512ecb50d4579690dbefaa419c05980d"
  ],
  [
    "54e90cb8f3a2998d2675c5780679e06c0556b1e618f8fdf07f9a4b2466fbf1e",
    "16248676b6f06ec5e34994bc3115f85c8147b54f34d8500928f2fdc051e2089"
  ],
  [
    "525c70a2ba0dbdd68d75640f47f13d0d415ea595f7030f533f4625c2a46523b",
    "58292c8675e5e1a438f49e0c05648d9a7aa997f2f1fd77d5de1944afe5d7eea"
  ],
  [
    "54726d78d099007393348787a03107ab492e59690a46c87fb02ec554f2353bd",
    "53b54b77184ba75a3391e0ebfa6d6974db028f3f8e34bbd5460759a5848dd76"
  ],
  [
    "4ac81a66903537769d3aac6c483ccc08535cb767b6b5e1ec8017a7393ab70ae",
    "2cb22b77a8a05d26f11a4dec80eff292633aa05553a889c5ab16b6ac6e2ab17"
  ],
  [
    "21d0175349e21114988a2930b9a607d43245783cb4a0c984ce27f4c4206708",
    "59f1f49342cc5496213d3329bf4ca7fb0044337449c579bf53147a1dac9e67c"
  ],
  [
    "167f821b381f4c8adcc39789475fb55ba639e5124fe75f26dd61be396dd5e66",
    "22002c87d4cafb47ac9d27286d5cf5ff7a6715d69814118269b0729be9e4b3a"
  ],
  [
    "31010666c6db83a9f9e4db4c48173afd405783ac53852a6e38a8ff925528843",
    "1f466dc9b5d9094107c741dbf380f9fd98d8549cd50f67169901516f8cce74c"
  ],
  [
    "1ad3875769a5053388a86edc85dd80fdffbbda6a456aea497ff81a0f1f6707b",
    "2de7cdec5e2bad56a71bd2f33a4ae4c874e1ad4210a6ac32b443cfa34e85b1b"
  ],
  [
    "c489650fb7f459ce09cd05a456fc5a46b849b38a671298ed645bcdaab168b0",
    "45610d092b8af1c43ceed474cd17f7bbee65120aa6fa4d37f949e7e41f25327"
  ],
  [
    "394256a5ef4d7af5459587a0bd2edb8acaf5ecfef2563c9a04daf34a4abe4c6",
    "1ebee390dae1403c0c53994e1d064fa64e20fcb45392e209b2b99486a559ffd"
  ],
  [
    "410a1511fead6151e9bedb089b9832d0fe01fab76d3f8459929f767525aeb27",
    "361f0a5ffe09fcc3ad4eff3f5e89508ac247af80267100b69de3c59df561cfa"
  ],
  [
    "38cd437c9f659e110a869605c182ee9fdc26de36baf559d9229e258267bb734",
    "624b1128ea7739bf1cbd0e423af92a4884323c868d2ba0ee9d362946edee2d1"
  ],
  [
    "78b126e50b7042d2a019f95cb87a3213c664ca1bafe345999b1e9e2dac1e608",
    "19e398196b22f4488cbe854c614ad8c353839abc5ab3a4f3f5c03c16ba8a198"
  ],
  [
    "6d3a5ce91132f385a91823c5c8046c4b638f5fe63357424410d901457cdb867",
    "7b80bae16d2d487e122495174f7a70992bc5dafbed72bf84127ead7c57302bb"
  ],
  [
    "32d053a904dc4d88fbe7d0b96e0cbeca22a00aa5c79c753d52b0b60abf31602",
    "3af6a02e5cae6d6490354ae51185149e3fdb6d0d9caab90e95ff58aa0c40377"
  ],
  [
    "49b1fbff5bdb0aa6938b066dde0ed772c0d81f9eff52e7fe038b0ccbd78adb5",
    "1c6e57834eb14d507eed8b36c81ddf92fa91c242467061927a742fafa82b43d"
  ],
  [
    "2f28b8994ca6f234d9293d26196b43b9d1d5306844348c4a638102c05de85f5",
    "759cfb172eab065d477248b3569f4ff5791055f01e95fe71b94b8e615d73c96"
  ],
  [
    "3c2ee954ff534f856f59188fa0f29ed8a022aee0cac52d634f6dc58cd514d70",
    "22bd162e74925f0a876bd8a206b8767dfdd7c898576a73a490f138d9a7f99c6"
  ],
  [
    "5763a7cab001e1aaeabf9ab5b9b2fffe6cc2b299ab04ec4933da74d960e1ab",
    "715ee4f8ee93ab5a1dba00f0a6abc4eec47d49b61254cc27fc36a031e32f0f8"
  ],
  [
    "19976ad8d7b7f47c785408243a227401996b36e47c7a78a7bc7d4256233ba9a",
    "896b713c5d7777b0703821a73c1d9a4c3755501042120534ff13990975e1f5"
  ],
  [
    "61674b992c29827186cab5ff454758dbbed8e89bc23d0bd33193afccc3a04bc",
    "38e1020744c13903809ea30a0662fdb5226ae760cdcf10800faabec452e00f8"
  ],
  [
    "2ea2d48bcb83c0c9cda4efe11f07165cfcbc9ccd26526e5fb12556316d4b1df",
    "1d2d68b74ad384c5c4a9c85453104216357bfcdf635680b40215f0f800974cb"
  ],
  [
    "7881212050264c40c336ed3a15dd2cd868ec9a558f5b728869eab66e8b8ed54",
    "21aaefcc8ad8a161b8971d6880321781dbd939570c540da4c330922b8c81e9b"
  ],
  [
    "b6be88ce0461d20f59c5199573cda0170b61decf6e8e69a6d32f1695adc4ed",
    "5536e4808370716f2bb3423a9a49a38ddbfe91faf3b7a35eb53d3519238b6cf"
  ],
  [
    "e5972af1655eb6dde2e8c77cc58044299922441b5ee41ceaf5cafedc765bcc",
    "550282f37a4783dd60801c237045992d6fbe82a5902e7d837ea25f6f98c7b3a"
  ],
  [
    "7efc1aad1f580d8f50274f1c114c40056be19a8c96fa8c4cb5bf85e1e7f3e4",
    "2689f1c3898b114d668be6413643ee9f879913d40c262541fd0316264c60a4f"
  ],
  [
    "7939db98037f59b0113e9d60051f75ac9c3cfd1a3eb535c73e2d945068c6c5c",
    "410914ca8bbf3c65cdf3e9772ca790c19131c50068d34b7346c10260a578a8e"
  ],
  [
    "225b77ad00a2b83d26690190b74867326eca4f55bfbc3a13be036225ca3b1b5",
    "411faafef89042ce6beb64309fdaff70fa53e9d32d79a21e7f82f80e79ff05e"
  ],
  [
    "1501e64c99c8b6658b0479f2c05c9142d246eaabfccf2fcec8dc4399539d8e1",
    "3bab1e3339e42c9ee66c65b0b20236fdd9362d3ce786ad3a9779ab578af50a8"
  ],
  [
    "59b907b941f24fb8ea2458153e55f07534b388e835af7b69f3c9f54392a335",
    "1d5438c4f2f68a417f3d56f916d899a6ffe910f5f2989ca31687f1b10f60db8"
  ],
  [
    "2887d08a26f484546f360e33abbf7a998b7170a5b30070938b84f072c676bf3",
    "62a78e8d00e5d3a59e2fc424ffa08961567ba1ef24c8531cd7bceee6074a535"
  ],
  [
    "6e3cc8076b3d45377929033af35aab0c6d19ae4fd47c0daf844079ca04c46eb",
    "7b90f338e4d848aa8f19d0b5c3bca916a2a9024acbf14bddb278bca2aa39e5f"
  ],
  [
    "34844dacdd3ec54a3af328bb9d67715ab33425e194ac9977ca02ef22e8f7a88",
    "3c1affc6372f32a1634748124f9e1a03c4f0c993971da0dc28888b0801279d"
  ],
  [
    "436b192e03a49796cf9bc5e93c88268b71c9c24f9c3a85322bba634ebea309d",
    "67a8091ef69d62abcb28ce5df4dc7d53f8dc2b9690344f75ecd03a6d9386044"
  ],
  [
    "592d25b68baff87a6d7fd41ff0dadbddc1bd1316683de3b2d677501c0eb14e4",
    "27ad1e1099683f54589010faeefb19e38569ace43653be8787a42b0591e7bc5"
  ],
  [
    "89a5111ae911512ba62e87b97f643c0219702f235c70f62c6678a129302009",
    "557fa3d98e9ce7b83b47545013a4498f3de43787fb66b1a54521222242f7c1b"
  ],
  [
    "1c9b5e53377e72da5066cb08566bbf9ec31ec1877f455d932cd9b1aa375d34e",
    "72f79555a8bc207863f32d482fca54692825449fd8963fcea3de3a8183a739a"
  ],
  [
    "574a6e05eb14591729515be239ea8c1fa9e12d4049d42876f76c8ff37bca03",
    "5f99b3af43ca68c1c73e8190d5f73c8de162ba643d7d5f0cd73cfa8135db6d3"
  ],
  [
    "513fc5c2e16505b2b25a2f284e167d5401194bcac0dc3ecf8b7c9acb560daa1",
    "687ee7a1a8954d08d3856e1a16ded808e419e789736d3f55f79f7693bad69f5"
  ],
  [
    "53d48bd1205274b1c2b0a0ceb3d21c5fcd7c8892a784931603240b288a598b9",
    "35387abd7ea59c9b956de44d36533cad1f6668c438d666651695ff3862159be"
  ],
  [
    "213eb1ea99e08825110dd61094eb6e8145119dc1c507636f068730b1e086d44",
    "744f6853f4f02f4f042468d0739e0c9f64df720b87ed77d1979547084ef7a89"
  ],
  [
    "735ef017d091ca23264ad0aa7bb9b2be3309b4539605e79ed4a652ccb2fbe3c",
    "7f0ccc7a5747c4e921fff97d431169f690763427e2cfd1ad74d7a0308d7faa9"
  ],
  [
    "3f36babc5a30070b610ed97db44997e6d9115c9c0579ad8f75d295a17130001",
    "79047908a2474e32d5c712a07bf5c4ad522590bb5d6cefda410d30528e12ca8"
  ],
  [
    "51c04907ae88a5926b242fb2862cb1f2c651a94e6caad5bff8601c079fded74",
    "10a585a269f460aed43f54c7de13cdf623fc8de5957526997278be939ef32ad"
  ],
  [
    "c1e1bd626a735aa2c065831317217ecce68e377eb1f67e54ce2e97bc2ef2dc",
    "53c5af23a9b482f420be6dfd37b6886154cfd130794098e1f51c1885ac2556a"
  ],
  [
    "5aff3b30775ae4758e604a4a6262803a545f5ef4e7855fa245ac6a6431a9ece",
    "39a4799e5519047f29333bee9c86c99bfa8056d4aa381c396c4a44331fe795f"
  ],
  [
    "3d753e9723701a8e9d99b91bb93dee2eda7ffa5072fb2cd5c5fd99aebcdb299",
    "15798bf5c17d6d5880fed1553af32dd8d8baf2888c715a886575448a24c7975"
  ],
  [
    "6593e5078466b07a4222d2e544da826d2c583c9cc5f2eaea148b129b00d4aa0",
    "11b352b08a0a61d3cd67d1dc08069dec3bde907b3da0f56de5011b956bf8744"
  ],
  [
    "7a6eb353c5be9ff03fe4a06c01fb71aad2b38144179a291ebcbb2c2417cca65",
    "3de3ecb12f2fa699b46a9d399abf77ca17bebc3e491bfb2542dd0fba991e2bb"
  ],
  [
    "2c7ead583d6c32162091034a9eddfa775b4e84b8bdbea939edb2a80dcf64f6",
    "461790ce40d9c276d962b2a1e9a74d66e9d7335962e234e8a2fc6963d31722d"
  ],
  [
    "34285af023d9b4c2c2b88e8704bf2c05a9b553b00b2e70ff05f8c2970cb134f",
    "33fe678e7671760a83836107428dbade68c3593fbe568f3f8f1b2c568099c44"
  ],
  [
    "6222f720a24466263db6a11842f117fc4bb78da6705f140e48869db3e087441",
    "6eff5b9bf3aeedc962bc5a24b66e7bdad2153450ed53a058bf2c8dbf2907693"
  ],
  [
    "17c6ec5ea206eb97cbf53851e37ce391080e0d2bf1e5395610f79ab0503f7ce",
    "3adb71ca3523d88ceb1e365f12dfb24895453c14daf0046b2626cddadfdf5f7"
  ],
  [
    "70859f9771a713e54974ce11cdaf44b0dcc3e9befa0c0834908d877eeaafd27",
    "d18f794bf0cc0623b711e7450030424e52326c45ba9b03341883ae4828a5f8"
  ],
  [
    "2a820cfd0fd4ab0871e7b303cd545a3086caf8fa818c087a4017197da74efbf",
    "5f992683ff37f6c041b84bfc01503d333ac9763505cc8f69473da01812969d1"
  ],
  [
    "5b0526de2c07fe7cd73e3884f642d57a0ac5e13c68590ed03a14e530616e8c1",
    "eec69d0cbd92c9fca31ec967dba848bec368e792d6678797946a5e34fe3487"
  ],
  [
    "6cf6b3efee707210cb3a72f1e885c3d0953aefb43e5e148c740aa1641725c61",
    "911cb630b898e2c1a9115f9e45bafe3b819edfb1eab6e15612d14289939984"
  ],
  [
    "74e913de55f1e46143cb2ecfc580f8d3d3908f200281322b84e21c989cda293",
    "761d2736c9ac7670ba905bc2629c6c0dbe988820a4454ff415ba68710f7df92"
  ],
  [
    "44084305e0c911a40b7cbefe5f13cffe9a99375d1a584c4a2200958050af7a9",
    "249c83877371564708ea525b64b1e7e12785460d83364446531c9adcacba5f0"
  ],
  [
    "2bf71ad4d1bee1a67fb300477029f54bdb0e09f78bf2ac2e8afc7465a7adbcc",
    "6244dd6cad282539049be57487bfd9900bb0d5da805d02b535096368fcb4cd5"
  ],
  [
    "3a62d8f763b62def36e4089458046a49c5ecb91b861549530773e0548ff2bb",
    "6a10a03ba61e6ac657270465c09aa9526cf1ebe96bdecdf0e7000476a47b9eb"
  ],
  [
    "284eed3a17c51e0677d4fe897f056abe9def8af07a4630e6ca5723e2aa6677",
    "516a06ac1d5626ed03d2eee9de6f60f0311eca703a99b0fb31b9c66b01c27c7"
  ],
  [
    "2a2c63b16cccd685f731d06fe93ce2cffb358d34d03dda9a7368185c1eb0c32",
    "7180baca0ba81284809f92eca1654cd76b925a9242e5d5e0f18d0a55d13c6ec"
  ],
  [
    "5f9466017ec09769611389ea5370ad68dda936d3f5816c9e928ff9574abf9a7",
    "6619b5b145bb5f4f29deb7a4cd68ef4da3995312fa6537f0d01684da4267ece"
  ],
  [
    "74f229babe01b4962b3307589c1a13019134b1db6822698388bebb55d21c30f",
    "156ae857ab3279f754facba0db36398dffec8c31e5e160473198f2f891b7531"
  ],
  [
    "334b9fe3a5fd99bc966ddd1309698fd32afd1f235062f2c275b6616a185de45",
    "221a60053583cc0607f6f2e6966b62fc9dac00538bb7eb1148e007a92116d2"
  ],
  [
    "7ad710ba002a67c731efbaba2149d16fec5d2f7aa3d126fd9886172e9f4ea30",
    "3a10f8e902a7a13aec94d66415347e1314f9bac83a7db176096b809b25ffb86"
  ],
  [
    "4306dd0a184a3283c3097ff8f7434cec80912e9dc04b7df21ba73fda9f8e6d8",
    "6d42bd3d1a8dbddafd09e872e2aa3891ae79ec939dc1b382196bc21c4ab749"
  ],
  [
    "1c3f2124e1135c32a426d1d14e471edd9e0f2c7bd703ee123cbbd608e8c4be7",
    "3cc607a3c3f1ab68dd5fa56c65996002721b8ad8ad4b0dd9e5b1467d316583"
  ],
  [
    "294af33272ffcee0b56a436de1b73759cbddebef4c07888b42c2f92b0b68e1",
    "d837164311d5dca8d37b99ef9eb22708643c83d1cbdfe852f63ea07b06fbad"
  ],
  [
    "753bdb5439a19bbffdfa02b1dc24e8368f22d0a8276b109c11e6feb26f56f39",
    "6ed396231af93647633eab467f1a034f38e76823eb85baf97cae56e2dcd9f75"
  ],
  [
    "5674f0cb892b733fc0b50e121d8679afed0a925c32594cc65ffe83bebe7748e",
    "7fbf0325dd38dd94905adab2c52758552292a6a103d9edfcb11938828e828c8"
  ],
  [
    "4a8f053573a0a74251059d0229d89b6660407ba0b491779fd10f87a5117c81f",
    "21b70112485398bf67ec9d733df24a1df30dea718a93b786f41ed04e3ae3c5e"
  ],
  [
    "726c01ec4a08df8fc8de173311f50d4f3b97c5a9cf68c1536146f827db95ae8",
    "15013cafadefa7f1c4e4dfdd70bd4d3979dd18bd7f0332572ce2a3fd8773d12"
  ],
  [
    "38ac0fbfa98937257460db7e6645d7e5112b6fce7234813fc8a704e8ade8da2",
    "73c0109f86048aad08c443f781ae60ad13b99f7b9cfdf3128fe6d6eeb799a7b"
  ],
  [
    "6f6d3a38621582ace092eb50ecfe9eff265df141ebdcab8653299116fcea291",
    "4a1bf3f39bc919c8f1b720a0b1ce952cad17f2ba98308ee6b76dd9b6f3d7b75"
  ],
  [
    "6a307fc28e1df8d9ad01766419e097797d65cb674436fa1c8f012d3de2c2a1f",
    "26911a635ba824db004875d79dd84834a97ac12643e42829015bf88c1fd6f05"
  ],
  [
    "2a74860e3336d6db916555894cc8028f41508812925db1925457afe40257155",
    "5f8da573f4c39816ce2dba8a20224223a7cfec53117ec78973930c0e9b60244"
  ],
  [
    "4d2b49e1ed0799f719b8269f092cb489a466a645bc0ccabafdc678864c176d7",
    "5410083df7d256f18cbf5697ae5e52c31e075d8a3b27e21d6f5177ca882f6c1"
  ],
  [
    "110ecb9fbf6c333d168cee473cc5ad98809b6cb9eb5d1f6cd28ab5fab504fd3",
    "7e3c54d7533d9f8c3310f219dab0cc3ea4d39b418a748eeffd6bae2b8637a43"
  ],
  [
    "5be4d711b80da70e6d3ac493250bbfd16f20b25f31919b3a91cf14ffbac1096",
    "7f55a0919f082e8885f1515e83c5b39b6022404503507498e1b4422d79c43e2"
  ],
  [
    "2605125b95ca4ba93a21cbbba5762898a7cf9e988f07ab9e64cb3868e3b139d",
    "62f0ccf55b9fc0eaf9736fc8ee484e2acdbe259813af9803cf815829a5e9d3b"
  ],
  [
    "1092bbbf206f2a3068167c3dd99a72de31e206f6c504c071c8214d105ff814d",
    "309f489f68a62089f53b96df5d4fbc3ecc5a1a42eb7ece0e49bad17ad490ff4"
  ],
  [
    "2abdee9409d9c92559ca3f4e6bddd649c31aa09b90bfcb4a612af491241e18d",
    "3ffa8eac180a29de3f8a69efca84bac046f921f5725e96a6ff0530be1436aaf"
  ],
  [
    "376313f27d00bb1aae7ec991745efe6ee28c6b50de0c6cd9845cc4bb4f83543",
    "6a8e0a9389ba528b156fa94ac090a895d7b795818d4941c29415d9e2984c547"
  ],
  [
    "a80380c71bd466a696b3f0fbf02817c9459d9798f4f3899cf32edf647fe066",
    "6a09805e814e7cdfc76eba4b79f1df5ae559e0f0aba9f728d3cba4ea5c57471"
  ],
  [
    "223694b921d247d989a79b9b2b2f07496036c40cb043eab074a9d6a2cd2ffed",
    "c247217f1b1df35e30d9e15fdaadf42d6fb0edd3a5a7e265d4cdc426c120aa"
  ],
  [
    "102333620df278c6714bbc880fc087db58c1b9b4d77ed4d61b32a74bfc7c3e2",
    "6a77d37727ccf71c2caeb151faf4404d4b94e9047f9f0a7c3966367f3b53c65"
  ],
  [
    "891626f466536929ee7eadcd18b41925706dedab7528ed5f0f7abf039eb9d2",
    "5f73d11c141c933a35b2d0d06e5cbae614a20d17dc3b439f8bcdc3413c5ea37"
  ],
  [
    "215c23fd3f073f870e5e80303967391bf173f8adcdbeec72d131c557babc203",
    "10634332e9d9439a321597dc5b0fac9ff478834c3d6e281735f21a4a5e13266"
  ],
  [
    "21ea0bdc1332bc36e6aeb43be9071651c27e4ea2eadec636c8d818d4af72a36",
    "3a523d9643dccc6bb9c7c58413312caa3e60ba9c7c7f0177e0f3f469a3241e3"
  ],
  [
    "60deaed1bffb6190beed40caaf2bfab5e43d3707aff7ad3f278d571aa247eae",
    "e41f71ff254c1418e6a66992af307789fe04d6606fb2670900bb1a089fd879"
  ],
  [
    "1e1fac4a1646253fb1332fadc21fbdd3e3a24a840d129400f520ae4116a4cf5",
    "69c406f9f46576afad68808de0ab7e8922b6226af748e721d9097e21f1800f3"
  ],
  [
    "5db0ddcdf79ffe74d6454c12d2bc60b06776db03c75dc413f5be42ea9a91b5e",
    "134c3d6c699841f17306835bb193785228ffe7ab212a01a861c56b086a18cec"
  ],
  [
    "626814e320fb5bea505b248fd1c1389ad586c1cfe04923fe2f83173e915f4f8",
    "7ae407a926e887206a8b85cf485f1f327c9bb8ccbb6897024e2d122877d8ee0"
  ],
  [
    "23186237dc7d3b570cea645282ad4c359731bbfa54e7f036426bf6493812cd",
    "7d1fbab7e61a22d3b00993290d9f4cd5d820061573e787f66c2cff9a18e1eaf"
  ],
  [
    "54302dcb0e6cc1c6e44cca8f61a63bb2ca65048d53fb325d36ff12c49a58202",
    "1b77b3e37d13504b348046268d8ae25ce98ad783c25561a879dcc77e99c2426"
  ],
  [
    "13961b56b9fc0e412e468c385c22bd0680a25624ec211ffbb6bc877b2a6926c",
    "62f7f7792c77cd981fad13cb6863fe099c4d971c1374109185eae99943f16e9"
  ],
  [
    "47abd7308c70659af3f00fafe6837298af3cb530b6c2ba710ffd07a6bc1ae98",
    "75d0c8a7377aa9f0663d0c124a5659750847afabc29e39893fd27534a4a03cb"
  ],
  [
    "2c6276b764fb398fa555857dbe0ce0ec18fab7a233bf23851295739801f0585",
    "5d8f4897ce44007ec5bfcb9aeb78b8f6e1d40a514f72d213c9300d2770d2b8c"
  ]
], h3 = {};
pe(h3, {
  BlockStatus: () => yl,
  BlockTag: () => ao,
  EntryPointType: () => ll,
  RPC: () => oa,
  SIMULATION_FLAG: () => fl,
  Sequencer: () => m3,
  TransactionExecutionStatus: () => ml,
  TransactionFinalityStatus: () => pl,
  TransactionStatus: () => hl,
  TransactionType: () => bl,
  Uint: () => to,
  ValidateType: () => ul
});
var fl = /* @__PURE__ */ ((e) => (e.SKIP_VALIDATE = "SKIP_VALIDATE", e.SKIP_EXECUTE = "SKIP_EXECUTE", e))(fl || {}), ul = /* @__PURE__ */ ((e) => (e.DEPLOY = "DEPLOY", e.CALL = "CALL", e.INVOKE = "INVOKE", e))(ul || {}), to = /* @__PURE__ */ ((e) => (e.u8 = "core::integer::u8", e.u16 = "core::integer::u16", e.u32 = "core::integer::u32", e.u64 = "core::integer::u64", e.u128 = "core::integer::u128", e.u256 = "core::integer::u256", e))(to || {}), ll = /* @__PURE__ */ ((e) => (e.EXTERNAL = "EXTERNAL", e.L1_HANDLER = "L1_HANDLER", e.CONSTRUCTOR = "CONSTRUCTOR", e))(ll || {}), bl = /* @__PURE__ */ ((e) => (e.DECLARE = "DECLARE", e.DEPLOY = "DEPLOY", e.DEPLOY_ACCOUNT = "DEPLOY_ACCOUNT", e.INVOKE = "INVOKE_FUNCTION", e))(bl || {}), hl = /* @__PURE__ */ ((e) => (e.NOT_RECEIVED = "NOT_RECEIVED", e.RECEIVED = "RECEIVED", e.ACCEPTED_ON_L2 = "ACCEPTED_ON_L2", e.ACCEPTED_ON_L1 = "ACCEPTED_ON_L1", e.REJECTED = "REJECTED", e.REVERTED = "REVERTED", e))(hl || {}), pl = /* @__PURE__ */ ((e) => (e.NOT_RECEIVED = "NOT_RECEIVED", e.RECEIVED = "RECEIVED", e.ACCEPTED_ON_L2 = "ACCEPTED_ON_L2", e.ACCEPTED_ON_L1 = "ACCEPTED_ON_L1", e))(pl || {}), ml = /* @__PURE__ */ ((e) => (e.REJECTED = "REJECTED", e.REVERTED = "REVERTED", e.SUCCEEDED = "SUCCEEDED", e))(ml || {}), yl = /* @__PURE__ */ ((e) => (e.PENDING = "PENDING", e.ACCEPTED_ON_L1 = "ACCEPTED_ON_L1", e.ACCEPTED_ON_L2 = "ACCEPTED_ON_L2", e.REJECTED = "REJECTED", e))(yl || {}), ao = /* @__PURE__ */ ((e) => (e.pending = "pending", e.latest = "latest", e))(ao || {}), oa = {};
pe(oa, {
  SimulationFlag: () => oi,
  TransactionExecutionStatus: () => fi,
  TransactionFinalityStatus: () => di,
  TransactionType: () => p3
});
var gl = /* @__PURE__ */ ((e) => (e.DECLARE = "DECLARE", e.DEPLOY = "DEPLOY", e.DEPLOY_ACCOUNT = "DEPLOY_ACCOUNT", e.INVOKE = "INVOKE", e.L1_HANDLER = "L1_HANDLER", e))(gl || {}), _l = /* @__PURE__ */ ((e) => (e.ACCEPTED_ON_L2 = "ACCEPTED_ON_L2", e.ACCEPTED_ON_L1 = "ACCEPTED_ON_L1", e))(_l || {}), vl = /* @__PURE__ */ ((e) => (e.SUCCEEDED = "SUCCEEDED", e.REVERTED = "REVERTED", e))(vl || {}), wl = /* @__PURE__ */ ((e) => (e.SKIP_VALIDATE = "SKIP_VALIDATE", e.SKIP_FEE_CHARGE = "SKIP_FEE_CHARGE", e))(wl || {}), p3 = gl, oi = wl, di = _l, fi = vl, m3 = {};
function ve(e, t) {
  if (!e)
    throw new Error(t || "Assertion failure");
}
var y3 = {};
pe(y3, {
  assertInRange: () => g3,
  bigNumberishArrayToDecimalStringArray: () => xl,
  bigNumberishArrayToHexadecimalStringArray: () => Tl,
  cleanHex: () => ui,
  getDecimalString: () => Sl,
  getHexString: () => no,
  getHexStringArray: () => Cl,
  hexToBytes: () => Al,
  hexToDecimalString: () => kl,
  isBigInt: () => Vs,
  isHex: () => bt,
  isStringWholeNumber: () => mr,
  toBigInt: () => $,
  toCairoBool: () => li,
  toHex: () => B,
  toHexString: () => ro,
  toStorageKey: () => El
});
function bt(e) {
  return /^0x[0-9a-f]*$/i.test(e);
}
function $(e) {
  return BigInt(e);
}
function Vs(e) {
  return typeof e == "bigint";
}
function B(e) {
  return Re($(e).toString(16));
}
function El(e) {
  return Re($(e).toString(16).padStart(64, "0"));
}
function kl(e) {
  return BigInt(Re(e)).toString(10);
}
var ui = (e) => e.toLowerCase().replace(/^(0x)0+/, "$1");
function g3(e, t, a, r = "") {
  const n = r === "" ? "invalid length" : `invalid ${r} length`, s = BigInt(e), c = BigInt(t), i = BigInt(a);
  ve(
    s >= c && s <= i,
    `Message not signable, ${n}.`
  );
}
function xl(e) {
  return e.map((t) => $(t).toString(10));
}
function Tl(e) {
  return e.map((t) => B(t));
}
var mr = (e) => /^\d+$/.test(e), ro = (e) => B(e);
function Sl(e) {
  if (bt(e))
    return kl(e);
  if (mr(e))
    return e;
  throw new Error(`${e} need to be hex-string or whole-number-string`);
}
function no(e) {
  if (bt(e))
    return e;
  if (mr(e))
    return ro(e);
  throw new Error(`${e} need to be hex-string or whole-number-string`);
}
function Cl(e) {
  return e.map((t) => no(t));
}
var li = (e) => (+e).toString();
function Al(e) {
  if (!bt(e))
    throw new Error(`${e} need to be a hex-string`);
  let t = pr(e);
  return t.length % 2 !== 0 && (t = `0${t}`), Ht(t);
}
var _3 = {};
pe(_3, {
  getSelector: () => co,
  getSelectorFromName: () => Xe,
  keccakBn: () => Ol,
  starknetKeccak: () => so
});
function Ol(e) {
  const t = pr(B(BigInt(e))), a = t.length % 2 === 0 ? t : `0${t}`;
  return Re(wn(Al(Re(a))).toString(16));
}
function v3(e) {
  return Re(wn(Hs(e)).toString(16));
}
function so(e) {
  return BigInt(v3(e)) & nl;
}
function Xe(e) {
  return B(so(e));
}
function co(e) {
  return bt(e) ? e : mr(e) ? ro(e) : Xe(e);
}
var w3 = {};
pe(w3, {
  decodeShortString: () => uo,
  encodeShortString: () => ta,
  isASCII: () => io,
  isDecimalString: () => Nl,
  isLongText: () => oo,
  isShortString: () => On,
  isShortText: () => E3,
  isText: () => In,
  splitLongString: () => fo
});
var Il = 31;
function io(e) {
  return /^[\x00-\x7F]*$/.test(e);
}
function On(e) {
  return e.length <= Il;
}
function Nl(e) {
  return /^[0-9]*$/i.test(e);
}
function In(e) {
  return typeof e == "string" && !bt(e) && !mr(e);
}
var E3 = (e) => In(e) && On(e), oo = (e) => In(e) && !On(e);
function fo(e) {
  const t = RegExp(`[^]{1,${Il}}`, "g");
  return e.match(t) || [];
}
function ta(e) {
  if (!io(e))
    throw new Error(`${e} is not an ASCII string`);
  if (!On(e))
    throw new Error(`${e} is too long`);
  return Re(e.replace(/./g, (t) => t.charCodeAt(0).toString(16)));
}
function uo(e) {
  if (!io(e))
    throw new Error(`${e} is not an ASCII string`);
  if (bt(e))
    return pr(e).replace(/.{2}/g, (t) => String.fromCharCode(parseInt(t, 16)));
  if (Nl(e))
    return uo("0X".concat(BigInt(e).toString(16)));
  throw new Error(`${e} is not Hex or decimal`);
}
var k3 = {};
pe(k3, {
  felt: () => Ue,
  getArrayType: () => Nn,
  isCairo1Abi: () => jl,
  isCairo1Type: () => qt,
  isLen: () => wa,
  isTypeArray: () => vt,
  isTypeBool: () => Ks,
  isTypeContractAddress: () => Ll,
  isTypeFelt: () => os,
  isTypeNamedTuple: () => Pl,
  isTypeStruct: () => tr,
  isTypeTuple: () => ct,
  isTypeUint: () => ho,
  isTypeUint256: () => kt,
  tuple: () => S3,
  uint256: () => po
});
var x3 = {};
pe(x3, {
  UINT_128_MAX: () => lo,
  UINT_256_MAX: () => Rl,
  bnToUint256: () => T3,
  isUint256: () => bo,
  uint256ToBN: () => qs
});
function qs(e) {
  return ($(e.high) << 128n) + $(e.low);
}
var lo = (1n << 128n) - 1n, Rl = (1n << 256n) - 1n;
function bo(e) {
  return $(e) <= Rl;
}
function T3(e) {
  const t = $(e);
  if (!bo(t))
    throw new Error("Number is too large");
  return {
    low: Re((t & lo).toString(16)),
    high: Re((t >> 128n).toString(16))
  };
}
var wa = (e) => /_len$/.test(e), os = (e) => e === "felt" || e === "core::felt252", vt = (e) => /\*/.test(e) || e.startsWith("core::array::Array::"), ct = (e) => /^\(.*\)$/i.test(e), Pl = (e) => /\(.*\)/i.test(e) && e.includes(":"), tr = (e, t) => e in t, ho = (e) => Object.values(to).includes(e), kt = (e) => e === "core::integer::u256", Ks = (e) => e === "core::bool", Ll = (e) => e === "core::starknet::contract_address::ContractAddress", qt = (e) => e.includes("core::"), Nn = (e) => qt(e) ? e.substring(e.indexOf("<") + 1, e.lastIndexOf(">")) : e.replace("*", "");
function jl(e) {
  const t = e.find((a) => a.type === "function");
  if (!t) {
    if (e.find((a) => a.type === "interface"))
      return !0;
    throw new Error("Error in ABI. No function in ABI.");
  }
  if (t.inputs.length)
    return qt(t.inputs[0].type);
  if (t.outputs.length)
    return qt(t.outputs[0].type);
  throw new Error(`Error in ABI. No input/output in function ${t.name}`);
}
var po = (e) => {
  const t = BigInt(e);
  if (!bo(t))
    throw new Error("Number is too large");
  return {
    // eslint-disable-next-line no-bitwise
    low: (t & lo).toString(10),
    // eslint-disable-next-line no-bitwise
    high: (t >> 128n).toString(10)
  };
}, S3 = (...e) => ({ ...e });
function Ue(e) {
  if (Vs(e) || typeof e == "number" && Number.isInteger(e))
    return e.toString();
  if (In(e)) {
    if (!On(e))
      throw new Error(
        `${e} is a long string > 31 chars, felt can store short strings, split it to array of short strings`
      );
    const t = ta(e);
    return BigInt(t).toString();
  }
  if (typeof e == "string" && bt(e))
    return BigInt(e).toString();
  if (typeof e == "string" && mr(e))
    return e;
  if (typeof e == "boolean")
    return `${+e}`;
  throw new Error(`${e} can't be computed by felt()`);
}
var Oc = {
  isBN: (e, t, a) => {
    if (!Vs(e[a]))
      throw new Error(
        `Data and formatter mismatch on ${a}:${t[a]}, expected response data ${a}:${e[a]} to be BN instead it is ${typeof e[a]}`
      );
  },
  unknown: (e, t, a) => {
    throw new Error(`Unhandled formatter type on ${a}:${t[a]} for data ${a}:${e[a]}`);
  }
};
function Gn(e, t, a) {
  return Object.entries(e).reduce((r, [n, s]) => {
    const c = a ?? t[n];
    if (!(n in t) && !a)
      return r[n] = s, r;
    if (c === "string") {
      if (Array.isArray(e[n])) {
        const i = Gn(
          e[n],
          e[n].map((o) => c)
        );
        return r[n] = Object.values(i).join(""), r;
      }
      return Oc.isBN(e, t, n), r[n] = uo(s), r;
    }
    if (c === "number")
      return Oc.isBN(e, t, n), r[n] = Number(s), r;
    if (typeof c == "function")
      return r[n] = c(s), r;
    if (Array.isArray(c)) {
      const i = Gn(e[n], c, c[0]);
      return r[n] = Object.values(i), r;
    }
    return typeof c == "object" ? (r[n] = Gn(e[n], c), r) : (Oc.unknown(e, t, n), r);
  }, {});
}
var C3 = class {
  constructor(e) {
    this.abi = e;
  }
  /**
   * abi method inputs length without '_len' inputs
   * cairo 0 reducer
   * @param abiMethod FunctionAbi
   * @returns number
   */
  methodInputsLength(e) {
    return e.inputs.reduce((t, a) => wa(a.name) ? t : t + 1, 0);
  }
  /**
   * get method definition from abi
   * @param name string
   * @returns FunctionAbi | undefined
   */
  getMethod(e) {
    return this.abi.find((t) => t.name === e);
  }
  /**
   * Get Abi in legacy format
   * @returns Abi
   */
  getLegacyFormat() {
    return this.abi;
  }
}, A3 = class {
  constructor(e) {
    this.abi = e;
  }
  /**
   * abi method inputs length
   * @param abiMethod FunctionAbi
   * @returns number
   */
  methodInputsLength(e) {
    return e.inputs.length;
  }
  /**
   * get method definition from abi
   * @param name string
   * @returns FunctionAbi | undefined
   */
  getMethod(e) {
    return this.abi.find((t) => t.type === "interface").items.find((t) => t.name === e);
  }
  /**
   * Get Abi in legacy format
   * @returns Abi
   */
  getLegacyFormat() {
    return this.abi.flatMap((e) => e.type === "interface" ? e.items : e);
  }
};
function O3(e) {
  const t = I3(e);
  if (t === 0 || t === 1)
    return new C3(e);
  if (t === 2)
    return new A3(e);
  throw Error(`Unsupported ABI version ${t}`);
}
function I3(e) {
  return e.find((t) => t.type === "interface") ? 2 : jl(e) ? 1 : 0;
}
function qd(e, t, a) {
  return e === "constructor" && !a && !t.length;
}
function N3(e) {
  const t = e.substring(0, e.indexOf(":")), a = e.substring(t.length + 1);
  return { name: t, type: a };
}
function Zl(e) {
  if (!e.includes("("))
    return { subTuple: [], result: e };
  const t = [];
  let a = "", r = 0;
  for (; r < e.length; ) {
    if (e[r] === "(") {
      let n = 1;
      const s = r;
      for (r++; n; )
        e[r] === ")" && n--, e[r] === "(" && n++, r++;
      t.push(e.substring(s, r)), a += " ", r--;
    } else
      a += e[r];
    r++;
  }
  return {
    subTuple: t,
    result: a
  };
}
function R3(e) {
  const t = e.replace(/\s/g, "").slice(1, -1), { subTuple: a, result: r } = Zl(t);
  let n = r.split(",").map((s) => a.length ? s.replace(" ", a.shift()) : s);
  return Pl(e) && (n = n.reduce((s, c) => s.concat(N3(c)), [])), n;
}
function P3(e) {
  const t = e.replace(/\s/g, "").slice(1, -1), { subTuple: a, result: r } = Zl(t);
  return r.split(",").map((n) => a.length ? n.replace(" ", a.shift()) : n);
}
function mo(e) {
  return qt(e) ? P3(e) : R3(e);
}
function Ic(e) {
  return Error(
    `Your object includes the property : ${e}, containing an Uint256 object without the 'low' and 'high' keys.`
  );
}
function L3(e, t, a) {
  const r = (c, i) => i.reduce((o, d) => {
    const f = (u) => Object.defineProperty(o, d.name, {
      enumerable: !0,
      value: u ?? c[d.name]
    });
    if (c[d.name] === "undefined" && (qt(d.type) || !wa(d.name)))
      throw Error(`Your object needs a property with key : ${d.name} .`);
    switch (!0) {
      case tr(d.type, a):
        f(
          r(
            c[d.name],
            a[d.type].members
          )
        );
        break;
      case kt(d.type): {
        const u = c[d.name];
        if (typeof u != "object") {
          f();
          break;
        }
        if (!("low" in u && "high" in u))
          throw Ic(d.name);
        f({ low: u.low, high: u.high });
        break;
      }
      case ct(d.type):
        f(s(c[d.name], d));
        break;
      case vt(d.type):
        f(n(c[d.name], d));
        break;
      case (!qt(d.type) && wa(d.name)):
        break;
      default:
        f();
    }
    return o;
  }, {});
  function n(c, i) {
    const o = Nn(i.type);
    if (typeof c == "string")
      return c;
    switch (!0) {
      case o in a:
        return c.map((d) => r(d, a[o].members));
      case o === "core::integer::u256":
        return c.map((d) => {
          if (typeof d != "object")
            return d;
          if (!("low" in d && "high" in d))
            throw Ic(i.name);
          return { low: d.low, high: d.high };
        });
      case ct(o):
        return c.map((d) => s(d, { name: "0", type: o }));
      case vt(o):
        return c.map((d) => n(d, { name: "0", type: o }));
      default:
        return c;
    }
  }
  function s(c, i) {
    return mo(i.type).reduce((o, d, f) => {
      const u = Object.keys(c), l = (p) => Object.defineProperty(o, f.toString(), {
        enumerable: !0,
        value: p ?? c[u[f]]
      }), b = d?.type ? d.type : d;
      switch (!0) {
        case tr(b, a):
          l(
            r(
              c[u[f]],
              a[b].members
            )
          );
          break;
        case kt(b): {
          const p = c[u[f]];
          if (typeof p != "object") {
            l();
            break;
          }
          if (!("low" in p && "high" in p))
            throw Ic(i.name);
          l({ low: p.low, high: p.high });
          break;
        }
        case ct(b):
          l(
            s(c[u[f]], {
              name: "0",
              type: b
            })
          );
          break;
        case vt(b):
          l(
            n(c[u[f]], {
              name: "0",
              type: b
            })
          );
          break;
        default:
          l();
      }
      return o;
    }, {});
  }
  return r(e, t);
}
function Dl(e, t) {
  switch (!0) {
    case kt(e):
      const a = po(t);
      return [Ue(a.low), Ue(a.high)];
    default:
      return Ue(t);
  }
}
function j3(e, t) {
  const a = mo(t), r = Object.values(e);
  if (r.length !== a.length)
    throw Error(
      `ParseTuple: provided and expected abi tuple size do not match.
      provided: ${r} 
      expected: ${a}`
    );
  return a.map((n, s) => ({
    element: r[s],
    type: n.type ?? n
  }));
}
function Kd(e) {
  if (typeof e == "object") {
    const { low: a, high: r } = e;
    return [Ue(a), Ue(r)];
  }
  const t = po(e);
  return [Ue(t.low), Ue(t.high)];
}
function Lr(e, t, a) {
  if (e === void 0)
    throw Error(`Missing parameter for type ${t}`);
  if (Array.isArray(e)) {
    const r = [];
    r.push(Ue(e.length));
    const n = Nn(t);
    return e.reduce((s, c) => s.concat(Lr(c, n, a)), r);
  }
  if (a[t] && a[t].members.length) {
    if (kt(t))
      return Kd(e);
    const { members: r } = a[t], n = e;
    return r.reduce((s, c) => s.concat(Lr(n[c.name], c.type, a)), []);
  }
  if (ct(t))
    return j3(e, t).reduce((r, n) => {
      const s = Lr(n.element, n.type, a);
      return r.concat(s);
    }, []);
  if (kt(t))
    return Kd(e);
  if (typeof e == "object")
    throw Error(`Parameter ${e} do not align with abi parameter ${t}`);
  return Dl(t, e);
}
function Z3(e, t, a) {
  const { name: r, type: n } = t;
  let { value: s } = e.next();
  switch (!0) {
    case vt(n):
      if (!Array.isArray(s) && !In(s))
        throw Error(`ABI expected parameter ${r} to be array or long string, got ${s}`);
      return typeof s == "string" && (s = fo(s)), Lr(s, t.type, a);
    case (tr(n, a) || ct(n) || kt(n)):
      return Lr(s, n, a);
    default:
      return Dl(n, s);
  }
}
function Bl(e, t) {
  let a;
  switch (!0) {
    case Ks(e):
      return a = t.next().value, !!BigInt(a);
    case kt(e):
      const r = t.next().value, n = t.next().value;
      return qs({ low: r, high: n });
    default:
      return a = t.next().value, BigInt(a);
  }
}
function qa(e, t, a) {
  if (kt(t.type)) {
    const r = e.next().value, n = e.next().value;
    return qs({ low: r, high: n });
  }
  if (t.type in a && a[t.type])
    return a[t.type].members.reduce((r, n) => (r[n.name] = qa(e, n, a), r), {});
  if (ct(t.type))
    return mo(t.type).reduce((r, n, s) => {
      const c = n?.name ? n.name : s, i = n?.type ? n.type : n, o = { name: c, type: i };
      return r[c] = qa(e, o, a), r;
    }, {});
  if (vt(t.type)) {
    const r = [], n = { name: "", type: Nn(t.type) }, s = BigInt(e.next().value);
    for (; r.length < s; )
      r.push(qa(e, n, a));
    return r;
  }
  return Bl(t.type, e);
}
function D3(e, t, a, r) {
  const { name: n, type: s } = t;
  let c;
  switch (!0) {
    case wa(n):
      return c = e.next().value, BigInt(c);
    case (s in a || ct(s)):
      return qa(e, t, a);
    case vt(s):
      if (qt(s))
        return qa(e, t, a);
      const i = [];
      if (r && r[`${n}_len`]) {
        const o = r[`${n}_len`];
        for (; i.length < o; )
          i.push(
            qa(
              e,
              { name: n, type: t.type.replace("*", "") },
              a
            )
          );
      }
      return i;
    default:
      return Bl(s, e);
  }
}
var Fl = (e, t) => {
  ve(
    typeof e == "string" || typeof e == "number" || typeof e == "bigint",
    `Validate: arg ${t.name} should be a felt typed as (String, Number or BigInt)`
  );
}, yo = (e, t) => {
  typeof e == "number" && ve(
    e <= Number.MAX_SAFE_INTEGER,
    "Validation: Parameter is to large to be typed as Number use (BigInt or String)"
  ), ve(
    typeof e == "string" || typeof e == "number" || typeof e == "bigint" || typeof e == "object" && "low" in e && "high" in e,
    `Validate: arg ${t.name} of cairo ZORG type ${t.type} should be type (String, Number or BigInt)`
  );
  const a = typeof e == "object" ? qs(e) : $(e);
  switch (t.type) {
    case "core::integer::u8":
      ve(
        a >= 0n && a <= 255n,
        `Validate: arg ${t.name} cairo typed ${t.type} should be in range [0 - 255]`
      );
      break;
    case "core::integer::u16":
      ve(
        a >= 0n && a <= 65535n,
        `Validate: arg ${t.name} cairo typed ${t.type} should be in range [0, 65535]`
      );
      break;
    case "core::integer::u32":
      ve(
        a >= 0n && a <= 4294967295n,
        `Validate: arg ${t.name} cairo typed ${t.type} should be in range [0, 4294967295]`
      );
      break;
    case "core::integer::u64":
      ve(
        a >= 0n && a <= 2n ** 64n - 1n,
        `Validate: arg ${t.name} cairo typed ${t.type} should be in range [0, 2^64-1]`
      );
      break;
    case "core::integer::u128":
      ve(
        a >= 0n && a <= 2n ** 128n - 1n,
        `Validate: arg ${t.name} cairo typed ${t.type} should be in range [0, 2^128-1]`
      );
      break;
    case "core::integer::u256":
      ve(
        a >= 0n && a <= 2n ** 256n - 1n,
        `Validate: arg ${t.name} is ${t.type} 0 - 2^256-1`
      );
      break;
  }
}, Ul = (e, t) => {
  ve(
    typeof e == "boolean",
    `Validate: arg ${t.name} of cairo type ${t.type} should be type (Boolean)`
  );
}, $l = (e, t, a) => {
  if (t.type === "core::integer::u256") {
    yo(e, t);
    return;
  }
  ve(
    typeof e == "object" && !Array.isArray(e),
    `Validate: arg ${t.name} is cairo type struct (${t.type}), and should be defined as js object (not array)`
  ), a[t.type].members.forEach(({ name: r }) => {
    ve(
      Object.keys(e).includes(r),
      `Validate: arg ${t.name} should have a property ${r}`
    );
  });
}, zl = (e, t) => {
  ve(
    typeof e == "object" && !Array.isArray(e),
    `Validate: arg ${t.name} should be a tuple (defined as object)`
  );
}, Ml = (e, t, a) => {
  const r = Nn(t.type);
  if (!(os(r) && oo(e)))
    switch (ve(Array.isArray(e), `Validate: arg ${t.name} should be an Array`), !0) {
      case os(r):
        e.forEach((n) => Fl(n, t));
        break;
      case ct(r):
        e.forEach((n) => zl(n, { name: t.name, type: r }));
        break;
      case tr(r, a):
        e.forEach(
          (n) => $l(n, { name: t.name, type: r }, a)
        );
        break;
      case ho(r):
        e.forEach((n) => yo(n, t));
        break;
      case Ks(r):
        e.forEach((n) => Ul(n, t));
        break;
      case vt(r):
        e.forEach(
          (n) => Ml(n, { name: "", type: r }, a)
        );
        break;
      default:
        throw new Error(
          `Validate Unhandled: argument ${t.name}, type ${t.type}, value ${e}`
        );
    }
};
function Wd(e, t, a) {
  e.inputs.reduce((r, n) => {
    const s = t[r];
    switch (!0) {
      case wa(n.name):
        return r;
      case os(n.type):
        Fl(s, n);
        break;
      case ho(n.type):
        yo(s, n);
        break;
      case Ks(n.type):
        Ul(s, n);
        break;
      case Ll(n.type):
        break;
      case tr(n.type, a):
        $l(s, n, a);
        break;
      case ct(n.type):
        zl(s, n);
        break;
      case vt(n.type):
        Ml(s, n, a);
        break;
      default:
        throw new Error(
          `Validate Unhandled: argument ${n.name}, type ${n.type}, value ${s}`
        );
    }
    return r + 1;
  }, 0);
}
var se = class {
  constructor(e) {
    this.structs = se.getAbiStruct(e), this.parser = O3(e), this.abi = this.parser.getLegacyFormat();
  }
  /**
   * Validate arguments passed to the method as corresponding to the ones in the abi
   * @param type ValidateType - type of the method
   * @param method string - name of the method
   * @param args ArgsOrCalldata - arguments that are passed to the method
   */
  validate(e, t, a = []) {
    if (e !== "DEPLOY") {
      const s = this.abi.filter((c) => {
        if (c.type !== "function")
          return !1;
        const i = c.stateMutability === "view" || c.state_mutability === "view";
        return e === "INVOKE" ? !i : i;
      }).map((c) => c.name);
      ve(
        s.includes(t),
        `${e === "INVOKE" ? "invocable" : "viewable"} method not found in abi`
      );
    }
    const r = this.abi.find(
      (s) => e === "DEPLOY" ? s.name === t && s.type === "constructor" : s.name === t && s.type === "function"
    );
    if (qd(t, a, r))
      return;
    const n = this.parser.methodInputsLength(r);
    if (a.length !== n)
      throw Error(
        `Invalid number of arguments, expected ${n} arguments, but got ${a.length}`
      );
    Wd(r, a, this.structs);
  }
  /**
   * Compile contract callData with abi
   * Parse the calldata by using input fields from the abi for that method
   * @param method string - method name
   * @param args RawArgs - arguments passed to the method. Can be an array of arguments (in the order of abi definition), or an object constructed in conformity with abi (in this case, the parameter can be in a wrong order).
   * @return Calldata - parsed arguments in format that contract is expecting
   * @example
   * ```typescript
   * const calldata = myCallData.compile("constructor",["0x34a",[1,3n]]);
   * ```
   * ```typescript
   * const calldata2 = myCallData.compile("constructor",{list:[1,3n],balance:"0x34"}); // wrong order is valid
   * ```
   */
  compile(e, t) {
    const a = this.abi.find((c) => c.name === e);
    if (qd(e, t, a))
      return [];
    let r;
    if (Array.isArray(t))
      r = t;
    else {
      const c = L3(t, a.inputs, this.structs);
      r = Object.values(c), Wd(a, r, this.structs);
    }
    const n = r[Symbol.iterator](), s = a.inputs.reduce(
      (c, i) => wa(i.name) ? c : c.concat(Z3(n, i, this.structs)),
      []
    );
    return Object.defineProperty(s, "__compiled__", {
      enumerable: !1,
      writable: !1,
      value: !0
    }), s;
  }
  /**
   * Compile contract callData without abi
   * @param rawArgs RawArgs representing cairo method arguments or string array of compiled data
   * @returns Calldata
   */
  static compile(e) {
    const t = (r) => {
      const n = (s, c = "") => {
        const i = Array.isArray(s) ? [s.length.toString(), ...s] : s;
        return Object.entries(i).flatMap(([o, d]) => {
          let f = d;
          oo(f) && (f = fo(f)), o === "entrypoint" && (f = Xe(f));
          const u = Array.isArray(i) && o === "0" ? "$$len" : o;
          return Vs(f) ? [[`${c}${u}`, Ue(f)]] : Object(f) === f ? n(f, `${c}${u}.`) : [[`${c}${u}`, Ue(f)]];
        });
      };
      return Object.fromEntries(n(r));
    };
    let a;
    if (Array.isArray(e)) {
      const r = { ...e }, n = t(r);
      a = Object.values(n);
    } else {
      const r = t(e);
      a = Object.values(r);
    }
    return Object.defineProperty(a, "__compiled__", {
      enumerable: !1,
      writable: !1,
      value: !0
    }), a;
  }
  /**
   * Parse elements of the response array and structuring them into response object
   * @param method string - method name
   * @param response string[] - response from the method
   * @return Result - parsed response corresponding to the abi
   */
  parse(e, t) {
    const { outputs: a } = this.abi.find((s) => s.name === e), r = t.flat()[Symbol.iterator](), n = a.flat().reduce((s, c, i) => {
      const o = c.name ?? i;
      return s[o] = D3(r, c, this.structs, s), s[o] && s[`${o}_len`] && delete s[`${o}_len`], s;
    }, {});
    return Object.keys(n).length === 1 && 0 in n ? n[0] : n;
  }
  /**
   * Format cairo method response data to native js values based on provided format schema
   * @param method string - cairo method name
   * @param response string[] - cairo method response
   * @param format object - formatter object schema
   * @returns Result - parsed and formatted response object
   */
  format(e, t, a) {
    const r = this.parse(e, t);
    return Gn(r, a);
  }
  /**
   * Helper to extract structs from abi
   * @param abi Abi
   * @returns AbiStructs - structs from abi
   */
  static getAbiStruct(e) {
    return e.filter((t) => t.type === "struct").reduce(
      (t, a) => ({
        ...t,
        [a.name]: a
      }),
      {}
    );
  }
  /**
   * Helper: Compile HexCalldata | RawCalldata | RawArgs
   * @param rawCalldata HexCalldata | RawCalldata | RawArgs
   * @returns Calldata
   */
  static toCalldata(e = []) {
    return se.compile(e);
  }
  /**
   * Helper: Convert raw to HexCalldata
   * @param raw HexCalldata | RawCalldata | RawArgs
   * @returns HexCalldata
   */
  static toHex(e = []) {
    return se.compile(e).map((t) => B(t));
  }
}, B3 = {};
pe(B3, {
  calculateContractAddressFromHash: () => Yn,
  calculateDeclareTransactionHash: () => Vl,
  calculateDeployAccountTransactionHash: () => ql,
  calculateDeployTransactionHash: () => M3,
  calculateTransactionHash: () => Kl,
  calculateTransactionHashCommon: () => Rn,
  computeCompiledClassHash: () => Yl,
  computeContractClassHash: () => Xl,
  computeHashOnElements: () => Te,
  computeLegacyContractClassHash: () => Gl,
  computeSierraContractClassHash: () => Jl,
  default: () => Wl,
  feeTransactionVersion: () => za,
  feeTransactionVersion_2: () => ds,
  formatSpaces: () => Gr,
  getSelector: () => co,
  getSelectorFromName: () => Xe,
  getVersionsByType: () => go,
  keccakBn: () => Ol,
  poseidon: () => S2,
  starknetKeccak: () => so,
  transactionVersion: () => Bt,
  transactionVersion_2: () => ar
});
var F3 = {};
pe(F3, {
  starkCurve: () => fh,
  weierstrass: () => L2
});
var U3 = {};
pe(U3, {
  parse: () => Kt,
  parseAlwaysAsBig: () => Hl,
  stringify: () => xt,
  stringifyAlwaysAsBig: () => z3
});
var $3 = (e) => {
  if (!kn(e))
    return parseFloat(e);
  const t = parseInt(e, 10);
  return Number.isSafeInteger(t) ? t : BigInt(e);
}, Kt = (e) => nu(String(e), void 0, $3), Hl = (e) => nu(String(e), void 0, Sh), xt = (e, t, a, r) => su(e, t, a, r), z3 = xt, Bt = 1n, ar = 2n, za = 2n ** 128n + Bt, ds = 2n ** 128n + ar;
function go(e) {
  return e === "fee" ? { v1: za, v2: ds } : { v1: Bt, v2: ar };
}
function Te(e) {
  return [...e, e.length].reduce((t, a) => fr($(t), $(a)), 0).toString();
}
function Rn(e, t, a, r, n, s, c, i = []) {
  const o = Te(n), d = [
    e,
    t,
    a,
    r,
    o,
    s,
    c,
    ...i
  ];
  return Te(d);
}
function M3(e, t, a, r, n = "constructor") {
  return Rn(
    "0x6465706c6f79",
    a,
    e,
    Xe(n),
    t,
    0,
    r
  );
}
function Vl(e, t, a, r, n, s, c) {
  return Rn(
    "0x6465636c617265",
    a,
    t,
    0,
    [e],
    r,
    n,
    [s, ...c ? [c] : []]
  );
}
function ql(e, t, a, r, n, s, c, i) {
  const o = [t, r, ...a];
  return Rn(
    "0x6465706c6f795f6163636f756e74",
    n,
    e,
    0,
    o,
    s,
    c,
    [i]
  );
}
function Kl(e, t, a, r, n, s) {
  return Rn(
    "0x696e766f6b65",
    t,
    e,
    0,
    a,
    r,
    n,
    [s]
  );
}
function Yn(e, t, a, r) {
  const n = se.compile(a), s = Te(n), c = Ue("0x535441524b4e45545f434f4e54524143545f41444452455353");
  return Te([
    c,
    r,
    e,
    t,
    s
  ]);
}
function H3(e, t) {
  return e === "attributes" || e === "accessible_scopes" ? Array.isArray(t) && t.length === 0 ? void 0 : t : e === "debug_info" ? null : t === null ? void 0 : t;
}
function Gr(e) {
  let t = !1;
  const a = [];
  for (const r of e)
    r === '"' && !(a.length > 0 && a.slice(-1)[0] === "\\") && (t = !t), t ? a.push(r) : a.push(r === ":" ? ": " : r === "," ? ", " : r);
  return a.join("");
}
function Wl(e) {
  const { abi: t, program: a } = e, r = Gr(xt({ abi: t, program: a }, H3));
  return Re(wn(Hs(r)).toString(16));
}
function Gl(e) {
  const t = typeof e == "string" ? Kt(e) : e, a = B(sl), r = Te(
    t.entry_points_by_type.EXTERNAL.flatMap((d) => [d.selector, d.offset])
  ), n = Te(
    t.entry_points_by_type.L1_HANDLER.flatMap((d) => [d.selector, d.offset])
  ), s = Te(
    t.entry_points_by_type.CONSTRUCTOR.flatMap((d) => [d.selector, d.offset])
  ), c = Te(
    t.program.builtins.map((d) => ta(d))
  ), i = Wl(t), o = Te(t.program.data);
  return Te([
    a,
    r,
    n,
    s,
    c,
    i,
    o
  ]);
}
function V3(e) {
  return Vt(
    e.flatMap((t) => BigInt(ta(t)))
  );
}
function Nc(e) {
  const t = e.flatMap((a) => [BigInt(a.selector), BigInt(a.offset), V3(a.builtins)]);
  return Vt(t);
}
function Yl(e) {
  const t = BigInt(ta("COMPILED_CLASS_V1")), a = Nc(e.entry_points_by_type.EXTERNAL), r = Nc(e.entry_points_by_type.L1_HANDLER), n = Nc(e.entry_points_by_type.CONSTRUCTOR), s = Vt(e.bytecode.map((c) => BigInt(c)));
  return B(
    Vt([
      t,
      a,
      r,
      n,
      s
    ])
  );
}
function Rc(e) {
  const t = e.flatMap((a) => [BigInt(a.selector), BigInt(a.function_idx)]);
  return Vt(t);
}
function q3(e) {
  const t = Gr(xt(e.abi, null));
  return BigInt(Re(wn(Hs(t)).toString(16)));
}
function Jl(e) {
  const t = BigInt(ta("CONTRACT_CLASS_V0.1.0")), a = Rc(e.entry_points_by_type.EXTERNAL), r = Rc(e.entry_points_by_type.L1_HANDLER), n = Rc(e.entry_points_by_type.CONSTRUCTOR), s = q3(e), c = Vt(e.sierra_program.map((i) => BigInt(i)));
  return B(
    Vt([
      t,
      a,
      r,
      n,
      s,
      c
    ])
  );
}
function Xl(e) {
  const t = typeof e == "string" ? Kt(e) : e;
  return "sierra_program" in t ? Jl(t) : Gl(t);
}
var K3 = {};
pe(K3, {
  compressProgram: () => _o,
  decompressProgram: () => bi,
  estimatedFeeToMaxFee: () => la,
  formatSignature: () => Ws,
  makeAddress: () => W3,
  randomAddress: () => vo,
  signatureToDecimalArray: () => Za,
  signatureToHexArray: () => Da
});
function _o(e) {
  const t = typeof e == "string" ? e : xt(e), a = Fp(t);
  return Ju(a);
}
function bi(e) {
  if (Array.isArray(e))
    return e;
  const t = eo(Up(Yu(e)));
  return Kt(t);
}
function vo() {
  const e = Di.randomPrivateKey();
  return Fi(e);
}
function W3(e) {
  return Re(e).toLowerCase();
}
function Ws(e) {
  if (!e)
    throw Error("formatSignature: provided signature is undefined");
  if (Array.isArray(e))
    return e.map((t) => B(t));
  try {
    const { r: t, s: a } = e;
    return [B(t), B(a)];
  } catch {
    throw new Error("Signature need to be weierstrass.SignatureType or an array for custom");
  }
}
function Za(e) {
  return xl(Ws(e));
}
function Da(e) {
  return Tl(Ws(e));
}
function la(e, t = 0.5) {
  const a = Math.round((1 + t) * 100);
  return $(e) * $(a) / 100n;
}
function it(e) {
  return "sierra_program" in (typeof e == "string" ? Kt(e) : e);
}
function Pc(e) {
  const t = { ...e };
  if (it(e.contract) && (!e.compiledClassHash && e.casm && (t.compiledClassHash = Yl(e.casm)), !t.compiledClassHash))
    throw new Error(
      "Extract compiledClassHash failed, provide (CairoAssembly).casm file or compiledClassHash"
    );
  if (t.classHash = e.classHash ?? Xl(e.contract), !t.classHash)
    throw new Error("Extract classHash failed, provide (CompiledContract).json file or classHash");
  return t;
}
var Ql = typeof window < "u" && window.fetch || // use buildin fetch in browser if available
typeof global < "u" && global.fetch || // use buildin fetch in node, react-native and service worker if available
Qp, G3 = {};
pe(G3, {
  createSierraContractClass: () => e0,
  parseContract: () => wo,
  wait: () => fs
});
function fs(e) {
  return new Promise((t) => {
    setTimeout(t, e);
  });
}
function e0(e) {
  const t = { ...e };
  return delete t.sierra_program_debug_info, t.abi = Gr(xt(e.abi)), t.sierra_program = Gr(xt(e.sierra_program)), t.sierra_program = _o(t.sierra_program), t;
}
function wo(e) {
  const t = typeof e == "string" ? Kt(e) : e;
  return it(e) ? e0(t) : {
    ...t,
    ..."program" in t && { program: _o(t.program) }
  };
}
var Y3 = class {
  parseGetBlockResponse(e) {
    return {
      timestamp: e.timestamp,
      block_hash: e.block_hash,
      block_number: e.block_number,
      new_root: e.new_root,
      parent_hash: e.parent_hash,
      status: e.status,
      transactions: e.transactions
    };
  }
  parseGetTransactionResponse(e) {
    return {
      calldata: e.calldata || [],
      contract_address: e.contract_address,
      sender_address: e.contract_address,
      max_fee: e.max_fee,
      nonce: e.nonce,
      signature: e.signature || [],
      transaction_hash: e.transaction_hash,
      version: e.version
    };
  }
  parseFeeEstimateResponse(e) {
    return {
      overall_fee: $(e[0].overall_fee),
      gas_consumed: $(e[0].gas_consumed),
      gas_price: $(e[0].gas_price)
    };
  }
  parseFeeEstimateBulkResponse(e) {
    return e.map((t) => ({
      overall_fee: $(t.overall_fee),
      gas_consumed: $(t.gas_consumed),
      gas_price: $(t.gas_price)
    }));
  }
  parseCallContractResponse(e) {
    return {
      result: e
    };
  }
  parseSimulateTransactionResponse(e) {
    return e.map((t) => ({
      ...t,
      suggestedMaxFee: la(BigInt(t.fee_estimation.overall_fee))
    }));
  }
  parseContractClassResponse(e) {
    return {
      ...e,
      abi: typeof e.abi == "string" ? JSON.parse(e.abi) : e.abi
    };
  }
};
function J3(e, t = e.constructor) {
  const { captureStackTrace: a } = Error;
  a && a(e, t);
}
function X3(e, t) {
  const { setPrototypeOf: a } = Object;
  a ? a(e, t) : e.__proto__ = t;
}
var Q3 = class extends Error {
  constructor(e) {
    super(e), Object.defineProperty(this, "name", {
      value: new.target.name,
      enumerable: !1,
      configurable: !0
    }), X3(this, new.target.prototype), J3(this);
  }
}, rr = class extends Q3 {
}, e4 = class extends rr {
  constructor(e, t) {
    super(e), this.errorCode = t;
  }
}, t4 = class extends rr {
  constructor(e, t) {
    super(e), this.errorCode = t;
  }
}, a4 = {};
pe(a4, {
  StarknetIdContract: () => r0,
  getStarknetIdContract: () => Eo,
  useDecoded: () => t0,
  useEncoded: () => a0
});
var at = "abcdefghijklmnopqrstuvwxyz0123456789-", Ma = BigInt(at.length + 1), he = "这来", Gd = BigInt(at.length), hi = BigInt(he.length), Yd = BigInt(he.length + 1);
function pi(e) {
  let t = 0;
  for (; e.endsWith(he[he.length - 1]); )
    e = e.substring(0, e.length - 1), t += 1;
  return [e, t];
}
function t0(e) {
  let t = "";
  return e.forEach((a) => {
    for (; a !== Ze; ) {
      const s = a % Ma;
      if (a /= Ma, s === BigInt(at.length)) {
        const c = a / Yd;
        if (c === Ze) {
          const i = a % Yd;
          a = c, i === Ze ? t += at[0] : t += he[Number(i) - 1];
        } else {
          const i = a % hi;
          t += he[Number(i)], a /= hi;
        }
      } else
        t += at[Number(s)];
    }
    const [r, n] = pi(t);
    n && (t = r + (n % 2 === 0 ? he[he.length - 1].repeat(n / 2 - 1) + he[0] + at[1] : he[he.length - 1].repeat((n - 1) / 2 + 1))), t += ".";
  }), t && t.concat("stark");
}
function a0(e) {
  let t = BigInt(0), a = BigInt(1);
  if (e.endsWith(he[0] + at[1])) {
    const [r, n] = pi(e.substring(0, e.length - 2));
    e = r + he[he.length - 1].repeat(2 * (n + 1));
  } else {
    const [r, n] = pi(e);
    n && (e = r + he[he.length - 1].repeat(1 + 2 * (n - 1)));
  }
  for (let r = 0; r < e.length; r += 1) {
    const n = e[r], s = at.indexOf(n), c = BigInt(at.indexOf(n));
    if (s !== -1)
      r === e.length - 1 && e[r] === at[0] ? (t += a * Gd, a *= Ma, a *= Ma) : (t += a * c, a *= Ma);
    else if (he.indexOf(n) !== -1) {
      t += a * Gd, a *= Ma;
      const i = (r === e.length - 1 ? 1 : 0) + he.indexOf(n);
      t += a * BigInt(i), a *= hi;
    }
  }
  return t;
}
var r0 = /* @__PURE__ */ ((e) => (e.MAINNET = "0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678", e.TESTNET = "0x3bab268e932d2cecd1946f100ae67ce3dff9fd234119ea2f6da57d16d29fce", e))(r0 || {});
function Eo(e) {
  switch (e) {
    case "0x534e5f4d41494e":
      return "0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678";
    case "0x534e5f474f45524c49":
      return "0x3bab268e932d2cecd1946f100ae67ce3dff9fd234119ea2f6da57d16d29fce";
    default:
      throw new Error("Starknet.id is not yet deployed on this network");
  }
}
async function ko(e, t, a) {
  const r = await e.getChainId(), n = a ?? Eo(r);
  try {
    const s = (await e.callContract({
      contractAddress: n,
      entrypoint: "address_to_domain",
      calldata: se.compile({
        address: t
      })
    })).result.map((i) => BigInt(i)).slice(1), c = t0(s);
    if (!c)
      throw Error("Starkname not found");
    return c;
  } catch (s) {
    throw s instanceof Error && s.message === "Starkname not found" ? s : Error("Could not get stark name");
  }
}
async function xo(e, t, a) {
  const r = await e.getChainId(), n = a ?? Eo(r);
  try {
    return (await e.callContract({
      contractAddress: n,
      entrypoint: "domain_to_address",
      calldata: se.compile({
        domain: [a0(t.replace(".stark", "")).toString(10)]
      })
    })).result[0];
  } catch {
    throw Error("Could not get address from stark name");
  }
}
var r4 = Object.values(ao), ue = class {
  constructor(e) {
    this.hash = null, this.number = null, this.tag = null, this.valueOf = () => this.number, this.toString = () => this.hash, this.setIdentifier(e);
  }
  setIdentifier(e) {
    typeof e == "string" && bt(e) ? this.hash = e : typeof e == "bigint" ? this.hash = B(e) : typeof e == "number" ? this.number = e : typeof e == "string" && r4.includes(e) ? this.tag = e : this.tag = "pending";
  }
  // TODO: fix any
  get queryIdentifier() {
    return this.number !== null ? `blockNumber=${this.number}` : this.hash !== null ? `blockHash=${this.hash}` : `blockNumber=${this.tag}`;
  }
  // TODO: fix any
  get identifier() {
    return this.number !== null ? { block_number: this.number } : this.hash !== null ? { block_hash: this.hash } : this.tag;
  }
  set identifier(e) {
    this.setIdentifier(e);
  }
  get sequencerIdentifier() {
    return this.hash !== null ? { blockHash: this.hash } : { blockNumber: this.number ?? this.tag };
  }
}, Lc = {
  headers: { "Content-Type": "application/json" },
  blockIdentifier: "pending",
  retries: 200
}, Jd = class {
  constructor(e) {
    this.responseParser = new Y3();
    const { nodeUrl: t, retries: a, headers: r, blockIdentifier: n, chainId: s } = e;
    this.nodeUrl = t, this.retries = a || Lc.retries, this.headers = { ...Lc.headers, ...r }, this.blockIdentifier = n || Lc.blockIdentifier, this.chainId = s, this.getChainId();
  }
  fetch(e, t) {
    const a = xt({ method: e, jsonrpc: "2.0", params: t, id: 0 });
    return Ql(this.nodeUrl, {
      method: "POST",
      body: a,
      headers: this.headers
    });
  }
  errorHandler(e) {
    if (e) {
      const { code: t, message: a } = e;
      throw new rr(`${t}: ${a}`);
    }
  }
  async fetchEndpoint(e, t) {
    try {
      const a = await this.fetch(e, t), { error: r, result: n } = await a.json();
      return this.errorHandler(r), n;
    } catch (a) {
      throw this.errorHandler(a?.response?.data), a;
    }
  }
  // Methods from Interface
  async getChainId() {
    return this.chainId ?? (this.chainId = await this.fetchEndpoint("starknet_chainId")), this.chainId;
  }
  async getBlock(e = this.blockIdentifier) {
    return this.getBlockWithTxHashes(e).then(
      this.responseParser.parseGetBlockResponse
    );
  }
  async getBlockHashAndNumber() {
    return this.fetchEndpoint("starknet_blockHashAndNumber");
  }
  async getBlockWithTxHashes(e = this.blockIdentifier) {
    const t = new ue(e).identifier;
    return this.fetchEndpoint("starknet_getBlockWithTxHashes", { block_id: t });
  }
  async getBlockWithTxs(e = this.blockIdentifier) {
    const t = new ue(e).identifier;
    return this.fetchEndpoint("starknet_getBlockWithTxs", { block_id: t });
  }
  async getClassHashAt(e, t = this.blockIdentifier) {
    const a = new ue(t).identifier;
    return this.fetchEndpoint("starknet_getClassHashAt", {
      block_id: a,
      contract_address: e
    });
  }
  async getNonceForAddress(e, t = this.blockIdentifier) {
    const a = new ue(t).identifier;
    return this.fetchEndpoint("starknet_getNonce", {
      contract_address: e,
      block_id: a
    });
  }
  async getPendingTransactions() {
    return this.fetchEndpoint("starknet_pendingTransactions");
  }
  async getProtocolVersion() {
    throw new Error("Pathfinder does not implement this rpc 0.1.0 method");
  }
  async getStateUpdate(e = this.blockIdentifier) {
    const t = new ue(e).identifier;
    return this.fetchEndpoint("starknet_getStateUpdate", { block_id: t });
  }
  async getStorageAt(e, t, a = this.blockIdentifier) {
    const r = El(t), n = new ue(a).identifier;
    return this.fetchEndpoint("starknet_getStorageAt", {
      contract_address: e,
      key: r,
      block_id: n
    });
  }
  // Methods from Interface
  async getTransaction(e) {
    return this.getTransactionByHash(e).then(this.responseParser.parseGetTransactionResponse);
  }
  async getTransactionByHash(e) {
    return this.fetchEndpoint("starknet_getTransactionByHash", { transaction_hash: e });
  }
  async getTransactionByBlockIdAndIndex(e, t) {
    const a = new ue(e).identifier;
    return this.fetchEndpoint("starknet_getTransactionByBlockIdAndIndex", { block_id: a, index: t });
  }
  async getTransactionReceipt(e) {
    return this.fetchEndpoint("starknet_getTransactionReceipt", { transaction_hash: e });
  }
  async getClassByHash(e) {
    return this.getClass(e);
  }
  async getClass(e, t = this.blockIdentifier) {
    const a = new ue(t).identifier;
    return this.fetchEndpoint("starknet_getClass", {
      class_hash: e,
      block_id: a
    }).then(this.responseParser.parseContractClassResponse);
  }
  async getClassAt(e, t = this.blockIdentifier) {
    const a = new ue(t).identifier;
    return this.fetchEndpoint("starknet_getClassAt", {
      block_id: a,
      contract_address: e
    }).then(this.responseParser.parseContractClassResponse);
  }
  async getCode(e, t) {
    throw new Error("RPC does not implement getCode function");
  }
  async getEstimateFee(e, t, a = this.blockIdentifier) {
    return this.getInvokeEstimateFee(e, t, a);
  }
  async getInvokeEstimateFee(e, t, a = this.blockIdentifier) {
    const r = new ue(a).identifier, n = this.buildTransaction(
      {
        type: "INVOKE_FUNCTION",
        ...e,
        ...t
      },
      "fee"
    );
    return this.fetchEndpoint("starknet_estimateFee", {
      request: [n],
      block_id: r
    }).then(this.responseParser.parseFeeEstimateResponse);
  }
  async getDeclareEstimateFee(e, t, a = this.blockIdentifier) {
    const r = new ue(a).identifier, n = this.buildTransaction(
      {
        type: "DECLARE",
        ...e,
        ...t
      },
      "fee"
    );
    return this.fetchEndpoint("starknet_estimateFee", {
      request: [n],
      block_id: r
    }).then(this.responseParser.parseFeeEstimateResponse);
  }
  async getDeployAccountEstimateFee(e, t, a = this.blockIdentifier) {
    const r = new ue(a).identifier, n = this.buildTransaction(
      {
        type: "DEPLOY_ACCOUNT",
        ...e,
        ...t
      },
      "fee"
    );
    return this.fetchEndpoint("starknet_estimateFee", {
      request: [n],
      block_id: r
    }).then(this.responseParser.parseFeeEstimateResponse);
  }
  async getEstimateFeeBulk(e, { blockIdentifier: t = this.blockIdentifier, skipValidate: a = !1 }) {
    a && console.warn("getEstimateFeeBulk RPC does not support skipValidate");
    const r = new ue(t).identifier;
    return this.fetchEndpoint("starknet_estimateFee", {
      request: e.map((n) => this.buildTransaction(n, "fee")),
      block_id: r
    }).then(this.responseParser.parseFeeEstimateBulkResponse);
  }
  async declareContract({ contract: e, signature: t, senderAddress: a, compiledClassHash: r }, n) {
    return it(e) ? this.fetchEndpoint("starknet_addDeclareTransaction", {
      declare_transaction: {
        type: oa.TransactionType.DECLARE,
        contract_class: {
          sierra_program: bi(e.sierra_program),
          contract_class_version: e.contract_class_version,
          entry_points_by_type: e.entry_points_by_type,
          abi: e.abi
        },
        compiled_class_hash: r || "",
        version: rl,
        max_fee: B(n.maxFee || 0),
        signature: Da(t),
        sender_address: a,
        nonce: B(n.nonce)
      }
    }) : this.fetchEndpoint("starknet_addDeclareTransaction", {
      declare_transaction: {
        type: oa.TransactionType.DECLARE,
        contract_class: {
          program: e.program,
          entry_points_by_type: e.entry_points_by_type,
          abi: e.abi
        },
        version: al,
        max_fee: B(n.maxFee || 0),
        signature: Da(t),
        sender_address: a,
        nonce: B(n.nonce)
      }
    });
  }
  async deployAccountContract({ classHash: e, constructorCalldata: t, addressSalt: a, signature: r }, n) {
    return this.fetchEndpoint("starknet_addDeployAccountTransaction", {
      deploy_account_transaction: {
        constructor_calldata: se.toHex(t || []),
        class_hash: B(e),
        contract_address_salt: B(a || 0),
        type: oa.TransactionType.DEPLOY_ACCOUNT,
        max_fee: B(n.maxFee || 0),
        version: B(n.version || 0),
        signature: Da(r),
        nonce: B(n.nonce)
      }
    });
  }
  async invokeFunction(e, t) {
    return this.fetchEndpoint("starknet_addInvokeTransaction", {
      invoke_transaction: {
        sender_address: e.contractAddress,
        calldata: se.toHex(e.calldata),
        type: oa.TransactionType.INVOKE,
        max_fee: B(t.maxFee || 0),
        version: "0x1",
        signature: Da(e.signature),
        nonce: B(t.nonce)
      }
    });
  }
  // Methods from Interface
  async callContract(e, t = this.blockIdentifier) {
    const a = new ue(t).identifier, r = await this.fetchEndpoint("starknet_call", {
      request: {
        contract_address: e.contractAddress,
        entry_point_selector: Xe(e.entrypoint),
        calldata: se.toHex(e.calldata)
      },
      block_id: a
    });
    return this.responseParser.parseCallContractResponse(r);
  }
  async traceTransaction(e) {
    return this.fetchEndpoint("starknet_traceTransaction", { transaction_hash: e });
  }
  async traceBlockTransactions(e) {
    return this.fetchEndpoint("starknet_traceBlockTransactions", { block_hash: e });
  }
  async waitForTransaction(e, t) {
    let { retries: a } = this, r = !1, n = !1, s = {};
    const c = t?.retryInterval ?? 5e3, i = t?.errorStates ?? [fi.REVERTED], o = t?.successStates ?? [
      fi.SUCCEEDED,
      di.ACCEPTED_ON_L1,
      di.ACCEPTED_ON_L2
    ];
    for (; !r; ) {
      await fs(c);
      try {
        s = await this.getTransactionReceipt(e);
        const d = ii(s.execution_status), f = ii(s.finality_status);
        if (!d || !f)
          throw new Error("waiting for transaction status");
        if (o.includes(d) || o.includes(f))
          r = !0;
        else if (i.includes(d) || i.includes(f)) {
          const u = `${d}: ${f}: ${s.revert_reason}`, l = new Error(u);
          throw l.response = s, n = !0, l;
        }
      } catch (d) {
        if (d instanceof Error && n)
          throw d;
        if (a === 0)
          throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);
      }
      a -= 1;
    }
    return await fs(c), s;
  }
  /**
   * Gets the transaction count from a block.
   *
   *
   * @param blockIdentifier
   * @returns Number of transactions
   */
  async getTransactionCount(e = this.blockIdentifier) {
    const t = new ue(e).identifier;
    return this.fetchEndpoint("starknet_getBlockTransactionCount", { block_id: t });
  }
  /**
   * Gets the latest block number
   *
   *
   * @returns Number of the latest block
   */
  async getBlockNumber() {
    return this.fetchEndpoint("starknet_blockNumber");
  }
  /**
   * Gets syncing status of the node
   *
   *
   * @returns Object with the stats data
   */
  async getSyncingStats() {
    return this.fetchEndpoint("starknet_syncing");
  }
  /**
   * Gets all the events filtered
   *
   *
   * @returns events and the pagination of the events
   */
  async getEvents(e) {
    return this.fetchEndpoint("starknet_getEvents", { filter: e });
  }
  async getSimulateTransaction(e, {
    blockIdentifier: t = this.blockIdentifier,
    skipValidate: a = !1,
    skipExecute: r = !1,
    // @deprecated
    skipFeeCharge: n = !0
    // Pathfinder currently does not support `starknet_simulateTransactions` without `SKIP_FEE_CHARGE` simulation flag being set. This will become supported in a future release
  }) {
    const s = new ue(t).identifier, c = [];
    return a && c.push(oi.SKIP_VALIDATE), (r || n) && c.push(oi.SKIP_FEE_CHARGE), this.fetchEndpoint("starknet_simulateTransactions", {
      block_id: s,
      transactions: e.map((i) => this.buildTransaction(i)),
      simulation_flags: c
    }).then(this.responseParser.parseSimulateTransactionResponse);
  }
  async getStarkName(e, t) {
    return ko(this, e, t);
  }
  async getAddressFromStarkName(e, t) {
    return xo(this, e, t);
  }
  buildTransaction(e, t) {
    const a = go(t), r = {
      signature: Da(e.signature),
      nonce: B(e.nonce),
      max_fee: B(e.maxFee || 0)
    };
    if (e.type === "INVOKE_FUNCTION")
      return {
        type: oa.TransactionType.INVOKE,
        // Diff between sequencer and rpc invoke type
        sender_address: e.contractAddress,
        calldata: se.toHex(e.calldata),
        version: B(e.version || a.v1),
        // HEX_STR_TRANSACTION_VERSION_1, // as any HOTFIX TODO: Resolve spec version
        ...r
      };
    if (e.type === "DECLARE")
      return it(e.contract) ? {
        // compiled_class_hash
        type: e.type,
        contract_class: {
          ...e.contract,
          sierra_program: bi(e.contract.sierra_program)
        },
        compiled_class_hash: e.compiledClassHash || "",
        sender_address: e.senderAddress,
        version: B(e.version || a.v2),
        // HEX_STR_TRANSACTION_VERSION_2, // as any HOTFIX TODO: Resolve spec version
        ...r
      } : {
        type: e.type,
        contract_class: e.contract,
        sender_address: e.senderAddress,
        version: B(e.version || a.v1),
        // HEX_STR_TRANSACTION_VERSION_1, // as any HOTFIX TODO: Resolve spec version
        ...r
      };
    if (e.type === "DEPLOY_ACCOUNT")
      return {
        type: e.type,
        constructor_calldata: se.toHex(e.constructorCalldata || []),
        class_hash: B(e.classHash),
        contract_address_salt: B(e.addressSalt || 0),
        version: B(e.version || a.v1),
        ...r
      };
    throw Error("RPC buildTransaction received unknown TransactionType");
  }
}, n4 = class {
}, s4 = class extends n4 {
  parseGetBlockResponse(e) {
    return {
      ...e,
      new_root: e.state_root,
      parent_hash: e.parent_block_hash,
      transactions: Object.values(e.transactions).map((t) => "transaction_hash" in t && t.transaction_hash).filter(Boolean)
    };
  }
  parseGetTransactionResponse(e) {
    if (e.status === "NOT_RECEIVED" && e.finality_status === "NOT_RECEIVED")
      throw new rr();
    return {
      ...e,
      calldata: "calldata" in e.transaction ? e.transaction.calldata : [],
      contract_class: "contract_class" in e.transaction ? e.transaction.contract_class : void 0,
      entry_point_selector: "entry_point_selector" in e.transaction ? e.transaction.entry_point_selector : void 0,
      max_fee: "max_fee" in e.transaction ? e.transaction.max_fee : void 0,
      nonce: e.transaction.nonce,
      sender_address: "sender_address" in e.transaction ? e.transaction.sender_address : void 0,
      signature: "signature" in e.transaction ? e.transaction.signature : void 0,
      transaction_hash: "transaction_hash" in e.transaction ? e.transaction.transaction_hash : void 0,
      version: "version" in e.transaction ? e.transaction.version : void 0
    };
  }
  parseGetTransactionReceiptResponse(e) {
    return {
      ...e,
      messages_sent: e.l2_to_l1_messages,
      ..."revert_error" in e && { revert_reason: e.revert_error }
    };
  }
  parseFeeEstimateResponse(e) {
    if ("overall_fee" in e) {
      let t = {};
      try {
        t = {
          gas_consumed: $(e.gas_usage),
          gas_price: $(e.gas_price)
        };
      } catch {
      }
      return {
        overall_fee: $(e.overall_fee),
        ...t
      };
    }
    return {
      overall_fee: $(e.amount)
    };
  }
  parseFeeEstimateBulkResponse(e) {
    return [].concat(e).map((t) => {
      if ("overall_fee" in t) {
        let a = {};
        try {
          a = {
            gas_consumed: $(t.gas_usage),
            gas_price: $(t.gas_price)
          };
        } catch {
        }
        return {
          overall_fee: $(t.overall_fee),
          ...a
        };
      }
      return {
        overall_fee: $(t.amount)
      };
    });
  }
  parseSimulateTransactionResponse(e) {
    const t = "overall_fee" in e.fee_estimation ? e.fee_estimation.overall_fee : e.fee_estimation.amount;
    return [
      {
        transaction_trace: e.trace,
        fee_estimation: e.fee_estimation,
        suggestedMaxFee: la(BigInt(t))
      }
    ];
  }
  parseCallContractResponse(e) {
    return {
      result: e.result
    };
  }
  parseInvokeFunctionResponse(e) {
    return {
      transaction_hash: e.transaction_hash
    };
  }
  parseDeployContractResponse(e) {
    return {
      transaction_hash: e.transaction_hash,
      contract_address: e.address
    };
  }
  parseDeclareContractResponse(e) {
    return {
      transaction_hash: e.transaction_hash,
      class_hash: e.class_hash
    };
  }
  parseGetStateUpdateResponse(e) {
    const t = Object.entries(e.state_diff.nonces).map(([r, n]) => ({
      contract_address: r,
      nonce: n
    })), a = Object.entries(e.state_diff.storage_diffs).map(
      ([r, n]) => ({ address: r, storage_entries: n })
    );
    return {
      ...e,
      state_diff: {
        ...e.state_diff,
        storage_diffs: a,
        nonces: t
      }
    };
  }
  parseContractClassResponse(e) {
    const t = it(e) ? e : wo(e);
    return {
      ...t,
      abi: typeof t.abi == "string" ? JSON.parse(t.abi) : t.abi
    };
  }
}, c4 = /^(?:\w+:)?\/\/(\S+)$/, i4 = /^localhost[:?\d]*(?:[^:?\d]\S*)?$/, o4 = /^[^\s.]+\.\S{2,}$/;
function d4(e) {
  if (!e || typeof e != "string")
    return !1;
  const t = e.match(c4);
  if (!t)
    return !1;
  const a = t[1];
  return a ? !!(i4.test(a) || o4.test(a)) : !1;
}
function Tr(e, t, a) {
  return d4(a) ? a : Ku(e, a ?? t);
}
function f4(e) {
  return e === void 0 || Object.keys(e).length === 0 || Object.keys(e).length === 1 && Object.entries(e).every(([t, a]) => t === "blockIdentifier" && a === null);
}
var Xd = {
  network: "SN_GOERLI2",
  blockIdentifier: "pending"
  /* pending */
}, Ka = class {
  constructor(e = Xd) {
    this.responseParser = new s4(), "network" in e ? (this.baseUrl = Ka.getNetworkFromName(e.network), this.feederGatewayUrl = Tr(this.baseUrl, "feeder_gateway"), this.gatewayUrl = Tr(this.baseUrl, "gateway")) : (this.baseUrl = e.baseUrl, this.feederGatewayUrl = Tr(
      this.baseUrl,
      "feeder_gateway",
      e.feederGatewayUrl
    ), this.gatewayUrl = Tr(this.baseUrl, "gateway", e.gatewayUrl)), this.chainId = e?.chainId ?? Ka.getChainIdFromBaseUrl(this.baseUrl), this.headers = e.headers, this.blockIdentifier = e?.blockIdentifier || Xd.blockIdentifier;
  }
  static getNetworkFromName(e) {
    switch (e) {
      case "SN_MAIN":
        return "https://alpha-mainnet.starknet.io";
      case "SN_GOERLI":
        return "https://alpha4.starknet.io";
      case "SN_GOERLI2":
        return "https://alpha4-2.starknet.io";
      default:
        throw new Error("Could not detect base url from NetworkName");
    }
  }
  static getChainIdFromBaseUrl(e) {
    try {
      const t = new URL(e);
      return t.host.includes("mainnet.starknet.io") ? "0x534e5f4d41494e" : t.host.includes("alpha4-2.starknet.io") ? "0x534e5f474f45524c4932" : "0x534e5f474f45524c49";
    } catch {
      return console.error(`Could not parse baseUrl: ${e}`), "0x534e5f474f45524c49";
    }
  }
  getFetchUrl(e) {
    return ["add_transaction"].includes(e) ? this.gatewayUrl : this.feederGatewayUrl;
  }
  getFetchMethod(e) {
    return [
      "add_transaction",
      "call_contract",
      "estimate_fee",
      "estimate_message_fee",
      "estimate_fee_bulk",
      "simulate_transaction"
    ].includes(e) ? "POST" : "GET";
  }
  getQueryString(e) {
    return f4(e) ? "" : `?${Object.entries(e).map(([t, a]) => t === "blockIdentifier" ? `${new ue(a).queryIdentifier}` : `${t}=${a}`).join("&")}`;
  }
  getHeaders(e) {
    return e === "POST" ? {
      "Content-Type": "application/json",
      ...this.headers
    } : this.headers;
  }
  // typesafe fetch
  async fetchEndpoint(e, ...[t, a]) {
    const r = this.getFetchUrl(e), n = this.getFetchMethod(e), s = this.getQueryString(t), c = Ku(r, e, s);
    return this.fetch(c, {
      method: n,
      body: a
    });
  }
  async fetch(e, t) {
    const a = Tr(this.baseUrl, "", e), r = t?.method ?? "GET", n = this.getHeaders(r), s = xt(t?.body);
    try {
      const c = await Ql(a, {
        method: r,
        body: s,
        headers: n
      }), i = await c.text();
      if (!c.ok) {
        let o;
        try {
          o = Kt(i);
        } catch {
          throw new t4(c.statusText, c.status);
        }
        throw new e4(o.message, o.code);
      }
      return (t?.parseAlwaysAsBigInt ? Hl : Kt)(i);
    } catch (c) {
      throw c instanceof Error && !(c instanceof rr) ? Error(`Could not ${r} from endpoint \`${a}\`: ${c.message}`) : c;
    }
  }
  async getChainId() {
    return Promise.resolve(this.chainId);
  }
  async callContract({ contractAddress: e, entrypoint: t, calldata: a = [] }, r = this.blockIdentifier) {
    return this.fetchEndpoint(
      "call_contract",
      { blockIdentifier: r },
      {
        // TODO - determine best choice once both are fully supported in devnet
        // signature: [],
        // sender_address: contractAddress,
        contract_address: e,
        entry_point_selector: Xe(t),
        calldata: se.compile(a)
      }
    ).then(this.responseParser.parseCallContractResponse);
  }
  async getBlock(e = this.blockIdentifier) {
    return this.fetchEndpoint("get_block", { blockIdentifier: e }).then(
      this.responseParser.parseGetBlockResponse
    );
  }
  async getNonceForAddress(e, t = this.blockIdentifier) {
    return this.fetchEndpoint("get_nonce", { contractAddress: e, blockIdentifier: t });
  }
  async getStorageAt(e, t, a = this.blockIdentifier) {
    const r = $(t).toString(10);
    return this.fetchEndpoint("get_storage_at", {
      blockIdentifier: a,
      contractAddress: e,
      key: r
    });
  }
  async getTransaction(e) {
    const t = B(e);
    return this.fetchEndpoint("get_transaction", { transactionHash: t }).then((a) => {
      if (Object.values(a).length === 1)
        throw new rr(a.status);
      return this.responseParser.parseGetTransactionResponse(a);
    });
  }
  async getTransactionReceipt(e) {
    const t = B(e);
    return this.fetchEndpoint("get_transaction_receipt", { transactionHash: t }).then(
      this.responseParser.parseGetTransactionReceiptResponse
    );
  }
  async getClassAt(e, t = this.blockIdentifier) {
    return this.fetchEndpoint("get_full_contract", { blockIdentifier: t, contractAddress: e }).then(
      this.responseParser.parseContractClassResponse
    );
  }
  async getClassHashAt(e, t = this.blockIdentifier) {
    return this.fetchEndpoint("get_class_hash_at", { blockIdentifier: t, contractAddress: e });
  }
  async getClassByHash(e, t = this.blockIdentifier) {
    return this.fetchEndpoint("get_class_by_hash", { classHash: e, blockIdentifier: t }).then(
      this.responseParser.parseContractClassResponse
    );
  }
  async getCompiledClassByClassHash(e, t = this.blockIdentifier) {
    return this.fetchEndpoint("get_compiled_class_by_class_hash", { classHash: e, blockIdentifier: t });
  }
  async invokeFunction(e, t) {
    return this.fetchEndpoint("add_transaction", void 0, {
      type: "INVOKE_FUNCTION",
      sender_address: e.contractAddress,
      calldata: se.compile(e.calldata ?? []),
      signature: Za(e.signature),
      nonce: B(t.nonce),
      max_fee: B(t.maxFee || 0),
      version: "0x1"
    }).then(this.responseParser.parseInvokeFunctionResponse);
  }
  async deployAccountContract({ classHash: e, constructorCalldata: t, addressSalt: a, signature: r }, n) {
    return this.fetchEndpoint("add_transaction", void 0, {
      type: "DEPLOY_ACCOUNT",
      contract_address_salt: a ?? vo(),
      constructor_calldata: se.compile(t ?? []),
      class_hash: B(e),
      max_fee: B(n.maxFee || 0),
      version: B(n.version || 0),
      nonce: B(n.nonce),
      signature: Za(r)
    }).then(this.responseParser.parseDeployContractResponse);
  }
  async declareContract({ senderAddress: e, contract: t, signature: a, compiledClassHash: r }, n) {
    return it(t) ? this.fetchEndpoint("add_transaction", void 0, {
      type: "DECLARE",
      sender_address: e,
      compiled_class_hash: r,
      contract_class: t,
      nonce: B(n.nonce),
      signature: Za(a),
      max_fee: B(n.maxFee || 0),
      version: B(ar)
    }).then(this.responseParser.parseDeclareContractResponse) : this.fetchEndpoint("add_transaction", void 0, {
      type: "DECLARE",
      contract_class: t,
      nonce: B(n.nonce),
      signature: Za(a),
      sender_address: e,
      max_fee: B(n.maxFee || 0),
      version: B(Bt)
    }).then(this.responseParser.parseDeclareContractResponse);
  }
  async getEstimateFee(e, t, a = this.blockIdentifier, r = !1) {
    return this.getInvokeEstimateFee(e, t, a, r);
  }
  async getInvokeEstimateFee(e, t, a = this.blockIdentifier, r = !1) {
    const n = this.buildTransaction(
      {
        type: "INVOKE_FUNCTION",
        ...e,
        ...t
      },
      "fee"
    );
    return this.fetchEndpoint("estimate_fee", { blockIdentifier: a, skipValidate: r }, n).then(
      this.responseParser.parseFeeEstimateResponse
    );
  }
  async getDeclareEstimateFee(e, t, a = this.blockIdentifier, r = !1) {
    const n = this.buildTransaction(
      {
        type: "DECLARE",
        ...e,
        ...t
      },
      "fee"
    );
    return this.fetchEndpoint("estimate_fee", { blockIdentifier: a, skipValidate: r }, n).then(
      this.responseParser.parseFeeEstimateResponse
    );
  }
  async getDeployAccountEstimateFee(e, t, a = this.blockIdentifier, r = !1) {
    const n = this.buildTransaction(
      {
        type: "DEPLOY_ACCOUNT",
        ...e,
        ...t
      },
      "fee"
    );
    return this.fetchEndpoint("estimate_fee", { blockIdentifier: a, skipValidate: r }, n).then(
      this.responseParser.parseFeeEstimateResponse
    );
  }
  async getEstimateFeeBulk(e, { blockIdentifier: t = this.blockIdentifier, skipValidate: a = !1 }) {
    const r = e.map((n) => this.buildTransaction(n, "fee"));
    return this.fetchEndpoint(
      "estimate_fee_bulk",
      { blockIdentifier: t, skipValidate: a },
      r
    ).then(this.responseParser.parseFeeEstimateBulkResponse);
  }
  async getCode(e, t = this.blockIdentifier) {
    return this.fetchEndpoint("get_code", { contractAddress: e, blockIdentifier: t });
  }
  async waitForTransaction(e, t) {
    let a, r = !1, n = 0;
    const s = t?.retryInterval ?? 5e3, c = t?.errorStates ?? [
      "REJECTED",
      "NOT_RECEIVED",
      "REVERTED"
      /* REVERTED */
    ], i = t?.successStates ?? [
      "SUCCEEDED",
      "ACCEPTED_ON_L1",
      "ACCEPTED_ON_L2"
      /* ACCEPTED_ON_L2 */
    ];
    for (; !r; )
      if (await fs(s), a = await this.getTransactionStatus(e), a.finality_status === "NOT_RECEIVED" && n < 3)
        n += 1;
      else if (i.includes(a.finality_status) || i.includes(a.execution_status))
        r = !0;
      else if (c.includes(a.finality_status) || c.includes(a.execution_status)) {
        let o;
        a.tx_failure_reason ? o = `${a.tx_status}: ${a.tx_failure_reason.code}
${a.tx_failure_reason.error_message}` : a.tx_revert_reason ? o = `${a.tx_status}: ${a.tx_revert_reason}` : o = a.tx_status;
        const d = new Error(o);
        throw d.response = a, d;
      }
    return await this.getTransactionReceipt(e);
  }
  /**
   * Gets the status of a transaction.
   * @param txHash BigNumberish
   * @returns GetTransactionStatusResponse - the transaction status object
   */
  async getTransactionStatus(e) {
    const t = B(e);
    return this.fetchEndpoint("get_transaction_status", { transactionHash: t });
  }
  /**
   * Gets the smart contract address on the goerli testnet.
   * @returns GetContractAddressesResponse - starknet smart contract addresses
   */
  async getContractAddresses() {
    return this.fetchEndpoint("get_contract_addresses");
  }
  /**
   * Gets the transaction trace from a tx id.
   * @param txHash BigNumberish
   * @returns TransactionTraceResponse - the transaction trace
   */
  async getTransactionTrace(e) {
    const t = B(e);
    return this.fetchEndpoint("get_transaction_trace", { transactionHash: t });
  }
  async estimateMessageFee({ from_address: e, to_address: t, entry_point_selector: a, payload: r }, n = this.blockIdentifier) {
    const s = {
      from_address: Sl(e),
      to_address: no(t),
      entry_point_selector: co(a),
      payload: Cl(r)
    };
    return this.fetchEndpoint("estimate_message_fee", { blockIdentifier: n }, s);
  }
  /**
   * Simulate transaction using Sequencer provider
   * WARNING!: Sequencer will process only first element from invocations array
   *
   * @param invocations Array of invocations, but only first invocation will be processed
   * @param blockIdentifier block identifier, default 'latest'
   * @param skipValidate Skip Account __validate__ method
   * @returns
   */
  async getSimulateTransaction(e, {
    blockIdentifier: t = this.blockIdentifier,
    skipValidate: a = !1,
    skipExecute: r = !1
  }) {
    e.length > 1 && console.warn("Sequencer simulate process only first element from invocations list"), r && console.warn("Sequencer can't skip account __execute__");
    const n = this.buildTransaction(e[0]);
    return this.fetchEndpoint(
      "simulate_transaction",
      {
        blockIdentifier: t,
        skipValidate: a ?? !1
      },
      n
    ).then(this.responseParser.parseSimulateTransactionResponse);
  }
  async getStateUpdate(e = this.blockIdentifier) {
    const t = new ue(e).sequencerIdentifier;
    return this.fetchEndpoint("get_state_update", { ...t }).then(
      this.responseParser.parseGetStateUpdateResponse
    );
  }
  // consider adding an optional trace retrieval parameter to the getBlock method
  async getBlockTraces(e = this.blockIdentifier) {
    const t = new ue(e).sequencerIdentifier;
    return this.fetchEndpoint("get_block_traces", { ...t });
  }
  async getStarkName(e, t) {
    return ko(this, e, t);
  }
  async getAddressFromStarkName(e, t) {
    return xo(this, e, t);
  }
  /**
   * Build Single AccountTransaction from Single AccountInvocation
   * @param invocation AccountInvocationItem
   * @param versionType 'fee' | 'transaction' - used to determine default versions
   * @returns AccountTransactionItem
   */
  buildTransaction(e, t) {
    const a = go(t), r = {
      signature: Za(e.signature),
      nonce: B(e.nonce)
    };
    if (e.type === "INVOKE_FUNCTION")
      return {
        type: e.type,
        sender_address: e.contractAddress,
        calldata: se.compile(e.calldata ?? []),
        version: B(e.version || a.v1),
        ...r
      };
    if (e.type === "DECLARE")
      return it(e.contract) ? {
        type: e.type,
        contract_class: e.contract,
        compiled_class_hash: e.compiledClassHash,
        sender_address: e.senderAddress,
        version: B(e.version || a.v2),
        // fee on getDeclareEstimateFee use t.v. instead of feet.v.
        ...r
      } : {
        type: e.type,
        contract_class: e.contract,
        sender_address: e.senderAddress,
        version: B(e.version || a.v1),
        // fee from getDeclareEstimateFee use t.v. instead of feet.v.
        ...r
      };
    if (e.type === "DEPLOY_ACCOUNT")
      return {
        type: e.type,
        constructor_calldata: se.compile(e.constructorCalldata || []),
        class_hash: B(e.classHash),
        contract_address_salt: B(e.addressSalt || 0),
        version: B(e.version || a.v1),
        ...r
      };
    throw Error("Sequencer buildTransaction received unknown TransactionType");
  }
}, To = class {
  constructor(e) {
    e instanceof To ? this.provider = e.provider : e instanceof Jd || e instanceof Ka ? this.provider = e : e && "rpc" in e ? this.provider = new Jd(e.rpc) : e && "sequencer" in e ? this.provider = new Ka(e.sequencer) : this.provider = new Ka();
  }
  async getChainId() {
    return this.provider.getChainId();
  }
  async getBlock(e) {
    return this.provider.getBlock(e);
  }
  async getClassAt(e, t) {
    return this.provider.getClassAt(e, t);
  }
  async getClassHashAt(e, t) {
    return this.provider.getClassHashAt(e, t);
  }
  getClassByHash(e) {
    return this.provider.getClassByHash(e);
  }
  async getEstimateFee(e, t, a) {
    return this.provider.getEstimateFee(e, t, a);
  }
  async getInvokeEstimateFee(e, t, a, r) {
    return this.provider.getInvokeEstimateFee(
      e,
      t,
      a,
      r
    );
  }
  async getEstimateFeeBulk(e, t) {
    return this.provider.getEstimateFeeBulk(e, t);
  }
  async getNonceForAddress(e, t) {
    return this.provider.getNonceForAddress(e, t);
  }
  async getStorageAt(e, t, a) {
    return this.provider.getStorageAt(e, t, a);
  }
  async getTransaction(e) {
    return this.provider.getTransaction(e);
  }
  async getTransactionReceipt(e) {
    return this.provider.getTransactionReceipt(e);
  }
  async callContract(e, t) {
    return this.provider.callContract(e, t);
  }
  async invokeFunction(e, t) {
    return this.provider.invokeFunction(e, t);
  }
  async deployAccountContract(e, t) {
    return this.provider.deployAccountContract(e, t);
  }
  async declareContract(e, t) {
    return this.provider.declareContract(e, t);
  }
  async getDeclareEstimateFee(e, t, a, r) {
    return this.provider.getDeclareEstimateFee(e, t, a, r);
  }
  getDeployAccountEstimateFee(e, t, a, r) {
    return this.provider.getDeployAccountEstimateFee(
      e,
      t,
      a,
      r
    );
  }
  async getCode(e, t) {
    return this.provider.getCode(e, t);
  }
  async waitForTransaction(e, t) {
    return this.provider.waitForTransaction(e, t);
  }
  async getSimulateTransaction(e, t) {
    return this.provider.getSimulateTransaction(e, t);
  }
  async getStateUpdate(e) {
    return this.provider.getStateUpdate(e);
  }
  async getStarkName(e, t) {
    return ko(this, e, t);
  }
  async getAddressFromStarkName(e, t) {
    return xo(this, e, t);
  }
}, u4 = {};
pe(u4, {
  fromCallsToExecuteCalldata: () => So,
  fromCallsToExecuteCalldataWithNonce: () => l4,
  fromCallsToExecuteCalldata_cairo1: () => s0,
  getExecuteCalldata: () => us,
  transformCallsToMulticallArrays: () => n0,
  transformCallsToMulticallArrays_cairo1: () => b4
});
var n0 = (e) => {
  const t = [], a = [];
  return e.forEach((r) => {
    const n = se.compile(r.calldata || []);
    t.push({
      to: $(r.contractAddress).toString(10),
      selector: $(Xe(r.entrypoint)).toString(10),
      data_offset: a.length.toString(),
      data_len: n.length.toString()
    }), a.push(...n);
  }), {
    callArray: t,
    calldata: se.compile({ calldata: a })
  };
}, So = (e) => {
  const { callArray: t, calldata: a } = n0(e);
  return [...se.compile({ callArray: t }), ...a];
}, l4 = (e, t) => [...So(e), $(t).toString()], b4 = (e) => e.map((t) => ({
  to: $(t.contractAddress).toString(10),
  selector: $(Xe(t.entrypoint)).toString(10),
  calldata: se.compile(t.calldata || [])
})), s0 = (e) => {
  const t = e.map((a) => ({
    contractAddress: a.contractAddress,
    entrypoint: a.entrypoint,
    calldata: a.calldata
  }));
  return se.compile({ orderCalls: t });
}, us = (e, t = "0") => t === "1" ? s0(e) : So(e), h4 = {};
pe(h4, {
  encodeData: () => u0,
  encodeType: () => d0,
  encodeValue: () => Ao,
  getDependencies: () => Co,
  getMessageHash: () => Oo,
  getStructHash: () => Yr,
  getTypeHash: () => f0,
  isMerkleTreeType: () => o0,
  prepareSelector: () => i0
});
var p4 = {};
pe(p4, {
  MerkleTree: () => Wa,
  proofMerklePath: () => c0
});
var Wa = class {
  constructor(e) {
    this.branches = [], this.leaves = e, this.root = this.build(e);
  }
  build(e) {
    if (e.length === 1)
      return e[0];
    e.length !== this.leaves.length && this.branches.push(e);
    const t = [];
    for (let a = 0; a < e.length; a += 2)
      a + 1 === e.length ? t.push(Wa.hash(e[a], "0x0")) : t.push(Wa.hash(e[a], e[a + 1]));
    return this.build(t);
  }
  static hash(e, t) {
    const [a, r] = [$(e), $(t)].sort((n, s) => n >= s ? 1 : -1);
    return fr(a, r);
  }
  getProof(e, t = this.leaves, a = []) {
    const r = t.indexOf(e);
    if (r === -1)
      throw new Error("leaf not found");
    if (t.length === 1)
      return a;
    const n = r % 2 === 0, s = (n ? t[r + 1] : t[r - 1]) ?? "0x0", c = [...a, s], i = this.leaves.length === t.length ? -1 : this.branches.findIndex((d) => d.length === t.length), o = this.branches[i + 1] ?? [this.root];
    return this.getProof(
      Wa.hash(n ? e : s, n ? s : e),
      o,
      c
    );
  }
};
function c0(e, t, a) {
  if (a.length === 0)
    return e === t;
  const [r, ...n] = a;
  return c0(e, Wa.hash(t, r), n);
}
function m4(e) {
  try {
    return B(e);
  } catch {
    if (typeof e == "string")
      return B(ta(e));
    throw new Error(`Invalid BigNumberish: ${e}`);
  }
}
var y4 = (e) => {
  const t = e;
  return !!(t.types && t.primaryType && t.message);
};
function i0(e) {
  return bt(e) ? e : Xe(e);
}
function o0(e) {
  return e.type === "merkletree";
}
var Co = (e, t, a = []) => (t[t.length - 1] === "*" && (t = t.slice(0, -1)), a.includes(t) || !e[t] ? a : [
  t,
  ...e[t].reduce(
    (r, n) => [
      ...r,
      ...Co(e, n.type, r).filter(
        (s) => !r.includes(s)
      )
    ],
    []
  )
]);
function g4(e, t) {
  if (t.parent && t.key) {
    const a = e[t.parent].find((r) => r.name === t.key);
    if (!o0(a))
      throw new Error(`${t.key} is not a merkle tree`);
    if (a.contains.endsWith("*"))
      throw new Error(`Merkle tree contain property must not be an array but was given ${t.key}`);
    return a.contains;
  }
  return "raw";
}
var d0 = (e, t) => {
  const [a, ...r] = Co(e, t);
  return (a ? [a, ...r.sort()] : []).map((n) => `${n}(${e[n].map((s) => `${s.name}:${s.type}`)})`).join("");
}, f0 = (e, t) => Xe(d0(e, t)), Ao = (e, t, a, r = {}) => {
  if (e[t])
    return [t, Yr(e, t, a)];
  if (Object.keys(e).map((n) => `${n}*`).includes(t)) {
    const n = a.map((s) => Yr(e, t.slice(0, -1), s));
    return [t, Te(n)];
  }
  if (t === "merkletree") {
    const n = g4(e, r), s = a.map((i) => Ao(e, n, i)[1]), { root: c } = new Wa(s);
    return ["felt", c];
  }
  return t === "felt*" ? ["felt*", Te(a)] : t === "selector" ? ["felt", i0(a)] : [t, m4(a)];
}, u0 = (e, t, a) => {
  const [r, n] = e[t].reduce(
    ([s, c], i) => {
      if (a[i.name] === void 0 || a[i.name] === null)
        throw new Error(`Cannot encode data: missing data for '${i.name}'`);
      const o = a[i.name], [d, f] = Ao(e, i.type, o, {
        parent: t,
        key: i.name
      });
      return [
        [...s, d],
        [...c, f]
      ];
    },
    [["felt"], [f0(e, t)]]
  );
  return [r, n];
}, Yr = (e, t, a) => Te(u0(e, t, a)[1]), Oo = (e, t) => {
  if (!y4(e))
    throw new Error("Typed data does not match JSON schema");
  const a = [
    ta("StarkNet Message"),
    Yr(e.types, "StarkNetDomain", e.domain),
    t,
    Yr(e.types, e.primaryType, e.message)
  ];
  return Te(a);
}, _4 = class {
  constructor(e = Di.randomPrivateKey()) {
    this.pk = e instanceof Uint8Array ? Xu(e) : B(e);
  }
  async getPubKey() {
    return Fi(this.pk);
  }
  async signMessage(e, t) {
    const a = Oo(e, t);
    return Sr(a, this.pk);
  }
  async signTransaction(e, t, a) {
    if (a && a.length !== e.length)
      throw new Error("ABI must be provided for each transaction or no transaction");
    const r = us(e, t.cairoVersion), n = Kl(
      t.walletAddress,
      t.version,
      r,
      t.maxFee,
      t.chainId,
      t.nonce
    );
    return Sr(n, this.pk);
  }
  async signDeployAccountTransaction({
    classHash: e,
    contractAddress: t,
    constructorCalldata: a,
    addressSalt: r,
    maxFee: n,
    version: s,
    chainId: c,
    nonce: i
  }) {
    const o = ql(
      t,
      e,
      se.compile(a),
      r,
      s,
      n,
      c,
      i
    );
    return Sr(o, this.pk);
  }
  async signDeclareTransaction({
    classHash: e,
    senderAddress: t,
    chainId: a,
    maxFee: r,
    version: n,
    nonce: s,
    compiledClassHash: c
  }) {
    const i = Vl(
      e,
      t,
      n,
      r,
      a,
      s,
      c
    );
    return Sr(i, this.pk);
  }
};
function v4(e) {
  if (!e.events)
    throw new Error("UDC emited event is empty");
  const t = e.events.find(
    (a) => ui(a.from_address) === ui(ia.ADDRESS)
  ) || {
    data: []
  };
  return {
    transaction_hash: e.transaction_hash,
    contract_address: t.data[0],
    address: t.data[0],
    deployer: t.data[1],
    unique: t.data[2],
    classHash: t.data[3],
    calldata_len: t.data[4],
    calldata: t.data.slice(5, 5 + parseInt(t.data[4], 16)),
    salt: t.data[t.data.length - 1]
  };
}
var w4 = class extends To {
  constructor(e, t, a, r = "0") {
    super(e), this.deploySelf = this.deployAccount, this.address = t.toLowerCase(), this.signer = typeof a == "string" || a instanceof Uint8Array ? new _4(a) : a, this.cairoVersion = r;
  }
  async getNonce(e) {
    return super.getNonceForAddress(this.address, e);
  }
  async getNonceSafe(e) {
    try {
      return $(e ?? await this.getNonce());
    } catch {
      return 0n;
    }
  }
  async estimateFee(e, t) {
    return this.estimateInvokeFee(e, t);
  }
  async estimateInvokeFee(e, { nonce: t, blockIdentifier: a, skipValidate: r } = {}) {
    const n = Array.isArray(e) ? e : [e], s = $(t ?? await this.getNonce()), c = $(za), i = await this.getChainId(), o = {
      walletAddress: this.address,
      nonce: s,
      maxFee: Ze,
      version: c,
      chainId: i,
      cairoVersion: this.cairoVersion
    }, d = await this.buildInvocation(n, o), f = await super.getInvokeEstimateFee(
      { ...d },
      { version: c, nonce: s },
      a,
      r
    ), u = la(f.overall_fee);
    return {
      ...f,
      suggestedMaxFee: u
    };
  }
  async estimateDeclareFee({ contract: e, classHash: t, casm: a, compiledClassHash: r }, { blockIdentifier: n, nonce: s, skipValidate: c } = {}) {
    const i = $(s ?? await this.getNonce()), o = it(e) ? ds : za, d = await this.getChainId(), f = await this.buildDeclarePayload(
      { classHash: t, contract: e, casm: a, compiledClassHash: r },
      {
        nonce: i,
        chainId: d,
        version: o,
        walletAddress: this.address,
        maxFee: Ze,
        cairoVersion: this.cairoVersion
      }
    ), u = await super.getDeclareEstimateFee(
      f,
      { version: o, nonce: i },
      n,
      c
    ), l = la(u.overall_fee);
    return {
      ...u,
      suggestedMaxFee: l
    };
  }
  async estimateAccountDeployFee({
    classHash: e,
    addressSalt: t = 0,
    constructorCalldata: a = [],
    contractAddress: r
  }, { blockIdentifier: n, skipValidate: s } = {}) {
    const c = $(za), i = Ze, o = await this.getChainId(), d = await this.buildAccountDeployPayload(
      { classHash: e, addressSalt: t, constructorCalldata: a, contractAddress: r },
      {
        nonce: i,
        chainId: o,
        version: c,
        walletAddress: this.address,
        maxFee: Ze,
        cairoVersion: this.cairoVersion
      }
    ), f = await super.getDeployAccountEstimateFee(
      { ...d },
      { version: c, nonce: i },
      n,
      s
    ), u = la(f.overall_fee);
    return {
      ...f,
      suggestedMaxFee: u
    };
  }
  async estimateDeployFee(e, t) {
    const a = this.buildUDCContractPayload(e);
    return this.estimateInvokeFee(a, t);
  }
  async estimateFeeBulk(e, { nonce: t, blockIdentifier: a, skipValidate: r } = {}) {
    const n = await this.accountInvocationsFactory(e, {
      versions: [za, ds],
      nonce: t,
      blockIdentifier: a
    }), s = await super.getEstimateFeeBulk(n, {
      blockIdentifier: a,
      skipValidate: r
    });
    return [].concat(s).map((c) => {
      const i = la(c.overall_fee);
      return {
        ...c,
        suggestedMaxFee: i
      };
    });
  }
  async buildInvocation(e, t) {
    const a = us(e, this.cairoVersion), r = await this.signer.signTransaction(e, t);
    return {
      contractAddress: this.address,
      calldata: a,
      signature: r
    };
  }
  async execute(e, t = void 0, a = {}) {
    const r = Array.isArray(e) ? e : [e], n = $(a.nonce ?? await this.getNonce()), s = a.maxFee ?? await this.getSuggestedMaxFee(
      { type: "INVOKE_FUNCTION", payload: e },
      a
    ), c = $(Bt), i = await this.getChainId(), o = {
      walletAddress: this.address,
      nonce: n,
      maxFee: s,
      version: c,
      chainId: i,
      cairoVersion: this.cairoVersion
    }, d = await this.signer.signTransaction(r, o, t), f = us(r, this.cairoVersion);
    return this.invokeFunction(
      { contractAddress: this.address, calldata: f, signature: d },
      {
        nonce: n,
        maxFee: s,
        version: c
      }
    );
  }
  /**
   * First check if contract is already declared, if not declare it
   * If contract already declared returned transaction_hash is ''.
   * Method will pass even if contract is already declared
   * @param payload DeclareContractPayload
   * @param transactionsDetail (optional) InvocationsDetails = \{\}
   * @returns DeclareContractResponse
   */
  async declareIfNot(e, t = {}) {
    const a = Pc(e);
    try {
      await this.getClassByHash(a.classHash);
    } catch {
      return this.declare(e, t);
    }
    return {
      transaction_hash: "",
      class_hash: a.classHash
    };
  }
  async declare(e, t = {}) {
    const a = Pc(e), r = {};
    r.nonce = $(t.nonce ?? await this.getNonce()), r.maxFee = t.maxFee ?? await this.getSuggestedMaxFee(
      {
        type: "DECLARE",
        payload: a
      },
      t
    ), r.version = it(e.contract) ? ar : Bt, r.chainId = await this.getChainId();
    const n = await this.buildDeclarePayload(a, {
      ...r,
      walletAddress: this.address,
      cairoVersion: this.cairoVersion
    });
    return this.declareContract(n, r);
  }
  async deploy(e, t) {
    const a = [].concat(e).map((s) => {
      const {
        classHash: c,
        salt: i,
        unique: o = !0,
        constructorCalldata: d = []
      } = s, f = se.compile(d), u = i ?? vo();
      return {
        call: {
          contractAddress: ia.ADDRESS,
          entrypoint: ia.ENTRYPOINT,
          calldata: [
            c,
            u,
            li(o),
            f.length,
            ...f
          ]
        },
        address: Yn(
          o ? fr(this.address, u) : u,
          c,
          f,
          o ? ia.ADDRESS : 0
        )
      };
    }), r = a.map((s) => s.call), n = a.map((s) => s.address);
    return {
      ...await this.execute(r, void 0, t),
      contract_address: n
    };
  }
  async deployContract(e, t) {
    const a = await this.deploy(e, t), r = await this.waitForTransaction(a.transaction_hash);
    return v4(r);
  }
  async declareAndDeploy(e, t) {
    const { constructorCalldata: a, salt: r, unique: n } = e;
    let s = await this.declareIfNot(e, t);
    if (s.transaction_hash !== "") {
      const i = await this.waitForTransaction(s.transaction_hash);
      s = { ...s, ...i };
    }
    const c = await this.deployContract(
      { classHash: s.class_hash, salt: r, unique: n, constructorCalldata: a },
      t
    );
    return { declare: { ...s }, deploy: c };
  }
  async deployAccount({
    classHash: e,
    constructorCalldata: t = [],
    addressSalt: a = 0,
    contractAddress: r
  }, n = {}) {
    const s = $(Bt), c = Ze, i = await this.getChainId(), o = se.compile(t), d = r ?? Yn(a, e, o, 0), f = n.maxFee ?? await this.getSuggestedMaxFee(
      {
        type: "DEPLOY_ACCOUNT",
        payload: {
          classHash: e,
          constructorCalldata: o,
          addressSalt: a,
          contractAddress: d
        }
      },
      n
    ), u = await this.signer.signDeployAccountTransaction({
      classHash: e,
      constructorCalldata: o,
      contractAddress: d,
      addressSalt: a,
      chainId: i,
      maxFee: f,
      version: s,
      nonce: c
    });
    return this.deployAccountContract(
      { classHash: e, addressSalt: a, constructorCalldata: t, signature: u },
      {
        nonce: c,
        maxFee: f,
        version: s
      }
    );
  }
  async signMessage(e) {
    return this.signer.signMessage(e, this.address);
  }
  async hashMessage(e) {
    return Oo(e, this.address);
  }
  async verifyMessageHash(e, t) {
    try {
      return await this.callContract({
        contractAddress: this.address,
        entrypoint: "isValidSignature",
        calldata: se.compile({
          hash: $(e).toString(),
          signature: Ws(t)
        })
      }), !0;
    } catch {
      return !1;
    }
  }
  async verifyMessage(e, t) {
    const a = await this.hashMessage(e);
    return this.verifyMessageHash(a, t);
  }
  async getSuggestedMaxFee({ type: e, payload: t }, a) {
    let r;
    switch (e) {
      case "INVOKE_FUNCTION":
        r = await this.estimateInvokeFee(t, a);
        break;
      case "DECLARE":
        r = await this.estimateDeclareFee(t, a);
        break;
      case "DEPLOY_ACCOUNT":
        r = await this.estimateAccountDeployFee(t, a);
        break;
      case "DEPLOY":
        r = await this.estimateDeployFee(t, a);
        break;
      default:
        r = { suggestedMaxFee: Ze, overall_fee: Ze };
        break;
    }
    return r.suggestedMaxFee;
  }
  /**
   * will be renamed to buildDeclareContractTransaction
   */
  async buildDeclarePayload(e, { nonce: t, chainId: a, version: r, walletAddress: n, maxFee: s }) {
    const { classHash: c, contract: i, compiledClassHash: o } = Pc(e), d = wo(i), f = await this.signer.signDeclareTransaction({
      classHash: c,
      compiledClassHash: o,
      senderAddress: n,
      chainId: a,
      maxFee: s,
      version: r,
      nonce: t
    });
    return {
      senderAddress: n,
      signature: f,
      contract: d,
      compiledClassHash: o
    };
  }
  async buildAccountDeployPayload({
    classHash: e,
    addressSalt: t = 0,
    constructorCalldata: a = [],
    contractAddress: r
  }, { nonce: n, chainId: s, version: c, maxFee: i }) {
    const o = se.compile(a), d = r ?? Yn(t, e, o, 0), f = await this.signer.signDeployAccountTransaction({
      classHash: e,
      contractAddress: d,
      chainId: s,
      maxFee: i,
      version: c,
      nonce: n,
      addressSalt: t,
      constructorCalldata: o
    });
    return {
      classHash: e,
      addressSalt: t,
      constructorCalldata: o,
      signature: f
    };
  }
  buildUDCContractPayload(e) {
    return [].concat(e).map((t) => {
      const {
        classHash: a,
        salt: r = "0",
        unique: n = !0,
        constructorCalldata: s = []
      } = t, c = se.compile(s);
      return {
        contractAddress: ia.ADDRESS,
        entrypoint: ia.ENTRYPOINT,
        calldata: [
          a,
          r,
          li(n),
          c.length,
          ...c
        ]
      };
    });
  }
  async simulateTransaction(e, { nonce: t, blockIdentifier: a, skipValidate: r, skipExecute: n } = {}) {
    const s = await this.accountInvocationsFactory(e, {
      versions: [Bt, ar],
      nonce: t,
      blockIdentifier: a
    });
    return super.getSimulateTransaction(s, {
      blockIdentifier: a,
      skipValidate: r,
      skipExecute: n
    });
  }
  async accountInvocationsFactory(e, { versions: t, nonce: a, blockIdentifier: r }) {
    const n = t[0], s = await this.getNonceSafe(a), c = await this.getChainId();
    return Promise.all(
      [].concat(e).map(async (i, o) => {
        const d = {
          walletAddress: this.address,
          nonce: $(Number(s) + o),
          maxFee: Ze,
          version: n,
          chainId: c,
          cairoVersion: this.cairoVersion
        }, f = "payload" in i ? i.payload : i, u = {
          type: i.type,
          version: n,
          nonce: $(Number(s) + o),
          blockIdentifier: r
        };
        if (i.type === "INVOKE_FUNCTION") {
          const l = await this.buildInvocation(
            [].concat(f),
            d
          );
          return {
            ...u,
            ...l
          };
        }
        if (i.type === "DECLARE") {
          d.version = it(f.contract) ? $(t[1]) : $(t[0]);
          const l = await this.buildDeclarePayload(f, d);
          return {
            ...u,
            ...l,
            version: d.version
          };
        }
        if (i.type === "DEPLOY_ACCOUNT") {
          const l = await this.buildAccountDeployPayload(f, d);
          return {
            ...u,
            ...l
          };
        }
        if (i.type === "DEPLOY") {
          const l = this.buildUDCContractPayload(f), b = await this.buildInvocation(l, d);
          return {
            ...u,
            ...b,
            type: "INVOKE_FUNCTION"
            /* INVOKE */
          };
        }
        throw Error(`accountInvocationsFactory: unsupported transaction type: ${i}`);
      })
    );
  }
  async getStarkName(e = this.address, t) {
    return super.getStarkName(e, t);
  }
};
new To();
class Qd {
  async getPubKey() {
    throw new Error("Method not implemented");
  }
  async signMessage() {
    throw new Error("Method not implemented");
  }
  async signTransaction() {
    throw new Error("Method not implemented");
  }
  async signDeclareTransaction() {
    throw new Error("Method not implemented");
  }
  async signDeployAccountTransaction() {
    throw new Error("Method not implemented");
  }
}
class E4 extends w4 {
  constructor(t, a, r) {
    super(t, a, new Qd()), cc(this, "signer", new Qd()), cc(this, "execute", async (n, s, c) => {
      try {
        return {
          transaction_hash: await this.proxyLink.execute.mutate([
            n,
            s,
            c
          ])
        };
      } catch (i) {
        throw new Error(i);
      }
    }), cc(this, "signMessage", async (n) => {
      try {
        return await this.proxyLink.signMessage.mutate([n]);
      } catch (s) {
        throw new Error(s);
      }
    }), this.address = a, this.proxyLink = r;
  }
}
const Kn = [], k4 = (e, t, a) => {
  const r = {
    ...e,
    isConnected: !1,
    provider: t,
    getLoginStatus: () => a.getLoginStatus.mutate(),
    async request(n) {
      switch (n.type) {
        case "wallet_addStarknetChain":
          return await a.addStarknetChain.mutate();
        case "wallet_switchStarknetChain":
          return await a.switchStarknetChain.mutate();
        case "wallet_watchAsset":
          return await a.watchAsset.mutate();
        default:
          throw new Error("not implemented");
      }
    },
    async enable(n) {
      if (n?.starknetVersion !== "v4")
        throw Error("not implemented");
      try {
        const s = await a.enable.mutate();
        return await x4(
          r,
          t,
          a,
          s
        ), [s];
      } catch (s) {
        throw new Error(s);
      }
    },
    async isPreauthorized() {
      const { isLoggedIn: n, isPreauthorized: s } = await a.getLoginStatus.mutate();
      return !!(n && s);
    },
    on: (n, s) => {
      if (n === "accountsChanged")
        Kn.push({
          type: n,
          handler: s
        });
      else if (n === "networkChanged")
        Kn.push({
          type: n,
          handler: s
        });
      else
        throw new Error(`Unknwown event: ${n}`);
    },
    off: (n, s) => {
      if (n !== "accountsChanged" && n !== "networkChanged")
        throw new Error(`Unknwown event: ${n}`);
      const c = Kn.findIndex(
        (i) => i.type === n && i.handler === s
      );
      c >= 0 && Kn.splice(c, 1);
    }
  };
  return r;
};
async function x4(e, t, a, r) {
  if (e.isConnected)
    return e;
  const n = {
    isConnected: !0,
    chainId: await t.getChainId(),
    selectedAddress: r,
    account: new E4(t, r, a),
    provider: t
  };
  return Object.assign(e, n);
}
var ee;
(function(e) {
  e.assertEqual = (n) => n;
  function t(n) {
  }
  e.assertIs = t;
  function a(n) {
    throw new Error();
  }
  e.assertNever = a, e.arrayToEnum = (n) => {
    const s = {};
    for (const c of n)
      s[c] = c;
    return s;
  }, e.getValidEnumValues = (n) => {
    const s = e.objectKeys(n).filter((i) => typeof n[n[i]] != "number"), c = {};
    for (const i of s)
      c[i] = n[i];
    return e.objectValues(c);
  }, e.objectValues = (n) => e.objectKeys(n).map(function(s) {
    return n[s];
  }), e.objectKeys = typeof Object.keys == "function" ? (n) => Object.keys(n) : (n) => {
    const s = [];
    for (const c in n)
      Object.prototype.hasOwnProperty.call(n, c) && s.push(c);
    return s;
  }, e.find = (n, s) => {
    for (const c of n)
      if (s(c))
        return c;
  }, e.isInteger = typeof Number.isInteger == "function" ? (n) => Number.isInteger(n) : (n) => typeof n == "number" && isFinite(n) && Math.floor(n) === n;
  function r(n, s = " | ") {
    return n.map((c) => typeof c == "string" ? `'${c}'` : c).join(s);
  }
  e.joinValues = r, e.jsonStringifyReplacer = (n, s) => typeof s == "bigint" ? s.toString() : s;
})(ee || (ee = {}));
var mi;
(function(e) {
  e.mergeShapes = (t, a) => ({
    ...t,
    ...a
    // second overwrites first
  });
})(mi || (mi = {}));
const N = ee.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), Lt = (e) => {
  switch (typeof e) {
    case "undefined":
      return N.undefined;
    case "string":
      return N.string;
    case "number":
      return isNaN(e) ? N.nan : N.number;
    case "boolean":
      return N.boolean;
    case "function":
      return N.function;
    case "bigint":
      return N.bigint;
    case "symbol":
      return N.symbol;
    case "object":
      return Array.isArray(e) ? N.array : e === null ? N.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? N.promise : typeof Map < "u" && e instanceof Map ? N.map : typeof Set < "u" && e instanceof Set ? N.set : typeof Date < "u" && e instanceof Date ? N.date : N.object;
    default:
      return N.unknown;
  }
}, k = ee.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), T4 = (e) => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:");
class Ve extends Error {
  constructor(t) {
    super(), this.issues = [], this.addIssue = (r) => {
      this.issues = [...this.issues, r];
    }, this.addIssues = (r = []) => {
      this.issues = [...this.issues, ...r];
    };
    const a = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, a) : this.__proto__ = a, this.name = "ZodError", this.issues = t;
  }
  get errors() {
    return this.issues;
  }
  format(t) {
    const a = t || function(s) {
      return s.message;
    }, r = { _errors: [] }, n = (s) => {
      for (const c of s.issues)
        if (c.code === "invalid_union")
          c.unionErrors.map(n);
        else if (c.code === "invalid_return_type")
          n(c.returnTypeError);
        else if (c.code === "invalid_arguments")
          n(c.argumentsError);
        else if (c.path.length === 0)
          r._errors.push(a(c));
        else {
          let i = r, o = 0;
          for (; o < c.path.length; ) {
            const d = c.path[o];
            o === c.path.length - 1 ? (i[d] = i[d] || { _errors: [] }, i[d]._errors.push(a(c))) : i[d] = i[d] || { _errors: [] }, i = i[d], o++;
          }
        }
    };
    return n(this), r;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, ee.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (a) => a.message) {
    const a = {}, r = [];
    for (const n of this.issues)
      n.path.length > 0 ? (a[n.path[0]] = a[n.path[0]] || [], a[n.path[0]].push(t(n))) : r.push(t(n));
    return { formErrors: r, fieldErrors: a };
  }
  get formErrors() {
    return this.flatten();
  }
}
Ve.create = (e) => new Ve(e);
const Jr = (e, t) => {
  let a;
  switch (e.code) {
    case k.invalid_type:
      e.received === N.undefined ? a = "Required" : a = `Expected ${e.expected}, received ${e.received}`;
      break;
    case k.invalid_literal:
      a = `Invalid literal value, expected ${JSON.stringify(e.expected, ee.jsonStringifyReplacer)}`;
      break;
    case k.unrecognized_keys:
      a = `Unrecognized key(s) in object: ${ee.joinValues(e.keys, ", ")}`;
      break;
    case k.invalid_union:
      a = "Invalid input";
      break;
    case k.invalid_union_discriminator:
      a = `Invalid discriminator value. Expected ${ee.joinValues(e.options)}`;
      break;
    case k.invalid_enum_value:
      a = `Invalid enum value. Expected ${ee.joinValues(e.options)}, received '${e.received}'`;
      break;
    case k.invalid_arguments:
      a = "Invalid function arguments";
      break;
    case k.invalid_return_type:
      a = "Invalid function return type";
      break;
    case k.invalid_date:
      a = "Invalid date";
      break;
    case k.invalid_string:
      typeof e.validation == "object" ? "includes" in e.validation ? (a = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (a = `${a} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? a = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? a = `Invalid input: must end with "${e.validation.endsWith}"` : ee.assertNever(e.validation) : e.validation !== "regex" ? a = `Invalid ${e.validation}` : a = "Invalid";
      break;
    case k.too_small:
      e.type === "array" ? a = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? a = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? a = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? a = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : a = "Invalid input";
      break;
    case k.too_big:
      e.type === "array" ? a = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? a = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? a = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? a = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? a = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : a = "Invalid input";
      break;
    case k.custom:
      a = "Invalid input";
      break;
    case k.invalid_intersection_types:
      a = "Intersection results could not be merged";
      break;
    case k.not_multiple_of:
      a = `Number must be a multiple of ${e.multipleOf}`;
      break;
    case k.not_finite:
      a = "Number must be finite";
      break;
    default:
      a = t.defaultError, ee.assertNever(e);
  }
  return { message: a };
};
let l0 = Jr;
function S4(e) {
  l0 = e;
}
function ls() {
  return l0;
}
const bs = (e) => {
  const { data: t, path: a, errorMaps: r, issueData: n } = e, s = [...a, ...n.path || []], c = {
    ...n,
    path: s
  };
  let i = "";
  const o = r.filter((d) => !!d).slice().reverse();
  for (const d of o)
    i = d(c, { data: t, defaultError: i }).message;
  return {
    ...n,
    path: s,
    message: n.message || i
  };
}, C4 = [];
function P(e, t) {
  const a = bs({
    issueData: t,
    data: e.data,
    path: e.path,
    errorMaps: [
      e.common.contextualErrorMap,
      e.schemaErrorMap,
      ls(),
      Jr
      // then global default map
    ].filter((r) => !!r)
  });
  e.common.issues.push(a);
}
class Ee {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t, a) {
    const r = [];
    for (const n of a) {
      if (n.status === "aborted")
        return V;
      n.status === "dirty" && t.dirty(), r.push(n.value);
    }
    return { status: t.value, value: r };
  }
  static async mergeObjectAsync(t, a) {
    const r = [];
    for (const n of a)
      r.push({
        key: await n.key,
        value: await n.value
      });
    return Ee.mergeObjectSync(t, r);
  }
  static mergeObjectSync(t, a) {
    const r = {};
    for (const n of a) {
      const { key: s, value: c } = n;
      if (s.status === "aborted" || c.status === "aborted")
        return V;
      s.status === "dirty" && t.dirty(), c.status === "dirty" && t.dirty(), (typeof c.value < "u" || n.alwaysSet) && (r[s.value] = c.value);
    }
    return { status: t.value, value: r };
  }
}
const V = Object.freeze({
  status: "aborted"
}), b0 = (e) => ({ status: "dirty", value: e }), Ce = (e) => ({ status: "valid", value: e }), yi = (e) => e.status === "aborted", gi = (e) => e.status === "dirty", hs = (e) => e.status === "valid", ps = (e) => typeof Promise < "u" && e instanceof Promise;
var F;
(function(e) {
  e.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, e.toString = (t) => typeof t == "string" ? t : t?.message;
})(F || (F = {}));
class dt {
  constructor(t, a, r, n) {
    this._cachedPath = [], this.parent = t, this.data = a, this._path = r, this._key = n;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const ef = (e, t) => {
  if (hs(t))
    return { success: !0, data: t.value };
  if (!e.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const a = new Ve(e.common.issues);
      return this._error = a, this._error;
    }
  };
};
function K(e) {
  if (!e)
    return {};
  const { errorMap: t, invalid_type_error: a, required_error: r, description: n } = e;
  if (t && (a || r))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return t ? { errorMap: t, description: n } : { errorMap: (s, c) => s.code !== "invalid_type" ? { message: c.defaultError } : typeof c.data > "u" ? { message: r ?? c.defaultError } : { message: a ?? c.defaultError }, description: n };
}
class G {
  constructor(t) {
    this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(t) {
    return Lt(t.data);
  }
  _getOrReturnCtx(t, a) {
    return a || {
      common: t.parent.common,
      data: t.data,
      parsedType: Lt(t.data),
      schemaErrorMap: this._def.errorMap,
      path: t.path,
      parent: t.parent
    };
  }
  _processInputParams(t) {
    return {
      status: new Ee(),
      ctx: {
        common: t.parent.common,
        data: t.data,
        parsedType: Lt(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      }
    };
  }
  _parseSync(t) {
    const a = this._parse(t);
    if (ps(a))
      throw new Error("Synchronous parse encountered promise.");
    return a;
  }
  _parseAsync(t) {
    const a = this._parse(t);
    return Promise.resolve(a);
  }
  parse(t, a) {
    const r = this.safeParse(t, a);
    if (r.success)
      return r.data;
    throw r.error;
  }
  safeParse(t, a) {
    var r;
    const n = {
      common: {
        issues: [],
        async: (r = a?.async) !== null && r !== void 0 ? r : !1,
        contextualErrorMap: a?.errorMap
      },
      path: a?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: Lt(t)
    }, s = this._parseSync({ data: t, path: n.path, parent: n });
    return ef(n, s);
  }
  async parseAsync(t, a) {
    const r = await this.safeParseAsync(t, a);
    if (r.success)
      return r.data;
    throw r.error;
  }
  async safeParseAsync(t, a) {
    const r = {
      common: {
        issues: [],
        contextualErrorMap: a?.errorMap,
        async: !0
      },
      path: a?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: Lt(t)
    }, n = this._parse({ data: t, path: r.path, parent: r }), s = await (ps(n) ? n : Promise.resolve(n));
    return ef(r, s);
  }
  refine(t, a) {
    const r = (n) => typeof a == "string" || typeof a > "u" ? { message: a } : typeof a == "function" ? a(n) : a;
    return this._refinement((n, s) => {
      const c = t(n), i = () => s.addIssue({
        code: k.custom,
        ...r(n)
      });
      return typeof Promise < "u" && c instanceof Promise ? c.then((o) => o ? !0 : (i(), !1)) : c ? !0 : (i(), !1);
    });
  }
  refinement(t, a) {
    return this._refinement((r, n) => t(r) ? !0 : (n.addIssue(typeof a == "function" ? a(r, n) : a), !1));
  }
  _refinement(t) {
    return new Ye({
      schema: this,
      typeName: z.ZodEffects,
      effect: { type: "refinement", refinement: t }
    });
  }
  superRefine(t) {
    return this._refinement(t);
  }
  optional() {
    return wt.create(this, this._def);
  }
  nullable() {
    return xa.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return qe.create(this, this._def);
  }
  promise() {
    return sr.create(this, this._def);
  }
  or(t) {
    return tn.create([this, t], this._def);
  }
  and(t) {
    return an.create(this, t, this._def);
  }
  transform(t) {
    return new Ye({
      ...K(this._def),
      schema: this,
      typeName: z.ZodEffects,
      effect: { type: "transform", transform: t }
    });
  }
  default(t) {
    const a = typeof t == "function" ? t : () => t;
    return new on({
      ...K(this._def),
      innerType: this,
      defaultValue: a,
      typeName: z.ZodDefault
    });
  }
  brand() {
    return new p0({
      typeName: z.ZodBranded,
      type: this,
      ...K(this._def)
    });
  }
  catch(t) {
    const a = typeof t == "function" ? t : () => t;
    return new _s({
      ...K(this._def),
      innerType: this,
      catchValue: a,
      typeName: z.ZodCatch
    });
  }
  describe(t) {
    const a = this.constructor;
    return new a({
      ...this._def,
      description: t
    });
  }
  pipe(t) {
    return Pn.create(this, t);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const A4 = /^c[^\s-]{8,}$/i, O4 = /^[a-z][a-z0-9]*$/, I4 = /[0-9A-HJKMNP-TV-Z]{26}/, N4 = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i, R4 = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/, P4 = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u, L4 = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, j4 = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, Z4 = (e) => e.precision ? e.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}Z$`) : e.precision === 0 ? e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function D4(e, t) {
  return !!((t === "v4" || !t) && L4.test(e) || (t === "v6" || !t) && j4.test(e));
}
class Me extends G {
  constructor() {
    super(...arguments), this._regex = (t, a, r) => this.refinement((n) => t.test(n), {
      validation: a,
      code: k.invalid_string,
      ...F.errToObj(r)
    }), this.nonempty = (t) => this.min(1, F.errToObj(t)), this.trim = () => new Me({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    }), this.toLowerCase = () => new Me({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    }), this.toUpperCase = () => new Me({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  _parse(t) {
    if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== N.string) {
      const n = this._getOrReturnCtx(t);
      return P(
        n,
        {
          code: k.invalid_type,
          expected: N.string,
          received: n.parsedType
        }
        //
      ), V;
    }
    const a = new Ee();
    let r;
    for (const n of this._def.checks)
      if (n.kind === "min")
        t.data.length < n.value && (r = this._getOrReturnCtx(t, r), P(r, {
          code: k.too_small,
          minimum: n.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: n.message
        }), a.dirty());
      else if (n.kind === "max")
        t.data.length > n.value && (r = this._getOrReturnCtx(t, r), P(r, {
          code: k.too_big,
          maximum: n.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: n.message
        }), a.dirty());
      else if (n.kind === "length") {
        const s = t.data.length > n.value, c = t.data.length < n.value;
        (s || c) && (r = this._getOrReturnCtx(t, r), s ? P(r, {
          code: k.too_big,
          maximum: n.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: n.message
        }) : c && P(r, {
          code: k.too_small,
          minimum: n.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: n.message
        }), a.dirty());
      } else if (n.kind === "email")
        R4.test(t.data) || (r = this._getOrReturnCtx(t, r), P(r, {
          validation: "email",
          code: k.invalid_string,
          message: n.message
        }), a.dirty());
      else if (n.kind === "emoji")
        P4.test(t.data) || (r = this._getOrReturnCtx(t, r), P(r, {
          validation: "emoji",
          code: k.invalid_string,
          message: n.message
        }), a.dirty());
      else if (n.kind === "uuid")
        N4.test(t.data) || (r = this._getOrReturnCtx(t, r), P(r, {
          validation: "uuid",
          code: k.invalid_string,
          message: n.message
        }), a.dirty());
      else if (n.kind === "cuid")
        A4.test(t.data) || (r = this._getOrReturnCtx(t, r), P(r, {
          validation: "cuid",
          code: k.invalid_string,
          message: n.message
        }), a.dirty());
      else if (n.kind === "cuid2")
        O4.test(t.data) || (r = this._getOrReturnCtx(t, r), P(r, {
          validation: "cuid2",
          code: k.invalid_string,
          message: n.message
        }), a.dirty());
      else if (n.kind === "ulid")
        I4.test(t.data) || (r = this._getOrReturnCtx(t, r), P(r, {
          validation: "ulid",
          code: k.invalid_string,
          message: n.message
        }), a.dirty());
      else if (n.kind === "url")
        try {
          new URL(t.data);
        } catch {
          r = this._getOrReturnCtx(t, r), P(r, {
            validation: "url",
            code: k.invalid_string,
            message: n.message
          }), a.dirty();
        }
      else
        n.kind === "regex" ? (n.regex.lastIndex = 0, n.regex.test(t.data) || (r = this._getOrReturnCtx(t, r), P(r, {
          validation: "regex",
          code: k.invalid_string,
          message: n.message
        }), a.dirty())) : n.kind === "trim" ? t.data = t.data.trim() : n.kind === "includes" ? t.data.includes(n.value, n.position) || (r = this._getOrReturnCtx(t, r), P(r, {
          code: k.invalid_string,
          validation: { includes: n.value, position: n.position },
          message: n.message
        }), a.dirty()) : n.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : n.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : n.kind === "startsWith" ? t.data.startsWith(n.value) || (r = this._getOrReturnCtx(t, r), P(r, {
          code: k.invalid_string,
          validation: { startsWith: n.value },
          message: n.message
        }), a.dirty()) : n.kind === "endsWith" ? t.data.endsWith(n.value) || (r = this._getOrReturnCtx(t, r), P(r, {
          code: k.invalid_string,
          validation: { endsWith: n.value },
          message: n.message
        }), a.dirty()) : n.kind === "datetime" ? Z4(n).test(t.data) || (r = this._getOrReturnCtx(t, r), P(r, {
          code: k.invalid_string,
          validation: "datetime",
          message: n.message
        }), a.dirty()) : n.kind === "ip" ? D4(t.data, n.version) || (r = this._getOrReturnCtx(t, r), P(r, {
          validation: "ip",
          code: k.invalid_string,
          message: n.message
        }), a.dirty()) : ee.assertNever(n);
    return { status: a.value, value: t.data };
  }
  _addCheck(t) {
    return new Me({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  email(t) {
    return this._addCheck({ kind: "email", ...F.errToObj(t) });
  }
  url(t) {
    return this._addCheck({ kind: "url", ...F.errToObj(t) });
  }
  emoji(t) {
    return this._addCheck({ kind: "emoji", ...F.errToObj(t) });
  }
  uuid(t) {
    return this._addCheck({ kind: "uuid", ...F.errToObj(t) });
  }
  cuid(t) {
    return this._addCheck({ kind: "cuid", ...F.errToObj(t) });
  }
  cuid2(t) {
    return this._addCheck({ kind: "cuid2", ...F.errToObj(t) });
  }
  ulid(t) {
    return this._addCheck({ kind: "ulid", ...F.errToObj(t) });
  }
  ip(t) {
    return this._addCheck({ kind: "ip", ...F.errToObj(t) });
  }
  datetime(t) {
    var a;
    return typeof t == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      message: t
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof t?.precision > "u" ? null : t?.precision,
      offset: (a = t?.offset) !== null && a !== void 0 ? a : !1,
      ...F.errToObj(t?.message)
    });
  }
  regex(t, a) {
    return this._addCheck({
      kind: "regex",
      regex: t,
      ...F.errToObj(a)
    });
  }
  includes(t, a) {
    return this._addCheck({
      kind: "includes",
      value: t,
      position: a?.position,
      ...F.errToObj(a?.message)
    });
  }
  startsWith(t, a) {
    return this._addCheck({
      kind: "startsWith",
      value: t,
      ...F.errToObj(a)
    });
  }
  endsWith(t, a) {
    return this._addCheck({
      kind: "endsWith",
      value: t,
      ...F.errToObj(a)
    });
  }
  min(t, a) {
    return this._addCheck({
      kind: "min",
      value: t,
      ...F.errToObj(a)
    });
  }
  max(t, a) {
    return this._addCheck({
      kind: "max",
      value: t,
      ...F.errToObj(a)
    });
  }
  length(t, a) {
    return this._addCheck({
      kind: "length",
      value: t,
      ...F.errToObj(a)
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((t) => t.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((t) => t.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((t) => t.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((t) => t.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((t) => t.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((t) => t.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((t) => t.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((t) => t.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((t) => t.kind === "ip");
  }
  get minLength() {
    let t = null;
    for (const a of this._def.checks)
      a.kind === "min" && (t === null || a.value > t) && (t = a.value);
    return t;
  }
  get maxLength() {
    let t = null;
    for (const a of this._def.checks)
      a.kind === "max" && (t === null || a.value < t) && (t = a.value);
    return t;
  }
}
Me.create = (e) => {
  var t;
  return new Me({
    checks: [],
    typeName: z.ZodString,
    coerce: (t = e?.coerce) !== null && t !== void 0 ? t : !1,
    ...K(e)
  });
};
function B4(e, t) {
  const a = (e.toString().split(".")[1] || "").length, r = (t.toString().split(".")[1] || "").length, n = a > r ? a : r, s = parseInt(e.toFixed(n).replace(".", "")), c = parseInt(t.toFixed(n).replace(".", ""));
  return s % c / Math.pow(10, n);
}
class Wt extends G {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== N.number) {
      const n = this._getOrReturnCtx(t);
      return P(n, {
        code: k.invalid_type,
        expected: N.number,
        received: n.parsedType
      }), V;
    }
    let a;
    const r = new Ee();
    for (const n of this._def.checks)
      n.kind === "int" ? ee.isInteger(t.data) || (a = this._getOrReturnCtx(t, a), P(a, {
        code: k.invalid_type,
        expected: "integer",
        received: "float",
        message: n.message
      }), r.dirty()) : n.kind === "min" ? (n.inclusive ? t.data < n.value : t.data <= n.value) && (a = this._getOrReturnCtx(t, a), P(a, {
        code: k.too_small,
        minimum: n.value,
        type: "number",
        inclusive: n.inclusive,
        exact: !1,
        message: n.message
      }), r.dirty()) : n.kind === "max" ? (n.inclusive ? t.data > n.value : t.data >= n.value) && (a = this._getOrReturnCtx(t, a), P(a, {
        code: k.too_big,
        maximum: n.value,
        type: "number",
        inclusive: n.inclusive,
        exact: !1,
        message: n.message
      }), r.dirty()) : n.kind === "multipleOf" ? B4(t.data, n.value) !== 0 && (a = this._getOrReturnCtx(t, a), P(a, {
        code: k.not_multiple_of,
        multipleOf: n.value,
        message: n.message
      }), r.dirty()) : n.kind === "finite" ? Number.isFinite(t.data) || (a = this._getOrReturnCtx(t, a), P(a, {
        code: k.not_finite,
        message: n.message
      }), r.dirty()) : ee.assertNever(n);
    return { status: r.value, value: t.data };
  }
  gte(t, a) {
    return this.setLimit("min", t, !0, F.toString(a));
  }
  gt(t, a) {
    return this.setLimit("min", t, !1, F.toString(a));
  }
  lte(t, a) {
    return this.setLimit("max", t, !0, F.toString(a));
  }
  lt(t, a) {
    return this.setLimit("max", t, !1, F.toString(a));
  }
  setLimit(t, a, r, n) {
    return new Wt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: a,
          inclusive: r,
          message: F.toString(n)
        }
      ]
    });
  }
  _addCheck(t) {
    return new Wt({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  int(t) {
    return this._addCheck({
      kind: "int",
      message: F.toString(t)
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: F.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: F.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: F.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: F.toString(t)
    });
  }
  multipleOf(t, a) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: F.toString(a)
    });
  }
  finite(t) {
    return this._addCheck({
      kind: "finite",
      message: F.toString(t)
    });
  }
  safe(t) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: F.toString(t)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: F.toString(t)
    });
  }
  get minValue() {
    let t = null;
    for (const a of this._def.checks)
      a.kind === "min" && (t === null || a.value > t) && (t = a.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const a of this._def.checks)
      a.kind === "max" && (t === null || a.value < t) && (t = a.value);
    return t;
  }
  get isInt() {
    return !!this._def.checks.find((t) => t.kind === "int" || t.kind === "multipleOf" && ee.isInteger(t.value));
  }
  get isFinite() {
    let t = null, a = null;
    for (const r of this._def.checks) {
      if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf")
        return !0;
      r.kind === "min" ? (a === null || r.value > a) && (a = r.value) : r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    }
    return Number.isFinite(a) && Number.isFinite(t);
  }
}
Wt.create = (e) => new Wt({
  checks: [],
  typeName: z.ZodNumber,
  coerce: e?.coerce || !1,
  ...K(e)
});
class Gt extends G {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = BigInt(t.data)), this._getType(t) !== N.bigint) {
      const n = this._getOrReturnCtx(t);
      return P(n, {
        code: k.invalid_type,
        expected: N.bigint,
        received: n.parsedType
      }), V;
    }
    let a;
    const r = new Ee();
    for (const n of this._def.checks)
      n.kind === "min" ? (n.inclusive ? t.data < n.value : t.data <= n.value) && (a = this._getOrReturnCtx(t, a), P(a, {
        code: k.too_small,
        type: "bigint",
        minimum: n.value,
        inclusive: n.inclusive,
        message: n.message
      }), r.dirty()) : n.kind === "max" ? (n.inclusive ? t.data > n.value : t.data >= n.value) && (a = this._getOrReturnCtx(t, a), P(a, {
        code: k.too_big,
        type: "bigint",
        maximum: n.value,
        inclusive: n.inclusive,
        message: n.message
      }), r.dirty()) : n.kind === "multipleOf" ? t.data % n.value !== BigInt(0) && (a = this._getOrReturnCtx(t, a), P(a, {
        code: k.not_multiple_of,
        multipleOf: n.value,
        message: n.message
      }), r.dirty()) : ee.assertNever(n);
    return { status: r.value, value: t.data };
  }
  gte(t, a) {
    return this.setLimit("min", t, !0, F.toString(a));
  }
  gt(t, a) {
    return this.setLimit("min", t, !1, F.toString(a));
  }
  lte(t, a) {
    return this.setLimit("max", t, !0, F.toString(a));
  }
  lt(t, a) {
    return this.setLimit("max", t, !1, F.toString(a));
  }
  setLimit(t, a, r, n) {
    return new Gt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: a,
          inclusive: r,
          message: F.toString(n)
        }
      ]
    });
  }
  _addCheck(t) {
    return new Gt({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: F.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: F.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: F.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: F.toString(t)
    });
  }
  multipleOf(t, a) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: F.toString(a)
    });
  }
  get minValue() {
    let t = null;
    for (const a of this._def.checks)
      a.kind === "min" && (t === null || a.value > t) && (t = a.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const a of this._def.checks)
      a.kind === "max" && (t === null || a.value < t) && (t = a.value);
    return t;
  }
}
Gt.create = (e) => {
  var t;
  return new Gt({
    checks: [],
    typeName: z.ZodBigInt,
    coerce: (t = e?.coerce) !== null && t !== void 0 ? t : !1,
    ...K(e)
  });
};
class Xr extends G {
  _parse(t) {
    if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== N.boolean) {
      const a = this._getOrReturnCtx(t);
      return P(a, {
        code: k.invalid_type,
        expected: N.boolean,
        received: a.parsedType
      }), V;
    }
    return Ce(t.data);
  }
}
Xr.create = (e) => new Xr({
  typeName: z.ZodBoolean,
  coerce: e?.coerce || !1,
  ...K(e)
});
class Ea extends G {
  _parse(t) {
    if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== N.date) {
      const n = this._getOrReturnCtx(t);
      return P(n, {
        code: k.invalid_type,
        expected: N.date,
        received: n.parsedType
      }), V;
    }
    if (isNaN(t.data.getTime())) {
      const n = this._getOrReturnCtx(t);
      return P(n, {
        code: k.invalid_date
      }), V;
    }
    const a = new Ee();
    let r;
    for (const n of this._def.checks)
      n.kind === "min" ? t.data.getTime() < n.value && (r = this._getOrReturnCtx(t, r), P(r, {
        code: k.too_small,
        message: n.message,
        inclusive: !0,
        exact: !1,
        minimum: n.value,
        type: "date"
      }), a.dirty()) : n.kind === "max" ? t.data.getTime() > n.value && (r = this._getOrReturnCtx(t, r), P(r, {
        code: k.too_big,
        message: n.message,
        inclusive: !0,
        exact: !1,
        maximum: n.value,
        type: "date"
      }), a.dirty()) : ee.assertNever(n);
    return {
      status: a.value,
      value: new Date(t.data.getTime())
    };
  }
  _addCheck(t) {
    return new Ea({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  min(t, a) {
    return this._addCheck({
      kind: "min",
      value: t.getTime(),
      message: F.toString(a)
    });
  }
  max(t, a) {
    return this._addCheck({
      kind: "max",
      value: t.getTime(),
      message: F.toString(a)
    });
  }
  get minDate() {
    let t = null;
    for (const a of this._def.checks)
      a.kind === "min" && (t === null || a.value > t) && (t = a.value);
    return t != null ? new Date(t) : null;
  }
  get maxDate() {
    let t = null;
    for (const a of this._def.checks)
      a.kind === "max" && (t === null || a.value < t) && (t = a.value);
    return t != null ? new Date(t) : null;
  }
}
Ea.create = (e) => new Ea({
  checks: [],
  coerce: e?.coerce || !1,
  typeName: z.ZodDate,
  ...K(e)
});
class ms extends G {
  _parse(t) {
    if (this._getType(t) !== N.symbol) {
      const a = this._getOrReturnCtx(t);
      return P(a, {
        code: k.invalid_type,
        expected: N.symbol,
        received: a.parsedType
      }), V;
    }
    return Ce(t.data);
  }
}
ms.create = (e) => new ms({
  typeName: z.ZodSymbol,
  ...K(e)
});
class Qr extends G {
  _parse(t) {
    if (this._getType(t) !== N.undefined) {
      const a = this._getOrReturnCtx(t);
      return P(a, {
        code: k.invalid_type,
        expected: N.undefined,
        received: a.parsedType
      }), V;
    }
    return Ce(t.data);
  }
}
Qr.create = (e) => new Qr({
  typeName: z.ZodUndefined,
  ...K(e)
});
class en extends G {
  _parse(t) {
    if (this._getType(t) !== N.null) {
      const a = this._getOrReturnCtx(t);
      return P(a, {
        code: k.invalid_type,
        expected: N.null,
        received: a.parsedType
      }), V;
    }
    return Ce(t.data);
  }
}
en.create = (e) => new en({
  typeName: z.ZodNull,
  ...K(e)
});
class nr extends G {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(t) {
    return Ce(t.data);
  }
}
nr.create = (e) => new nr({
  typeName: z.ZodAny,
  ...K(e)
});
class ha extends G {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(t) {
    return Ce(t.data);
  }
}
ha.create = (e) => new ha({
  typeName: z.ZodUnknown,
  ...K(e)
});
class Tt extends G {
  _parse(t) {
    const a = this._getOrReturnCtx(t);
    return P(a, {
      code: k.invalid_type,
      expected: N.never,
      received: a.parsedType
    }), V;
  }
}
Tt.create = (e) => new Tt({
  typeName: z.ZodNever,
  ...K(e)
});
class ys extends G {
  _parse(t) {
    if (this._getType(t) !== N.undefined) {
      const a = this._getOrReturnCtx(t);
      return P(a, {
        code: k.invalid_type,
        expected: N.void,
        received: a.parsedType
      }), V;
    }
    return Ce(t.data);
  }
}
ys.create = (e) => new ys({
  typeName: z.ZodVoid,
  ...K(e)
});
class qe extends G {
  _parse(t) {
    const { ctx: a, status: r } = this._processInputParams(t), n = this._def;
    if (a.parsedType !== N.array)
      return P(a, {
        code: k.invalid_type,
        expected: N.array,
        received: a.parsedType
      }), V;
    if (n.exactLength !== null) {
      const c = a.data.length > n.exactLength.value, i = a.data.length < n.exactLength.value;
      (c || i) && (P(a, {
        code: c ? k.too_big : k.too_small,
        minimum: i ? n.exactLength.value : void 0,
        maximum: c ? n.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: n.exactLength.message
      }), r.dirty());
    }
    if (n.minLength !== null && a.data.length < n.minLength.value && (P(a, {
      code: k.too_small,
      minimum: n.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: n.minLength.message
    }), r.dirty()), n.maxLength !== null && a.data.length > n.maxLength.value && (P(a, {
      code: k.too_big,
      maximum: n.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: n.maxLength.message
    }), r.dirty()), a.common.async)
      return Promise.all([...a.data].map((c, i) => n.type._parseAsync(new dt(a, c, a.path, i)))).then((c) => Ee.mergeArray(r, c));
    const s = [...a.data].map((c, i) => n.type._parseSync(new dt(a, c, a.path, i)));
    return Ee.mergeArray(r, s);
  }
  get element() {
    return this._def.type;
  }
  min(t, a) {
    return new qe({
      ...this._def,
      minLength: { value: t, message: F.toString(a) }
    });
  }
  max(t, a) {
    return new qe({
      ...this._def,
      maxLength: { value: t, message: F.toString(a) }
    });
  }
  length(t, a) {
    return new qe({
      ...this._def,
      exactLength: { value: t, message: F.toString(a) }
    });
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
qe.create = (e, t) => new qe({
  type: e,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: z.ZodArray,
  ...K(t)
});
function Ba(e) {
  if (e instanceof ie) {
    const t = {};
    for (const a in e.shape) {
      const r = e.shape[a];
      t[a] = wt.create(Ba(r));
    }
    return new ie({
      ...e._def,
      shape: () => t
    });
  } else
    return e instanceof qe ? new qe({
      ...e._def,
      type: Ba(e.element)
    }) : e instanceof wt ? wt.create(Ba(e.unwrap())) : e instanceof xa ? xa.create(Ba(e.unwrap())) : e instanceof ft ? ft.create(e.items.map((t) => Ba(t))) : e;
}
class ie extends G {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const t = this._def.shape(), a = ee.objectKeys(t);
    return this._cached = { shape: t, keys: a };
  }
  _parse(t) {
    if (this._getType(t) !== N.object) {
      const o = this._getOrReturnCtx(t);
      return P(o, {
        code: k.invalid_type,
        expected: N.object,
        received: o.parsedType
      }), V;
    }
    const { status: a, ctx: r } = this._processInputParams(t), { shape: n, keys: s } = this._getCached(), c = [];
    if (!(this._def.catchall instanceof Tt && this._def.unknownKeys === "strip"))
      for (const o in r.data)
        s.includes(o) || c.push(o);
    const i = [];
    for (const o of s) {
      const d = n[o], f = r.data[o];
      i.push({
        key: { status: "valid", value: o },
        value: d._parse(new dt(r, f, r.path, o)),
        alwaysSet: o in r.data
      });
    }
    if (this._def.catchall instanceof Tt) {
      const o = this._def.unknownKeys;
      if (o === "passthrough")
        for (const d of c)
          i.push({
            key: { status: "valid", value: d },
            value: { status: "valid", value: r.data[d] }
          });
      else if (o === "strict")
        c.length > 0 && (P(r, {
          code: k.unrecognized_keys,
          keys: c
        }), a.dirty());
      else if (o !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const o = this._def.catchall;
      for (const d of c) {
        const f = r.data[d];
        i.push({
          key: { status: "valid", value: d },
          value: o._parse(
            new dt(r, f, r.path, d)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: d in r.data
        });
      }
    }
    return r.common.async ? Promise.resolve().then(async () => {
      const o = [];
      for (const d of i) {
        const f = await d.key;
        o.push({
          key: f,
          value: await d.value,
          alwaysSet: d.alwaysSet
        });
      }
      return o;
    }).then((o) => Ee.mergeObjectSync(a, o)) : Ee.mergeObjectSync(a, i);
  }
  get shape() {
    return this._def.shape();
  }
  strict(t) {
    return F.errToObj, new ie({
      ...this._def,
      unknownKeys: "strict",
      ...t !== void 0 ? {
        errorMap: (a, r) => {
          var n, s, c, i;
          const o = (c = (s = (n = this._def).errorMap) === null || s === void 0 ? void 0 : s.call(n, a, r).message) !== null && c !== void 0 ? c : r.defaultError;
          return a.code === "unrecognized_keys" ? {
            message: (i = F.errToObj(t).message) !== null && i !== void 0 ? i : o
          } : {
            message: o
          };
        }
      } : {}
    });
  }
  strip() {
    return new ie({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ie({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(t) {
    return new ie({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...t
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(t) {
    return new ie({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...t._def.shape()
      }),
      typeName: z.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(t, a) {
    return this.augment({ [t]: a });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(t) {
    return new ie({
      ...this._def,
      catchall: t
    });
  }
  pick(t) {
    const a = {};
    return ee.objectKeys(t).forEach((r) => {
      t[r] && this.shape[r] && (a[r] = this.shape[r]);
    }), new ie({
      ...this._def,
      shape: () => a
    });
  }
  omit(t) {
    const a = {};
    return ee.objectKeys(this.shape).forEach((r) => {
      t[r] || (a[r] = this.shape[r]);
    }), new ie({
      ...this._def,
      shape: () => a
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return Ba(this);
  }
  partial(t) {
    const a = {};
    return ee.objectKeys(this.shape).forEach((r) => {
      const n = this.shape[r];
      t && !t[r] ? a[r] = n : a[r] = n.optional();
    }), new ie({
      ...this._def,
      shape: () => a
    });
  }
  required(t) {
    const a = {};
    return ee.objectKeys(this.shape).forEach((r) => {
      if (t && !t[r])
        a[r] = this.shape[r];
      else {
        let n = this.shape[r];
        for (; n instanceof wt; )
          n = n._def.innerType;
        a[r] = n;
      }
    }), new ie({
      ...this._def,
      shape: () => a
    });
  }
  keyof() {
    return h0(ee.objectKeys(this.shape));
  }
}
ie.create = (e, t) => new ie({
  shape: () => e,
  unknownKeys: "strip",
  catchall: Tt.create(),
  typeName: z.ZodObject,
  ...K(t)
});
ie.strictCreate = (e, t) => new ie({
  shape: () => e,
  unknownKeys: "strict",
  catchall: Tt.create(),
  typeName: z.ZodObject,
  ...K(t)
});
ie.lazycreate = (e, t) => new ie({
  shape: e,
  unknownKeys: "strip",
  catchall: Tt.create(),
  typeName: z.ZodObject,
  ...K(t)
});
class tn extends G {
  _parse(t) {
    const { ctx: a } = this._processInputParams(t), r = this._def.options;
    function n(s) {
      for (const i of s)
        if (i.result.status === "valid")
          return i.result;
      for (const i of s)
        if (i.result.status === "dirty")
          return a.common.issues.push(...i.ctx.common.issues), i.result;
      const c = s.map((i) => new Ve(i.ctx.common.issues));
      return P(a, {
        code: k.invalid_union,
        unionErrors: c
      }), V;
    }
    if (a.common.async)
      return Promise.all(r.map(async (s) => {
        const c = {
          ...a,
          common: {
            ...a.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await s._parseAsync({
            data: a.data,
            path: a.path,
            parent: c
          }),
          ctx: c
        };
      })).then(n);
    {
      let s;
      const c = [];
      for (const o of r) {
        const d = {
          ...a,
          common: {
            ...a.common,
            issues: []
          },
          parent: null
        }, f = o._parseSync({
          data: a.data,
          path: a.path,
          parent: d
        });
        if (f.status === "valid")
          return f;
        f.status === "dirty" && !s && (s = { result: f, ctx: d }), d.common.issues.length && c.push(d.common.issues);
      }
      if (s)
        return a.common.issues.push(...s.ctx.common.issues), s.result;
      const i = c.map((o) => new Ve(o));
      return P(a, {
        code: k.invalid_union,
        unionErrors: i
      }), V;
    }
  }
  get options() {
    return this._def.options;
  }
}
tn.create = (e, t) => new tn({
  options: e,
  typeName: z.ZodUnion,
  ...K(t)
});
const Jn = (e) => e instanceof nn ? Jn(e.schema) : e instanceof Ye ? Jn(e.innerType()) : e instanceof sn ? [e.value] : e instanceof Yt ? e.options : e instanceof cn ? Object.keys(e.enum) : e instanceof on ? Jn(e._def.innerType) : e instanceof Qr ? [void 0] : e instanceof en ? [null] : null;
class Gs extends G {
  _parse(t) {
    const { ctx: a } = this._processInputParams(t);
    if (a.parsedType !== N.object)
      return P(a, {
        code: k.invalid_type,
        expected: N.object,
        received: a.parsedType
      }), V;
    const r = this.discriminator, n = a.data[r], s = this.optionsMap.get(n);
    return s ? a.common.async ? s._parseAsync({
      data: a.data,
      path: a.path,
      parent: a
    }) : s._parseSync({
      data: a.data,
      path: a.path,
      parent: a
    }) : (P(a, {
      code: k.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [r]
    }), V);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(t, a, r) {
    const n = /* @__PURE__ */ new Map();
    for (const s of a) {
      const c = Jn(s.shape[t]);
      if (!c)
        throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
      for (const i of c) {
        if (n.has(i))
          throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(i)}`);
        n.set(i, s);
      }
    }
    return new Gs({
      typeName: z.ZodDiscriminatedUnion,
      discriminator: t,
      options: a,
      optionsMap: n,
      ...K(r)
    });
  }
}
function _i(e, t) {
  const a = Lt(e), r = Lt(t);
  if (e === t)
    return { valid: !0, data: e };
  if (a === N.object && r === N.object) {
    const n = ee.objectKeys(t), s = ee.objectKeys(e).filter((i) => n.indexOf(i) !== -1), c = { ...e, ...t };
    for (const i of s) {
      const o = _i(e[i], t[i]);
      if (!o.valid)
        return { valid: !1 };
      c[i] = o.data;
    }
    return { valid: !0, data: c };
  } else if (a === N.array && r === N.array) {
    if (e.length !== t.length)
      return { valid: !1 };
    const n = [];
    for (let s = 0; s < e.length; s++) {
      const c = e[s], i = t[s], o = _i(c, i);
      if (!o.valid)
        return { valid: !1 };
      n.push(o.data);
    }
    return { valid: !0, data: n };
  } else
    return a === N.date && r === N.date && +e == +t ? { valid: !0, data: e } : { valid: !1 };
}
class an extends G {
  _parse(t) {
    const { status: a, ctx: r } = this._processInputParams(t), n = (s, c) => {
      if (yi(s) || yi(c))
        return V;
      const i = _i(s.value, c.value);
      return i.valid ? ((gi(s) || gi(c)) && a.dirty(), { status: a.value, value: i.data }) : (P(r, {
        code: k.invalid_intersection_types
      }), V);
    };
    return r.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      }),
      this._def.right._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      })
    ]).then(([s, c]) => n(s, c)) : n(this._def.left._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }), this._def.right._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }));
  }
}
an.create = (e, t, a) => new an({
  left: e,
  right: t,
  typeName: z.ZodIntersection,
  ...K(a)
});
class ft extends G {
  _parse(t) {
    const { status: a, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== N.array)
      return P(r, {
        code: k.invalid_type,
        expected: N.array,
        received: r.parsedType
      }), V;
    if (r.data.length < this._def.items.length)
      return P(r, {
        code: k.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), V;
    !this._def.rest && r.data.length > this._def.items.length && (P(r, {
      code: k.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), a.dirty());
    const n = [...r.data].map((s, c) => {
      const i = this._def.items[c] || this._def.rest;
      return i ? i._parse(new dt(r, s, r.path, c)) : null;
    }).filter((s) => !!s);
    return r.common.async ? Promise.all(n).then((s) => Ee.mergeArray(a, s)) : Ee.mergeArray(a, n);
  }
  get items() {
    return this._def.items;
  }
  rest(t) {
    return new ft({
      ...this._def,
      rest: t
    });
  }
}
ft.create = (e, t) => {
  if (!Array.isArray(e))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new ft({
    items: e,
    typeName: z.ZodTuple,
    rest: null,
    ...K(t)
  });
};
class rn extends G {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: a, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== N.object)
      return P(r, {
        code: k.invalid_type,
        expected: N.object,
        received: r.parsedType
      }), V;
    const n = [], s = this._def.keyType, c = this._def.valueType;
    for (const i in r.data)
      n.push({
        key: s._parse(new dt(r, i, r.path, i)),
        value: c._parse(new dt(r, r.data[i], r.path, i))
      });
    return r.common.async ? Ee.mergeObjectAsync(a, n) : Ee.mergeObjectSync(a, n);
  }
  get element() {
    return this._def.valueType;
  }
  static create(t, a, r) {
    return a instanceof G ? new rn({
      keyType: t,
      valueType: a,
      typeName: z.ZodRecord,
      ...K(r)
    }) : new rn({
      keyType: Me.create(),
      valueType: t,
      typeName: z.ZodRecord,
      ...K(a)
    });
  }
}
class gs extends G {
  _parse(t) {
    const { status: a, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== N.map)
      return P(r, {
        code: k.invalid_type,
        expected: N.map,
        received: r.parsedType
      }), V;
    const n = this._def.keyType, s = this._def.valueType, c = [...r.data.entries()].map(([i, o], d) => ({
      key: n._parse(new dt(r, i, r.path, [d, "key"])),
      value: s._parse(new dt(r, o, r.path, [d, "value"]))
    }));
    if (r.common.async) {
      const i = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const o of c) {
          const d = await o.key, f = await o.value;
          if (d.status === "aborted" || f.status === "aborted")
            return V;
          (d.status === "dirty" || f.status === "dirty") && a.dirty(), i.set(d.value, f.value);
        }
        return { status: a.value, value: i };
      });
    } else {
      const i = /* @__PURE__ */ new Map();
      for (const o of c) {
        const d = o.key, f = o.value;
        if (d.status === "aborted" || f.status === "aborted")
          return V;
        (d.status === "dirty" || f.status === "dirty") && a.dirty(), i.set(d.value, f.value);
      }
      return { status: a.value, value: i };
    }
  }
}
gs.create = (e, t, a) => new gs({
  valueType: t,
  keyType: e,
  typeName: z.ZodMap,
  ...K(a)
});
class ka extends G {
  _parse(t) {
    const { status: a, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== N.set)
      return P(r, {
        code: k.invalid_type,
        expected: N.set,
        received: r.parsedType
      }), V;
    const n = this._def;
    n.minSize !== null && r.data.size < n.minSize.value && (P(r, {
      code: k.too_small,
      minimum: n.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: n.minSize.message
    }), a.dirty()), n.maxSize !== null && r.data.size > n.maxSize.value && (P(r, {
      code: k.too_big,
      maximum: n.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: n.maxSize.message
    }), a.dirty());
    const s = this._def.valueType;
    function c(o) {
      const d = /* @__PURE__ */ new Set();
      for (const f of o) {
        if (f.status === "aborted")
          return V;
        f.status === "dirty" && a.dirty(), d.add(f.value);
      }
      return { status: a.value, value: d };
    }
    const i = [...r.data.values()].map((o, d) => s._parse(new dt(r, o, r.path, d)));
    return r.common.async ? Promise.all(i).then((o) => c(o)) : c(i);
  }
  min(t, a) {
    return new ka({
      ...this._def,
      minSize: { value: t, message: F.toString(a) }
    });
  }
  max(t, a) {
    return new ka({
      ...this._def,
      maxSize: { value: t, message: F.toString(a) }
    });
  }
  size(t, a) {
    return this.min(t, a).max(t, a);
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
ka.create = (e, t) => new ka({
  valueType: e,
  minSize: null,
  maxSize: null,
  typeName: z.ZodSet,
  ...K(t)
});
class Ga extends G {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(t) {
    const { ctx: a } = this._processInputParams(t);
    if (a.parsedType !== N.function)
      return P(a, {
        code: k.invalid_type,
        expected: N.function,
        received: a.parsedType
      }), V;
    function r(i, o) {
      return bs({
        data: i,
        path: a.path,
        errorMaps: [
          a.common.contextualErrorMap,
          a.schemaErrorMap,
          ls(),
          Jr
        ].filter((d) => !!d),
        issueData: {
          code: k.invalid_arguments,
          argumentsError: o
        }
      });
    }
    function n(i, o) {
      return bs({
        data: i,
        path: a.path,
        errorMaps: [
          a.common.contextualErrorMap,
          a.schemaErrorMap,
          ls(),
          Jr
        ].filter((d) => !!d),
        issueData: {
          code: k.invalid_return_type,
          returnTypeError: o
        }
      });
    }
    const s = { errorMap: a.common.contextualErrorMap }, c = a.data;
    return this._def.returns instanceof sr ? Ce(async (...i) => {
      const o = new Ve([]), d = await this._def.args.parseAsync(i, s).catch((u) => {
        throw o.addIssue(r(i, u)), o;
      }), f = await c(...d);
      return await this._def.returns._def.type.parseAsync(f, s).catch((u) => {
        throw o.addIssue(n(f, u)), o;
      });
    }) : Ce((...i) => {
      const o = this._def.args.safeParse(i, s);
      if (!o.success)
        throw new Ve([r(i, o.error)]);
      const d = c(...o.data), f = this._def.returns.safeParse(d, s);
      if (!f.success)
        throw new Ve([n(d, f.error)]);
      return f.data;
    });
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...t) {
    return new Ga({
      ...this._def,
      args: ft.create(t).rest(ha.create())
    });
  }
  returns(t) {
    return new Ga({
      ...this._def,
      returns: t
    });
  }
  implement(t) {
    return this.parse(t);
  }
  strictImplement(t) {
    return this.parse(t);
  }
  static create(t, a, r) {
    return new Ga({
      args: t || ft.create([]).rest(ha.create()),
      returns: a || ha.create(),
      typeName: z.ZodFunction,
      ...K(r)
    });
  }
}
class nn extends G {
  get schema() {
    return this._def.getter();
  }
  _parse(t) {
    const { ctx: a } = this._processInputParams(t);
    return this._def.getter()._parse({ data: a.data, path: a.path, parent: a });
  }
}
nn.create = (e, t) => new nn({
  getter: e,
  typeName: z.ZodLazy,
  ...K(t)
});
class sn extends G {
  _parse(t) {
    if (t.data !== this._def.value) {
      const a = this._getOrReturnCtx(t);
      return P(a, {
        received: a.data,
        code: k.invalid_literal,
        expected: this._def.value
      }), V;
    }
    return { status: "valid", value: t.data };
  }
  get value() {
    return this._def.value;
  }
}
sn.create = (e, t) => new sn({
  value: e,
  typeName: z.ZodLiteral,
  ...K(t)
});
function h0(e, t) {
  return new Yt({
    values: e,
    typeName: z.ZodEnum,
    ...K(t)
  });
}
class Yt extends G {
  _parse(t) {
    if (typeof t.data != "string") {
      const a = this._getOrReturnCtx(t), r = this._def.values;
      return P(a, {
        expected: ee.joinValues(r),
        received: a.parsedType,
        code: k.invalid_type
      }), V;
    }
    if (this._def.values.indexOf(t.data) === -1) {
      const a = this._getOrReturnCtx(t), r = this._def.values;
      return P(a, {
        received: a.data,
        code: k.invalid_enum_value,
        options: r
      }), V;
    }
    return Ce(t.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const t = {};
    for (const a of this._def.values)
      t[a] = a;
    return t;
  }
  get Values() {
    const t = {};
    for (const a of this._def.values)
      t[a] = a;
    return t;
  }
  get Enum() {
    const t = {};
    for (const a of this._def.values)
      t[a] = a;
    return t;
  }
  extract(t) {
    return Yt.create(t);
  }
  exclude(t) {
    return Yt.create(this.options.filter((a) => !t.includes(a)));
  }
}
Yt.create = h0;
class cn extends G {
  _parse(t) {
    const a = ee.getValidEnumValues(this._def.values), r = this._getOrReturnCtx(t);
    if (r.parsedType !== N.string && r.parsedType !== N.number) {
      const n = ee.objectValues(a);
      return P(r, {
        expected: ee.joinValues(n),
        received: r.parsedType,
        code: k.invalid_type
      }), V;
    }
    if (a.indexOf(t.data) === -1) {
      const n = ee.objectValues(a);
      return P(r, {
        received: r.data,
        code: k.invalid_enum_value,
        options: n
      }), V;
    }
    return Ce(t.data);
  }
  get enum() {
    return this._def.values;
  }
}
cn.create = (e, t) => new cn({
  values: e,
  typeName: z.ZodNativeEnum,
  ...K(t)
});
class sr extends G {
  unwrap() {
    return this._def.type;
  }
  _parse(t) {
    const { ctx: a } = this._processInputParams(t);
    if (a.parsedType !== N.promise && a.common.async === !1)
      return P(a, {
        code: k.invalid_type,
        expected: N.promise,
        received: a.parsedType
      }), V;
    const r = a.parsedType === N.promise ? a.data : Promise.resolve(a.data);
    return Ce(r.then((n) => this._def.type.parseAsync(n, {
      path: a.path,
      errorMap: a.common.contextualErrorMap
    })));
  }
}
sr.create = (e, t) => new sr({
  type: e,
  typeName: z.ZodPromise,
  ...K(t)
});
class Ye extends G {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === z.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(t) {
    const { status: a, ctx: r } = this._processInputParams(t), n = this._def.effect || null;
    if (n.type === "preprocess") {
      const c = n.transform(r.data);
      return r.common.async ? Promise.resolve(c).then((i) => this._def.schema._parseAsync({
        data: i,
        path: r.path,
        parent: r
      })) : this._def.schema._parseSync({
        data: c,
        path: r.path,
        parent: r
      });
    }
    const s = {
      addIssue: (c) => {
        P(r, c), c.fatal ? a.abort() : a.dirty();
      },
      get path() {
        return r.path;
      }
    };
    if (s.addIssue = s.addIssue.bind(s), n.type === "refinement") {
      const c = (i) => {
        const o = n.refinement(i, s);
        if (r.common.async)
          return Promise.resolve(o);
        if (o instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return i;
      };
      if (r.common.async === !1) {
        const i = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return i.status === "aborted" ? V : (i.status === "dirty" && a.dirty(), c(i.value), { status: a.value, value: i.value });
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((i) => i.status === "aborted" ? V : (i.status === "dirty" && a.dirty(), c(i.value).then(() => ({ status: a.value, value: i.value }))));
    }
    if (n.type === "transform")
      if (r.common.async === !1) {
        const c = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        if (!hs(c))
          return c;
        const i = n.transform(c.value, s);
        if (i instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: a.value, value: i };
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((c) => hs(c) ? Promise.resolve(n.transform(c.value, s)).then((i) => ({ status: a.value, value: i })) : c);
    ee.assertNever(n);
  }
}
Ye.create = (e, t, a) => new Ye({
  schema: e,
  typeName: z.ZodEffects,
  effect: t,
  ...K(a)
});
Ye.createWithPreprocess = (e, t, a) => new Ye({
  schema: t,
  effect: { type: "preprocess", transform: e },
  typeName: z.ZodEffects,
  ...K(a)
});
class wt extends G {
  _parse(t) {
    return this._getType(t) === N.undefined ? Ce(void 0) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
wt.create = (e, t) => new wt({
  innerType: e,
  typeName: z.ZodOptional,
  ...K(t)
});
class xa extends G {
  _parse(t) {
    return this._getType(t) === N.null ? Ce(null) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
xa.create = (e, t) => new xa({
  innerType: e,
  typeName: z.ZodNullable,
  ...K(t)
});
class on extends G {
  _parse(t) {
    const { ctx: a } = this._processInputParams(t);
    let r = a.data;
    return a.parsedType === N.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({
      data: r,
      path: a.path,
      parent: a
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
on.create = (e, t) => new on({
  innerType: e,
  typeName: z.ZodDefault,
  defaultValue: typeof t.default == "function" ? t.default : () => t.default,
  ...K(t)
});
class _s extends G {
  _parse(t) {
    const { ctx: a } = this._processInputParams(t), r = {
      ...a,
      common: {
        ...a.common,
        issues: []
      }
    }, n = this._def.innerType._parse({
      data: r.data,
      path: r.path,
      parent: {
        ...r
      }
    });
    return ps(n) ? n.then((s) => ({
      status: "valid",
      value: s.status === "valid" ? s.value : this._def.catchValue({
        get error() {
          return new Ve(r.common.issues);
        },
        input: r.data
      })
    })) : {
      status: "valid",
      value: n.status === "valid" ? n.value : this._def.catchValue({
        get error() {
          return new Ve(r.common.issues);
        },
        input: r.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
_s.create = (e, t) => new _s({
  innerType: e,
  typeName: z.ZodCatch,
  catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
  ...K(t)
});
class vs extends G {
  _parse(t) {
    if (this._getType(t) !== N.nan) {
      const a = this._getOrReturnCtx(t);
      return P(a, {
        code: k.invalid_type,
        expected: N.nan,
        received: a.parsedType
      }), V;
    }
    return { status: "valid", value: t.data };
  }
}
vs.create = (e) => new vs({
  typeName: z.ZodNaN,
  ...K(e)
});
const F4 = Symbol("zod_brand");
class p0 extends G {
  _parse(t) {
    const { ctx: a } = this._processInputParams(t), r = a.data;
    return this._def.type._parse({
      data: r,
      path: a.path,
      parent: a
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class Pn extends G {
  _parse(t) {
    const { status: a, ctx: r } = this._processInputParams(t);
    if (r.common.async)
      return (async () => {
        const n = await this._def.in._parseAsync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return n.status === "aborted" ? V : n.status === "dirty" ? (a.dirty(), b0(n.value)) : this._def.out._parseAsync({
          data: n.value,
          path: r.path,
          parent: r
        });
      })();
    {
      const n = this._def.in._parseSync({
        data: r.data,
        path: r.path,
        parent: r
      });
      return n.status === "aborted" ? V : n.status === "dirty" ? (a.dirty(), {
        status: "dirty",
        value: n.value
      }) : this._def.out._parseSync({
        data: n.value,
        path: r.path,
        parent: r
      });
    }
  }
  static create(t, a) {
    return new Pn({
      in: t,
      out: a,
      typeName: z.ZodPipeline
    });
  }
}
const m0 = (e, t = {}, a) => e ? nr.create().superRefine((r, n) => {
  var s, c;
  if (!e(r)) {
    const i = typeof t == "function" ? t(r) : typeof t == "string" ? { message: t } : t, o = (c = (s = i.fatal) !== null && s !== void 0 ? s : a) !== null && c !== void 0 ? c : !0, d = typeof i == "string" ? { message: i } : i;
    n.addIssue({ code: "custom", ...d, fatal: o });
  }
}) : nr.create(), U4 = {
  object: ie.lazycreate
};
var z;
(function(e) {
  e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline";
})(z || (z = {}));
const $4 = (e, t = {
  message: `Input not instance of ${e.name}`
}) => m0((a) => a instanceof e, t), y0 = Me.create, g0 = Wt.create, z4 = vs.create, M4 = Gt.create, _0 = Xr.create, H4 = Ea.create, V4 = ms.create, q4 = Qr.create, K4 = en.create, W4 = nr.create, G4 = ha.create, Y4 = Tt.create, J4 = ys.create, X4 = qe.create, Q4 = ie.create, e9 = ie.strictCreate, t9 = tn.create, a9 = Gs.create, r9 = an.create, n9 = ft.create, s9 = rn.create, c9 = gs.create, i9 = ka.create, o9 = Ga.create, d9 = nn.create, f9 = sn.create, u9 = Yt.create, l9 = cn.create, b9 = sr.create, tf = Ye.create, h9 = wt.create, p9 = xa.create, m9 = Ye.createWithPreprocess, y9 = Pn.create, g9 = () => y0().optional(), _9 = () => g0().optional(), v9 = () => _0().optional(), w9 = {
  string: (e) => Me.create({ ...e, coerce: !0 }),
  number: (e) => Wt.create({ ...e, coerce: !0 }),
  boolean: (e) => Xr.create({
    ...e,
    coerce: !0
  }),
  bigint: (e) => Gt.create({ ...e, coerce: !0 }),
  date: (e) => Ea.create({ ...e, coerce: !0 })
}, E9 = V;
var j = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: Jr,
  setErrorMap: S4,
  getErrorMap: ls,
  makeIssue: bs,
  EMPTY_PATH: C4,
  addIssueToContext: P,
  ParseStatus: Ee,
  INVALID: V,
  DIRTY: b0,
  OK: Ce,
  isAborted: yi,
  isDirty: gi,
  isValid: hs,
  isAsync: ps,
  get util() {
    return ee;
  },
  get objectUtil() {
    return mi;
  },
  ZodParsedType: N,
  getParsedType: Lt,
  ZodType: G,
  ZodString: Me,
  ZodNumber: Wt,
  ZodBigInt: Gt,
  ZodBoolean: Xr,
  ZodDate: Ea,
  ZodSymbol: ms,
  ZodUndefined: Qr,
  ZodNull: en,
  ZodAny: nr,
  ZodUnknown: ha,
  ZodNever: Tt,
  ZodVoid: ys,
  ZodArray: qe,
  ZodObject: ie,
  ZodUnion: tn,
  ZodDiscriminatedUnion: Gs,
  ZodIntersection: an,
  ZodTuple: ft,
  ZodRecord: rn,
  ZodMap: gs,
  ZodSet: ka,
  ZodFunction: Ga,
  ZodLazy: nn,
  ZodLiteral: sn,
  ZodEnum: Yt,
  ZodNativeEnum: cn,
  ZodPromise: sr,
  ZodEffects: Ye,
  ZodTransformer: Ye,
  ZodOptional: wt,
  ZodNullable: xa,
  ZodDefault: on,
  ZodCatch: _s,
  ZodNaN: vs,
  BRAND: F4,
  ZodBranded: p0,
  ZodPipeline: Pn,
  custom: m0,
  Schema: G,
  ZodSchema: G,
  late: U4,
  get ZodFirstPartyTypeKind() {
    return z;
  },
  coerce: w9,
  any: W4,
  array: X4,
  bigint: M4,
  boolean: _0,
  date: H4,
  discriminatedUnion: a9,
  effect: tf,
  enum: u9,
  function: o9,
  instanceof: $4,
  intersection: r9,
  lazy: d9,
  literal: f9,
  map: c9,
  nan: z4,
  nativeEnum: l9,
  never: Y4,
  null: K4,
  nullable: p9,
  number: g0,
  object: Q4,
  oboolean: v9,
  onumber: _9,
  optional: h9,
  ostring: g9,
  pipeline: y9,
  preprocess: m9,
  promise: b9,
  record: s9,
  set: i9,
  strictObject: e9,
  string: y0,
  symbol: V4,
  transformer: tf,
  tuple: n9,
  undefined: q4,
  union: t9,
  unknown: G4,
  void: J4,
  NEVER: E9,
  ZodIssueCode: k,
  quotelessJson: T4,
  ZodError: Ve
});
const v0 = /^0x[0-9a-f]+$/i, w0 = /^\d+$/, k9 = j.string().nonempty("The short string cannot be empty").max(31, "The short string cannot exceed 31 characters").refine(
  (e) => !v0.test(e),
  "The shortString should not be a hex string"
).refine(
  (e) => !w0.test(e),
  "The shortString should not be an integer string"
), Xn = j.union([
  j.string().regex(
    v0,
    "Only hex, integers and bigint are supported in calldata"
  ),
  j.string().regex(
    w0,
    "Only hex, integers and bigint are supported in calldata"
  ),
  k9,
  j.number().int("Only hex, integers and bigint are supported in calldata"),
  j.bigint()
]), af = j.object({
  contractAddress: j.string(),
  entrypoint: j.string(),
  calldata: j.array(Xn).optional()
}), x9 = j.object({
  types: j.record(
    j.array(
      j.union([
        j.object({
          name: j.string(),
          type: j.string()
        }),
        j.object({
          name: j.string(),
          type: j.literal("merkletree"),
          contains: j.string()
        })
      ])
    )
  ),
  primaryType: j.string(),
  domain: j.record(j.unknown()),
  message: j.record(j.unknown())
}), rf = {
  enable: j.tuple([
    j.object({
      starknetVersion: j.union([j.literal("v3"), j.literal("v4")]).optional()
    }).optional()
  ]).or(j.tuple([])),
  addStarknetChain: j.tuple([
    j.object({
      id: j.string(),
      chainId: j.string(),
      chainName: j.string(),
      rpcUrls: j.array(j.string()).optional(),
      nativeCurrency: j.object({
        name: j.string(),
        symbol: j.string(),
        decimals: j.number()
      }).optional(),
      blockExplorerUrls: j.array(j.string()).optional()
    })
  ]),
  switchStarknetChain: j.tuple([
    j.object({
      chainId: j.string()
    })
  ]),
  watchAsset: j.tuple([
    j.object({
      type: j.literal("ERC20"),
      options: j.object({
        address: j.string(),
        symbol: j.string().optional(),
        decimals: j.number().optional(),
        image: j.string().optional(),
        name: j.string().optional()
      })
    })
  ]),
  execute: j.tuple([
    j.array(af).nonempty().or(af),
    j.array(j.any()).optional(),
    j.object({
      nonce: Xn.optional(),
      maxFee: Xn.optional(),
      version: Xn.optional()
    }).optional()
  ]),
  signMessage: j.tuple([x9])
};
function T9(e) {
  return e;
}
function S9(e) {
  return e.length === 0 ? T9 : e.length === 1 ? e[0] : function(t) {
    return e.reduce((a, r) => r(a), t);
  };
}
function C9(e) {
  return typeof e == "object" && e !== null && "subscribe" in e;
}
function Ys(e) {
  const t = {
    subscribe(a) {
      let r = null, n = !1, s = !1, c = !1;
      function i() {
        if (r === null) {
          c = !0;
          return;
        }
        s || (s = !0, typeof r == "function" ? r() : r && r.unsubscribe());
      }
      return r = e({
        next(o) {
          n || a.next?.(o);
        },
        error(o) {
          n || (n = !0, a.error?.(o), i());
        },
        complete() {
          n || (n = !0, a.complete?.(), i());
        }
      }), c && i(), {
        unsubscribe: i
      };
    },
    pipe(...a) {
      return S9(a)(t);
    }
  };
  return t;
}
function E0(e) {
  return (t) => {
    let a = 0, r = null;
    const n = [];
    function s() {
      r || (r = t.subscribe({
        next(i) {
          for (const o of n)
            o.next?.(i);
        },
        error(i) {
          for (const o of n)
            o.error?.(i);
        },
        complete() {
          for (const i of n)
            i.complete?.();
        }
      }));
    }
    function c() {
      if (a === 0 && r) {
        const i = r;
        r = null, i.unsubscribe();
      }
    }
    return {
      subscribe(i) {
        return a++, n.push(i), s(), {
          unsubscribe() {
            a--, c();
            const o = n.findIndex((d) => d === i);
            o > -1 && n.splice(o, 1);
          }
        };
      }
    };
  };
}
function A9(e) {
  return (t) => ({
    subscribe(a) {
      let r = 0;
      return t.subscribe({
        next(n) {
          a.next?.(e(n, r++));
        },
        error(n) {
          a.error?.(n);
        },
        complete() {
          a.complete?.();
        }
      });
    }
  });
}
function k0(e) {
  return (t) => ({
    subscribe(a) {
      return t.subscribe({
        next(r) {
          e.next?.(r), a.next?.(r);
        },
        error(r) {
          e.error?.(r), a.error?.(r);
        },
        complete() {
          e.complete?.(), a.complete?.();
        }
      });
    }
  });
}
let O9 = class x0 extends Error {
  constructor(t) {
    super(t), this.name = "ObservableAbortError", Object.setPrototypeOf(this, x0.prototype);
  }
};
function T0(e) {
  let t;
  return {
    promise: new Promise((a, r) => {
      let n = !1;
      function s() {
        n || (n = !0, r(new O9("This operation was aborted.")), c.unsubscribe());
      }
      const c = e.subscribe({
        next(i) {
          n = !0, a(i), s();
        },
        error(i) {
          n = !0, r(i), s();
        },
        complete() {
          n = !0, s();
        }
      });
      t = s;
    }),
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    abort: t
  };
}
const I9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  isObservable: C9,
  map: A9,
  observable: Ys,
  observableToPromise: T0,
  share: E0,
  tap: k0
}, Symbol.toStringTag, { value: "Module" }));
function S0(e) {
  return Ys((t) => {
    function a(r = 0, n = e.op) {
      const s = e.links[r];
      if (!s)
        throw new Error("No more links to execute - did you forget to add an ending link?");
      return s({
        op: n,
        next(c) {
          return a(r + 1, c);
        }
      });
    }
    return a().subscribe(t);
  });
}
function nf(e) {
  return Array.isArray(e) ? e : [
    e
  ];
}
function N9(e) {
  return (t) => {
    const a = nf(e.true).map((n) => n(t)), r = nf(e.false).map((n) => n(t));
    return (n) => Ys((s) => {
      const c = e.condition(n.op) ? a : r;
      return S0({
        op: n.op,
        links: c
      }).subscribe(s);
    });
  };
}
let R9 = class Qn extends Error {
  static from(t, a = {}) {
    return t instanceof Error ? t.name === "TRPCClientError" ? t : new Qn(t.message, {
      ...a,
      cause: t,
      result: null
    }) : new Qn(t.error.message ?? "", {
      ...a,
      cause: void 0,
      result: t
    });
  }
  constructor(t, a) {
    const r = a?.cause;
    super(t, {
      cause: r
    }), this.meta = a?.meta, this.cause = r, this.shape = a?.result?.error, this.data = a?.result?.error.data, this.name = "TRPCClientError", Object.setPrototypeOf(this, Qn.prototype);
  }
};
function C0(e) {
  const t = /* @__PURE__ */ Object.create(null);
  for (const a in e) {
    const r = e[a];
    t[r] = a;
  }
  return t;
}
const Js = {
  /**
  * Invalid JSON was received by the server.
  * An error occurred on the server while parsing the JSON text.
  */
  PARSE_ERROR: -32700,
  /**
  * The JSON sent is not a valid Request object.
  */
  BAD_REQUEST: -32600,
  /**
  * Internal JSON-RPC error.
  */
  INTERNAL_SERVER_ERROR: -32603,
  // Implementation specific errors
  UNAUTHORIZED: -32001,
  FORBIDDEN: -32003,
  NOT_FOUND: -32004,
  METHOD_NOT_SUPPORTED: -32005,
  TIMEOUT: -32008,
  CONFLICT: -32009,
  PRECONDITION_FAILED: -32012,
  PAYLOAD_TOO_LARGE: -32013,
  UNPROCESSABLE_CONTENT: -32022,
  TOO_MANY_REQUESTS: -32029,
  CLIENT_CLOSED_REQUEST: -32099
};
C0(Js);
C0(Js);
const P9 = {
  PARSE_ERROR: 400,
  BAD_REQUEST: 400,
  NOT_FOUND: 404,
  INTERNAL_SERVER_ERROR: 500,
  UNAUTHORIZED: 401,
  FORBIDDEN: 403,
  TIMEOUT: 408,
  CONFLICT: 409,
  CLIENT_CLOSED_REQUEST: 499,
  PRECONDITION_FAILED: 412,
  PAYLOAD_TOO_LARGE: 413,
  METHOD_NOT_SUPPORTED: 405,
  UNPROCESSABLE_CONTENT: 422,
  TOO_MANY_REQUESTS: 429
};
function L9(e) {
  return P9[e] ?? 500;
}
function A0(e) {
  const { code: t } = e;
  return L9(t);
}
const O0 = () => {
};
function I0(e, t) {
  return new Proxy(O0, {
    get(a, r) {
      if (!(typeof r != "string" || r === "then"))
        return I0(e, [
          ...t,
          r
        ]);
    },
    apply(a, r, n) {
      const s = t[t.length - 1] === "apply";
      return e({
        args: s ? n.length >= 2 ? n[1] : [] : n,
        path: s ? t.slice(0, -1) : t
      });
    }
  });
}
const Io = (e) => I0(e, []), No = (e) => new Proxy(O0, {
  get(t, a) {
    if (!(typeof a != "string" || a === "then"))
      return e(a);
  }
});
function j9(e) {
  const { path: t, error: a, config: r } = e, { code: n } = e.error, s = {
    message: a.message,
    code: Js[n],
    data: {
      code: n,
      httpStatus: A0(a)
    }
  };
  return r.isDev && typeof e.error.stack == "string" && (s.data.stack = e.error.stack), typeof t == "string" && (s.data.path = t), r.errorFormatter({
    ...e,
    shape: s
  });
}
function sf(e, t) {
  return "error" in t ? {
    ...t,
    error: e.transformer.output.serialize(t.error)
  } : "data" in t.result ? {
    ...t,
    result: {
      ...t.result,
      data: e.transformer.output.serialize(t.result.data)
    }
  } : t;
}
function Z9(e, t) {
  return Array.isArray(t) ? t.map((a) => sf(e, a)) : sf(e, t);
}
const D9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createFlatProxy: No,
  createRecursiveProxy: Io,
  getErrorShape: j9,
  transformTRPCResponse: Z9
}, Symbol.toStringTag, { value: "Module" })), B9 = {
  query: [
    "72e3ff",
    "3fb0d8"
  ],
  mutation: [
    "c5a3fc",
    "904dfc"
  ],
  subscription: [
    "ff49e1",
    "d83fbe"
  ]
};
function F9(e) {
  return typeof FormData > "u" ? !1 : e instanceof FormData;
}
const U9 = (e = console) => (t) => {
  const { direction: a, type: r, path: n, context: s, id: c } = t, [i, o] = B9[r], d = t.input, f = F9(d) ? Object.fromEntries(d) : d, u = `
    background-color: #${a === "up" ? i : o}; 
    color: ${a === "up" ? "black" : "white"};
    padding: 2px;
  `, l = [
    "%c",
    a === "up" ? ">>" : "<<",
    r,
    `#${c}`,
    `%c${n}%c`,
    "%O"
  ], b = [
    u,
    `${u}; font-weight: bold;`,
    `${u}; font-weight: normal;`
  ];
  t.direction === "up" ? b.push({
    input: f,
    context: s
  }) : b.push({
    input: f,
    result: t.result,
    elapsedMs: t.elapsedMs,
    context: s
  });
  const p = t.direction === "down" && t.result && (t.result instanceof Error || "error" in t.result.result) ? "error" : "log";
  e[p].apply(null, [
    l.join(" ")
  ].concat(b));
};
function $9(e = {}) {
  const { enabled: t = () => !0 } = e, { logger: a = U9(e.console) } = e;
  return () => ({ op: r, next: n }) => Ys((s) => {
    t({
      ...r,
      direction: "up"
    }) && a({
      ...r,
      direction: "up"
    });
    const c = Date.now();
    function i(o) {
      const d = Date.now() - c;
      t({
        ...r,
        direction: "down",
        result: o
      }) && a({
        ...r,
        direction: "down",
        elapsedMs: d,
        result: o
      });
    }
    return n(r).pipe(k0({
      next(o) {
        i(o);
      },
      error(o) {
        i(o);
      }
    })).subscribe(s);
  });
}
let z9 = class {
  $request({ type: e, input: t, path: a, context: r = {} }) {
    return S0({
      links: this.links,
      op: {
        id: ++this.requestId,
        type: e,
        path: a,
        input: t,
        context: r
      }
    }).pipe(E0());
  }
  requestAsPromise(e) {
    const t = this.$request(e), { promise: a, abort: r } = T0(t);
    return new Promise((n, s) => {
      e.signal?.addEventListener("abort", r), a.then((c) => {
        n(c.result.data);
      }).catch((c) => {
        s(R9.from(c));
      });
    });
  }
  query(e, t, a) {
    return this.requestAsPromise({
      type: "query",
      path: e,
      input: t,
      context: a?.context,
      signal: a?.signal
    });
  }
  mutation(e, t, a) {
    return this.requestAsPromise({
      type: "mutation",
      path: e,
      input: t,
      context: a?.context,
      signal: a?.signal
    });
  }
  subscription(e, t, a) {
    return this.$request({
      type: "subscription",
      path: e,
      input: t,
      context: a?.context
    }).subscribe({
      next(r) {
        r.result.type === "started" ? a.onStarted?.() : r.result.type === "stopped" ? a.onStopped?.() : a.onData?.(r.result.data);
      },
      error(r) {
        a.onError?.(r);
      },
      complete() {
        a.onComplete?.();
      }
    });
  }
  constructor(e) {
    this.requestId = 0;
    const t = (() => {
      const a = e.transformer;
      return a ? "input" in a ? e.transformer : {
        input: a,
        output: a
      } : {
        input: {
          serialize: (r) => r,
          deserialize: (r) => r
        },
        output: {
          serialize: (r) => r,
          deserialize: (r) => r
        }
      };
    })();
    this.runtime = {
      transformer: {
        serialize: (a) => t.input.serialize(a),
        deserialize: (a) => t.output.deserialize(a)
      },
      combinedTransformer: t
    }, this.links = e.links.map((a) => a(this.runtime));
  }
};
const M9 = {
  query: "query",
  mutate: "mutation",
  subscribe: "subscription"
}, H9 = (e) => M9[e];
function V9(e) {
  return No((t) => e.hasOwnProperty(t) ? e[t] : Io(({ path: a, args: r }) => {
    const n = [
      t,
      ...a
    ], s = H9(n.pop()), c = n.join(".");
    return e[s](c, ...r);
  }));
}
function q9(e) {
  const t = new z9(e);
  return V9(t);
}
function K9(e) {
  return !!e && !Array.isArray(e) && typeof e == "object";
}
function W9(e) {
  if (e instanceof cr)
    return e;
  const t = new cr({
    code: "INTERNAL_SERVER_ERROR",
    cause: e
  });
  return e instanceof Error && e.stack && (t.stack = e.stack), t;
}
class G9 extends Error {
}
function Y9(e) {
  if (e instanceof Error)
    return e;
  const t = typeof e;
  if (!(t === "undefined" || t === "function" || e === null)) {
    if (t !== "object")
      return new Error(String(e));
    if (K9(e)) {
      const a = new G9();
      for (const r in e)
        a[r] = e[r];
      return a;
    }
  }
}
class cr extends Error {
  constructor(t) {
    const a = Y9(t.cause), r = t.message ?? a?.message ?? t.code;
    super(r, {
      cause: a
    }), this.code = t.code, this.name = this.constructor.name;
  }
}
function J9(e) {
  return "input" in e ? e : {
    input: e,
    output: e
  };
}
const jr = {
  _default: !0,
  input: {
    serialize: (e) => e,
    deserialize: (e) => e
  },
  output: {
    serialize: (e) => e,
    deserialize: (e) => e
  }
}, Zr = ({ shape: e }) => e;
function X9(e) {
  return Object.assign(/* @__PURE__ */ Object.create(null), e);
}
const Q9 = [
  "query",
  "mutation",
  "subscription"
];
function e8(e) {
  return "router" in e._def;
}
const t8 = {
  _ctx: null,
  _errorShape: null,
  _meta: null,
  queries: {},
  mutations: {},
  subscriptions: {},
  errorFormatter: Zr,
  transformer: jr
}, a8 = [
  /**
  * Then is a reserved word because otherwise we can't return a promise that returns a Proxy
  * since JS will think that `.then` is something that exists
  */
  "then"
];
function N0(e) {
  return function(t) {
    const a = new Set(Object.keys(t).filter((c) => a8.includes(c)));
    if (a.size > 0)
      throw new Error("Reserved words used in `router({})` call: " + Array.from(a).join(", "));
    const r = X9({});
    function n(c, i = "") {
      for (const [o, d] of Object.entries(c ?? {})) {
        const f = `${i}${o}`;
        if (e8(d)) {
          n(d._def.procedures, `${f}.`);
          continue;
        }
        if (r[f])
          throw new Error(`Duplicate key: ${f}`);
        r[f] = d;
      }
    }
    n(t);
    const s = {
      _config: e,
      router: !0,
      procedures: r,
      ...t8,
      record: t,
      queries: Object.entries(r).filter((c) => c[1]._def.query).reduce((c, [i, o]) => ({
        ...c,
        [i]: o
      }), {}),
      mutations: Object.entries(r).filter((c) => c[1]._def.mutation).reduce((c, [i, o]) => ({
        ...c,
        [i]: o
      }), {}),
      subscriptions: Object.entries(r).filter((c) => c[1]._def.subscription).reduce((c, [i, o]) => ({
        ...c,
        [i]: o
      }), {})
    };
    return {
      ...t,
      _def: s,
      createCaller(c) {
        return Io(({ path: i, args: o }) => {
          if (i.length === 1 && Q9.includes(i[0]))
            return r8({
              procedures: s.procedures,
              path: o[0],
              rawInput: o[1],
              ctx: c,
              type: i[0]
            });
          const d = i.join("."), f = s.procedures[d];
          let u = "query";
          return f._def.mutation ? u = "mutation" : f._def.subscription && (u = "subscription"), f({
            path: d,
            rawInput: o[0],
            ctx: c,
            type: u
          });
        });
      },
      getErrorShape(c) {
        const { path: i, error: o } = c, { code: d } = c.error, f = {
          message: o.message,
          code: Js[d],
          data: {
            code: d,
            httpStatus: A0(o)
          }
        };
        return e.isDev && typeof c.error.stack == "string" && (f.data.stack = c.error.stack), typeof i == "string" && (f.data.path = i), this._def._config.errorFormatter({
          ...c,
          shape: f
        });
      }
    };
  };
}
function r8(e) {
  const { type: t, path: a } = e;
  if (!(a in e.procedures) || !e.procedures[a]?._def[t])
    throw new cr({
      code: "NOT_FOUND",
      message: `No "${t}"-procedure on path "${a}"`
    });
  const r = e.procedures[a];
  return r(e);
}
const cf = typeof window > "u" || "Deno" in window || globalThis.process?.env?.NODE_ENV === "test" || !!globalThis.process?.env?.JEST_WORKER_ID || !!globalThis.process?.env?.VITEST_WORKER_ID;
function of(e) {
  const t = e;
  if (typeof t == "function")
    return t;
  if (typeof t.parseAsync == "function")
    return t.parseAsync.bind(t);
  if (typeof t.parse == "function")
    return t.parse.bind(t);
  if (typeof t.validateSync == "function")
    return t.validateSync.bind(t);
  if (typeof t.create == "function")
    return t.create.bind(t);
  if (typeof t.assert == "function")
    return (a) => (t.assert(a), a);
  throw new Error("Could not find a validator fn");
}
function R0(e, ...t) {
  const a = Object.assign(/* @__PURE__ */ Object.create(null), e);
  for (const r of t)
    for (const n in r) {
      if (n in a && a[n] !== r[n])
        throw new Error(`Duplicate key ${n}`);
      a[n] = r[n];
    }
  return a;
}
function n8() {
  function e(a) {
    return {
      _middlewares: a,
      unstable_pipe(r) {
        const n = "_middlewares" in r ? r._middlewares : [
          r
        ];
        return e([
          ...a,
          ...n
        ]);
      }
    };
  }
  function t(a) {
    return e([
      a
    ]);
  }
  return t;
}
function df(e) {
  return e && typeof e == "object" && !Array.isArray(e);
}
function s8(e) {
  const t = async ({ next: a, rawInput: r, input: n }) => {
    let s;
    try {
      s = await e(r);
    } catch (i) {
      throw new cr({
        code: "BAD_REQUEST",
        cause: i
      });
    }
    const c = df(n) && df(s) ? {
      ...n,
      ...s
    } : s;
    return a({
      input: c
    });
  };
  return t._type = "input", t;
}
function c8(e) {
  const t = async ({ next: a }) => {
    const r = await a();
    if (!r.ok)
      return r;
    try {
      const n = await e(r.data);
      return {
        ...r,
        data: n
      };
    } catch (n) {
      throw new cr({
        message: "Output validation failed",
        code: "INTERNAL_SERVER_ERROR",
        cause: n
      });
    }
  };
  return t._type = "output", t;
}
const P0 = "middlewareMarker";
function Fa(e, t) {
  const { middlewares: a = [], inputs: r, meta: n, ...s } = t;
  return L0({
    ...R0(e, s),
    inputs: [
      ...e.inputs,
      ...r ?? []
    ],
    middlewares: [
      ...e.middlewares,
      ...a
    ],
    meta: e.meta && n ? {
      ...e.meta,
      ...n
    } : n ?? e.meta
  });
}
function L0(e = {}) {
  const t = {
    inputs: [],
    middlewares: [],
    ...e
  };
  return {
    _def: t,
    input(a) {
      const r = of(a);
      return Fa(t, {
        inputs: [
          a
        ],
        middlewares: [
          s8(r)
        ]
      });
    },
    output(a) {
      const r = of(a);
      return Fa(t, {
        output: a,
        middlewares: [
          c8(r)
        ]
      });
    },
    meta(a) {
      return Fa(t, {
        meta: a
      });
    },
    /**
    * @deprecated
    * This functionality is deprecated and will be removed in the next major version.
    */
    unstable_concat(a) {
      return Fa(t, a._def);
    },
    use(a) {
      const r = "_middlewares" in a ? a._middlewares : [
        a
      ];
      return Fa(t, {
        middlewares: r
      });
    },
    query(a) {
      return jc({
        ...t,
        query: !0
      }, a);
    },
    mutation(a) {
      return jc({
        ...t,
        mutation: !0
      }, a);
    },
    subscription(a) {
      return jc({
        ...t,
        subscription: !0
      }, a);
    }
  };
}
function jc(e, t) {
  const a = Fa(e, {
    resolver: t,
    middlewares: [
      async function(r) {
        const n = await t(r);
        return {
          marker: P0,
          ok: !0,
          data: n,
          ctx: r.ctx
        };
      }
    ]
  });
  return o8(a._def);
}
const i8 = `
If you want to call this function on the server, you do the following:
This is a client-only function.

const caller = appRouter.createCaller({
  /* ... your context */
});

const result = await caller.call('myProcedure', input);
`.trim();
function o8(e) {
  const t = async function(a) {
    if (!a || !("rawInput" in a))
      throw new Error(i8);
    const r = async (s = {
      index: 0,
      ctx: a.ctx
    }) => {
      try {
        const c = e.middlewares[s.index];
        return await c({
          ctx: s.ctx,
          type: a.type,
          path: a.path,
          rawInput: s.rawInput ?? a.rawInput,
          meta: e.meta,
          input: s.input,
          next(i) {
            const o = i;
            return r({
              index: s.index + 1,
              ctx: o && "ctx" in o ? {
                ...s.ctx,
                ...o.ctx
              } : s.ctx,
              input: o && "input" in o ? o.input : s.input,
              rawInput: o && "rawInput" in o ? o.rawInput : s.rawInput
            });
          }
        });
      } catch (c) {
        return {
          ok: !1,
          error: W9(c),
          marker: P0
        };
      }
    }, n = await r();
    if (!n)
      throw new cr({
        code: "INTERNAL_SERVER_ERROR",
        message: "No result from middlewares - did you forget to `return next()`?"
      });
    if (!n.ok)
      throw n.error;
    return n.data;
  };
  return t._def = e, t.meta = e.meta, t;
}
function d8(...e) {
  const t = R0({}, ...e.map((n) => n._def.record)), a = e.reduce((n, s) => {
    if (s._def._config.errorFormatter && s._def._config.errorFormatter !== Zr) {
      if (n !== Zr && n !== s._def._config.errorFormatter)
        throw new Error("You seem to have several error formatters");
      return s._def._config.errorFormatter;
    }
    return n;
  }, Zr), r = e.reduce((n, s) => {
    if (s._def._config.transformer && s._def._config.transformer !== jr) {
      if (n !== jr && n !== s._def._config.transformer)
        throw new Error("You seem to have several transformers");
      return s._def._config.transformer;
    }
    return n;
  }, jr);
  return N0({
    errorFormatter: a,
    transformer: r,
    isDev: e.some((n) => n._def._config.isDev),
    allowOutsideOfServer: e.some((n) => n._def._config.allowOutsideOfServer),
    isServer: e.some((n) => n._def._config.isServer),
    $types: e[0]?._def._config.$types
  })(t);
}
class ws {
  context() {
    return new ws();
  }
  meta() {
    return new ws();
  }
  create(t) {
    return u8()(t);
  }
}
const f8 = new ws();
function u8() {
  return function(e) {
    const t = e?.errorFormatter ?? Zr, a = {
      transformer: J9(e?.transformer ?? jr),
      isDev: e?.isDev ?? globalThis.process?.env?.NODE_ENV !== "production",
      allowOutsideOfServer: e?.allowOutsideOfServer ?? !1,
      errorFormatter: t,
      isServer: e?.isServer ?? cf,
      /**
      * @internal
      */
      $types: No((r) => {
        throw new Error(`Tried to access "$types.${r}" which is not available at runtime`);
      })
    };
    if (!(e?.isServer ?? cf) && e?.allowOutsideOfServer !== !0)
      throw new Error("You're trying to use @trpc/server in a non-server environment. This is not supported by default.");
    return {
      /**
      * These are just types, they can't be used
      * @internal
      */
      _config: a,
      /**
      * Builder object for creating procedures
      */
      procedure: L0({
        meta: e?.defaultMeta
      }),
      /**
      * Create reusable middlewares
      */
      middleware: n8(),
      /**
      * Create a router
      */
      router: N0(a),
      /**
      * Merge Routers
      */
      mergeRouters: d8
    };
  };
}
var vi = {}, Xs = {}, yr = {}, me = {};
const gr = /* @__PURE__ */ zu(I9);
var Ro = {}, j0 = gr;
function Z0(e) {
  return j0.observable((t) => {
    function a(r = 0, n = e.op) {
      const s = e.links[r];
      if (!s)
        throw new Error("No more links to execute - did you forget to add an ending link?");
      return s({
        op: n,
        next(c) {
          return a(r + 1, c);
        }
      });
    }
    return a().subscribe(t);
  });
}
function ff(e) {
  return Array.isArray(e) ? e : [
    e
  ];
}
function l8(e) {
  return (t) => {
    const a = ff(e.true).map((n) => n(t)), r = ff(e.false).map((n) => n(t));
    return (n) => j0.observable((s) => {
      const c = e.condition(n.op) ? a : r;
      return Z0({
        op: n.op,
        links: c
      }).subscribe(s);
    });
  };
}
Ro.createChain = Z0;
Ro.splitLink = l8;
var _r = {};
class zt extends Error {
  static from(t, a = {}) {
    return t instanceof Error ? t.name === "TRPCClientError" ? t : new zt(t.message, {
      ...a,
      cause: t,
      result: null
    }) : new zt(t.error.message ?? "", {
      ...a,
      cause: void 0,
      result: t
    });
  }
  constructor(t, a) {
    const r = a?.cause;
    super(t, {
      cause: r
    }), this.meta = a?.meta, this.cause = r, this.shape = a?.result?.error, this.data = a?.result?.error.data, this.name = "TRPCClientError", Object.setPrototypeOf(this, zt.prototype);
  }
}
function uf(e) {
  return !!e && !Array.isArray(e) && typeof e == "object";
}
function b8(e, t) {
  if ("error" in e) {
    const a = t.transformer.deserialize(e.error);
    return {
      ok: !1,
      error: {
        ...e,
        error: a
      }
    };
  }
  return {
    ok: !0,
    result: {
      ...e.result,
      ...(!e.result.type || e.result.type === "data") && {
        type: "data",
        data: t.transformer.deserialize(e.result.data)
      }
    }
  };
}
function h8(e, t) {
  let a;
  try {
    a = b8(e, t);
  } catch {
    throw new zt("Unable to transform response from server");
  }
  if (!a.ok && (!uf(a.error.error) || typeof a.error.error.code != "number"))
    throw new zt("Badly formatted response from server");
  if (a.ok && !uf(a.result))
    throw new zt("Badly formatted response from server");
  return a;
}
_r.TRPCClientError = zt;
_r.transformResult = h8;
const p8 = /* @__PURE__ */ zu(D9);
var ht = {};
const wi = (e) => typeof e == "function";
function lf(e, t) {
  return wi(e.bind) ? e.bind(t) : e;
}
function D0(e) {
  if (e)
    return e;
  if (typeof window < "u" && wi(window.fetch))
    return lf(window.fetch, window);
  if (typeof globalThis < "u" && wi(globalThis.fetch))
    return lf(globalThis.fetch, globalThis);
  throw new Error("No fetch implementation found");
}
function m8(e) {
  return e || (typeof window < "u" && window.AbortController ? window.AbortController : typeof globalThis < "u" && globalThis.AbortController ? globalThis.AbortController : null);
}
function y8(e) {
  return {
    url: e.url,
    fetch: D0(e.fetch),
    AbortController: m8(e.AbortController)
  };
}
function g8(e) {
  const t = {};
  for (let a = 0; a < e.length; a++) {
    const r = e[a];
    t[a] = r;
  }
  return t;
}
const _8 = {
  query: "GET",
  mutation: "POST"
};
function B0(e) {
  return "input" in e ? e.runtime.transformer.serialize(e.input) : g8(e.inputs.map((t) => e.runtime.transformer.serialize(t)));
}
const F0 = (e) => {
  let t = e.url + "/" + e.path;
  const a = [];
  if ("inputs" in e && a.push("batch=1"), e.type === "query") {
    const r = B0(e);
    r !== void 0 && a.push(`input=${encodeURIComponent(JSON.stringify(r))}`);
  }
  return a.length && (t += "?" + a.join("&")), t;
}, U0 = (e) => {
  if (e.type === "query")
    return;
  const t = B0(e);
  return t !== void 0 ? JSON.stringify(t) : void 0;
}, v8 = (e) => z0({
  ...e,
  contentTypeHeader: "application/json",
  getUrl: F0,
  getBody: U0
});
async function $0(e, t) {
  const a = e.getUrl(e), r = e.getBody(e), { type: n } = e, s = await e.headers();
  /* istanbul ignore if -- @preserve */
  if (n === "subscription")
    throw new Error("Subscriptions should use wsLink");
  return e.fetch(a, {
    method: _8[n],
    signal: t?.signal,
    body: r,
    headers: {
      ...e.contentTypeHeader ? {
        "content-type": e.contentTypeHeader
      } : {},
      ...e.batchModeHeader ? {
        "trpc-batch-mode": e.batchModeHeader
      } : {},
      ...s
    }
  });
}
function z0(e) {
  const t = e.AbortController ? new e.AbortController() : null, a = {};
  return {
    promise: new Promise((r, n) => {
      $0(e, t).then((s) => (a.response = s, s.json())).then((s) => {
        r({
          json: s,
          meta: a
        });
      }).catch(n);
    }),
    cancel: () => {
      t?.abort();
    }
  };
}
ht.fetchHTTPResponse = $0;
ht.getBody = U0;
ht.getFetch = D0;
ht.getUrl = F0;
ht.httpRequest = z0;
ht.jsonHttpRequester = v8;
ht.resolveHTTPLinkOptions = y8;
var Po = {}, w8 = gr, Zc = _r, Ei = ht;
const Dc = () => {
  throw new Error("Something went wrong. Please submit an issue at https://github.com/trpc/trpc/issues/new");
};
function Bc(e) {
  let t = null, a = null;
  const r = () => {
    clearTimeout(a), a = null, t = null;
  };
  function n(i) {
    const o = [
      []
    ];
    let d = 0;
    for (; ; ) {
      const f = i[d];
      if (!f)
        break;
      const u = o[o.length - 1];
      if (f.aborted) {
        f.reject?.(new Error("Aborted")), d++;
        continue;
      }
      if (e.validate(u.concat(f).map((l) => l.key))) {
        u.push(f), d++;
        continue;
      }
      if (u.length === 0) {
        f.reject?.(new Error("Input is too big for a single dispatch")), d++;
        continue;
      }
      o.push([]);
    }
    return o;
  }
  function s() {
    const i = n(t);
    r();
    for (const o of i) {
      if (!o.length)
        continue;
      const d = {
        items: o,
        cancel: Dc
      };
      for (const b of o)
        b.batch = d;
      const f = (b, p) => {
        const h = d.items[b];
        h.resolve?.(p), h.batch = null, h.reject = null, h.resolve = null;
      }, { promise: u, cancel: l } = e.fetch(d.items.map((b) => b.key), f);
      d.cancel = l, u.then((b) => {
        for (let p = 0; p < b.length; p++) {
          const h = b[p];
          f(p, h);
        }
        for (let p = 0; p < d.items.length; p++) {
          const h = d.items[p];
          h.reject?.(new Error("Missing result")), h.batch = null;
        }
      }).catch((b) => {
        for (const p of d.items)
          p.reject?.(b), p.batch = null;
      });
    }
  }
  function c(i) {
    const o = {
      aborted: !1,
      key: i,
      batch: null,
      resolve: Dc,
      reject: Dc
    }, d = new Promise((f, u) => {
      o.reject = u, o.resolve = f, t || (t = []), t.push(o);
    });
    return a || (a = setTimeout(s)), {
      promise: d,
      cancel: () => {
        o.aborted = !0, o.batch?.items.every((f) => f.aborted) && (o.batch.cancel(), o.batch = null);
      }
    };
  }
  return {
    load: c
  };
}
function M0(e) {
  return function(t) {
    const a = Ei.resolveHTTPLinkOptions(t), r = t.maxURLLength || 1 / 0;
    return (n) => {
      const s = (f) => {
        const u = (b) => {
          if (r === 1 / 0)
            return !0;
          const p = b.map((m) => m.path).join(","), h = b.map((m) => m.input);
          return Ei.getUrl({
            ...a,
            runtime: n,
            type: f,
            path: p,
            inputs: h
          }).length <= r;
        }, l = e({
          ...a,
          runtime: n,
          type: f,
          opts: t
        });
        return {
          validate: u,
          fetch: l
        };
      }, c = Bc(s("query")), i = Bc(s("mutation")), o = Bc(s("subscription")), d = {
        query: c,
        subscription: o,
        mutation: i
      };
      return ({ op: f }) => w8.observable((u) => {
        const l = d[f.type], { promise: b, cancel: p } = l.load(f);
        return b.then((h) => {
          const m = Zc.transformResult(h.json, n);
          if (!m.ok) {
            u.error(Zc.TRPCClientError.from(m.error, {
              meta: h.meta
            }));
            return;
          }
          u.next({
            context: h.meta,
            result: m.result
          }), u.complete();
        }).catch((h) => u.error(Zc.TRPCClientError.from(h))), () => p();
      });
    };
  };
}
const E8 = (e) => (t) => {
  const a = t.map((c) => c.path).join(","), r = t.map((c) => c.input), { promise: n, cancel: s } = Ei.jsonHttpRequester({
    ...e,
    path: a,
    inputs: r,
    headers() {
      return e.opts.headers ? typeof e.opts.headers == "function" ? e.opts.headers({
        opList: t
      }) : e.opts.headers : {};
    }
  });
  return {
    promise: n.then((c) => (Array.isArray(c.json) ? c.json : t.map(() => c.json)).map((i) => ({
      meta: c.meta,
      json: i
    }))),
    cancel: s
  };
}, k8 = M0(E8);
Po.createHTTPBatchLink = M0;
Po.httpBatchLink = k8;
var Qs = {};
Object.defineProperty(Qs, "__esModule", { value: !0 });
var x8 = gr, Fc = _r, H0 = ht;
function V0(e) {
  return (t) => {
    const a = H0.resolveHTTPLinkOptions(t);
    return (r) => ({ op: n }) => x8.observable((s) => {
      const { path: c, input: i, type: o } = n, { promise: d, cancel: f } = e.requester({
        ...a,
        runtime: r,
        type: o,
        path: c,
        input: i,
        headers() {
          return t.headers ? typeof t.headers == "function" ? t.headers({
            op: n
          }) : t.headers : {};
        }
      });
      return d.then((u) => {
        const l = Fc.transformResult(u.json, r);
        if (!l.ok) {
          s.error(Fc.TRPCClientError.from(l.error, {
            meta: u.meta
          }));
          return;
        }
        s.next({
          context: u.meta,
          result: l.result
        }), s.complete();
      }).catch((u) => s.error(Fc.TRPCClientError.from(u))), () => {
        f();
      };
    });
  };
}
const T8 = V0({
  requester: H0.jsonHttpRequester
});
Qs.httpLink = T8;
Qs.httpLinkFactory = V0;
var Lo = {};
Object.defineProperty(Lo, "__esModule", { value: !0 });
var bf = gr;
const S8 = {
  query: [
    "72e3ff",
    "3fb0d8"
  ],
  mutation: [
    "c5a3fc",
    "904dfc"
  ],
  subscription: [
    "ff49e1",
    "d83fbe"
  ]
};
function C8(e) {
  return typeof FormData > "u" ? !1 : e instanceof FormData;
}
const A8 = (e = console) => (t) => {
  const { direction: a, type: r, path: n, context: s, id: c } = t, [i, o] = S8[r], d = t.input, f = C8(d) ? Object.fromEntries(d) : d, u = `
    background-color: #${a === "up" ? i : o}; 
    color: ${a === "up" ? "black" : "white"};
    padding: 2px;
  `, l = [
    "%c",
    a === "up" ? ">>" : "<<",
    r,
    `#${c}`,
    `%c${n}%c`,
    "%O"
  ], b = [
    u,
    `${u}; font-weight: bold;`,
    `${u}; font-weight: normal;`
  ];
  t.direction === "up" ? b.push({
    input: f,
    context: s
  }) : b.push({
    input: f,
    result: t.result,
    elapsedMs: t.elapsedMs,
    context: s
  });
  const p = t.direction === "down" && t.result && (t.result instanceof Error || "error" in t.result.result) ? "error" : "log";
  e[p].apply(null, [
    l.join(" ")
  ].concat(b));
};
function O8(e = {}) {
  const { enabled: t = () => !0 } = e, { logger: a = A8(e.console) } = e;
  return () => ({ op: r, next: n }) => bf.observable((s) => {
    t({
      ...r,
      direction: "up"
    }) && a({
      ...r,
      direction: "up"
    });
    const c = Date.now();
    function i(o) {
      const d = Date.now() - c;
      t({
        ...r,
        direction: "down",
        result: o
      }) && a({
        ...r,
        direction: "down",
        elapsedMs: d,
        result: o
      });
    }
    return n(r).pipe(bf.tap({
      next(o) {
        i(o);
      },
      error(o) {
        i(o);
      }
    })).subscribe(s);
  });
}
Lo.loggerLink = O8;
var ec = {};
Object.defineProperty(ec, "__esModule", { value: !0 });
var I8 = gr, ki = _r;
/* istanbul ignore next -- @preserve */
const N8 = (e) => e === 0 ? 0 : Math.min(1e3 * 2 ** e, 3e4);
function R8(e) {
  const { url: t, WebSocket: a = WebSocket, retryDelayMs: r = N8, onOpen: n, onClose: s } = e;
  /* istanbul ignore next -- @preserve */
  if (!a)
    throw new Error("No WebSocket implementation found - you probably don't want to use this on the server, but if you do you need to pass a `WebSocket`-ponyfill");
  let c = [];
  const i = /* @__PURE__ */ Object.create(null);
  let o = 0, d = null, f = null, u = T(), l = "connecting";
  function b() {
    l !== "open" || d || (d = setTimeout(() => {
      d = null, c.length === 1 ? u.send(JSON.stringify(c.pop())) : u.send(JSON.stringify(c)), c = [];
    }));
  }
  function p() {
    if (f || l === "closed")
      return;
    const _ = r(o++);
    m(_);
  }
  function h() {
    l = "connecting";
    const _ = u;
    u = T(), y(_);
  }
  function m(_) {
    f || (l = "connecting", f = setTimeout(h, _));
  }
  function y(_) {
    Object.values(i).some((w) => w.ws === _) || _.close();
  }
  function v() {
    Object.values(i).forEach((_) => {
      _.type === "subscription" && _.callbacks.complete();
    });
  }
  function g(_) {
    c.some((w) => w.id === _.op.id) || Z(_.op, _.callbacks);
  }
  function T() {
    const _ = typeof t == "function" ? t() : t, w = new a(_);
    clearTimeout(f), f = null, w.addEventListener("open", () => {
      /* istanbul ignore next -- @preserve */
      w === u && (o = 0, l = "open", n?.(), b());
    }), w.addEventListener("error", () => {
      w === u && p();
    });
    const O = (S) => {
      if (S.method === "reconnect" && w === u) {
        l === "open" && s?.(), h();
        for (const C of Object.values(i))
          C.type === "subscription" && g(C);
      }
    }, I = (S) => {
      const C = S.id !== null && i[S.id];
      if (C) {
        if (C.callbacks.next?.(S), C.ws !== u && w === u) {
          const X = C.ws;
          C.ws = u, y(X);
        }
        "result" in S && S.result.type === "stopped" && w === u && C.callbacks.complete();
      }
    };
    return w.addEventListener("message", ({ data: S }) => {
      const C = JSON.parse(S);
      "method" in C ? O(C) : I(C), (w !== u || l === "closed") && y(w);
    }), w.addEventListener("close", ({ code: S }) => {
      l === "open" && s?.({
        code: S
      }), u === w && p();
      for (const [C, X] of Object.entries(i))
        if (X.ws === w) {
          if (l === "closed") {
            delete i[C], X.callbacks.complete?.();
            continue;
          }
          X.type === "subscription" ? g(X) : (delete i[C], X.callbacks.error?.(ki.TRPCClientError.from(new jo("WebSocket closed prematurely"))));
        }
    }), w;
  }
  function Z(_, w) {
    const { type: O, input: I, path: S, id: C } = _, X = {
      id: C,
      method: O,
      params: {
        input: I,
        path: S
      }
    };
    return i[C] = {
      ws: u,
      type: O,
      callbacks: w,
      op: _
    }, c.push(X), b(), () => {
      const ne = i[C]?.callbacks;
      delete i[C], c = c.filter((D) => D.id !== C), ne?.complete?.(), u.readyState === a.OPEN && _.type === "subscription" && (c.push({
        id: C,
        method: "subscription.stop"
      }), b());
    };
  }
  return {
    close: () => {
      l = "closed", s?.(), v(), y(u), clearTimeout(f), f = null;
    },
    request: Z,
    getConnection() {
      return u;
    }
  };
}
class jo extends Error {
  constructor(t) {
    super(t), this.name = "TRPCWebSocketClosedError", Object.setPrototypeOf(this, jo.prototype);
  }
}
function P8(e) {
  return (t) => {
    const { client: a } = e;
    return ({ op: r }) => I8.observable((n) => {
      const { type: s, path: c, id: i, context: o } = r, d = t.transformer.serialize(r.input), f = a.request({
        type: s,
        path: c,
        input: d,
        id: i,
        context: o
      }, {
        error(u) {
          n.error(u), f();
        },
        complete() {
          n.complete();
        },
        next(u) {
          const l = ki.transformResult(u, t);
          if (!l.ok) {
            n.error(ki.TRPCClientError.from(l.error));
            return;
          }
          n.next({
            result: l.result
          }), r.type !== "subscription" && (f(), n.complete());
        }
      });
      return () => {
        f();
      };
    });
  };
}
ec.createWSClient = R8;
ec.wsLink = P8;
Object.defineProperty(me, "__esModule", { value: !0 });
var hf = gr, q0 = Ro, K0 = _r, pf = p8, Dr = ht, W0 = Po, Zo = Qs, L8 = Lo, G0 = ec;
class Do {
  $request({ type: t, input: a, path: r, context: n = {} }) {
    return q0.createChain({
      links: this.links,
      op: {
        id: ++this.requestId,
        type: t,
        path: r,
        input: a,
        context: n
      }
    }).pipe(hf.share());
  }
  requestAsPromise(t) {
    const a = this.$request(t), { promise: r, abort: n } = hf.observableToPromise(a);
    return new Promise((s, c) => {
      t.signal?.addEventListener("abort", n), r.then((i) => {
        s(i.result.data);
      }).catch((i) => {
        c(K0.TRPCClientError.from(i));
      });
    });
  }
  query(t, a, r) {
    return this.requestAsPromise({
      type: "query",
      path: t,
      input: a,
      context: r?.context,
      signal: r?.signal
    });
  }
  mutation(t, a, r) {
    return this.requestAsPromise({
      type: "mutation",
      path: t,
      input: a,
      context: r?.context,
      signal: r?.signal
    });
  }
  subscription(t, a, r) {
    return this.$request({
      type: "subscription",
      path: t,
      input: a,
      context: r?.context
    }).subscribe({
      next(n) {
        n.result.type === "started" ? r.onStarted?.() : n.result.type === "stopped" ? r.onStopped?.() : r.onData?.(n.result.data);
      },
      error(n) {
        r.onError?.(n);
      },
      complete() {
        r.onComplete?.();
      }
    });
  }
  constructor(t) {
    this.requestId = 0;
    const a = (() => {
      const r = t.transformer;
      return r ? "input" in r ? t.transformer : {
        input: r,
        output: r
      } : {
        input: {
          serialize: (n) => n,
          deserialize: (n) => n
        },
        output: {
          serialize: (n) => n,
          deserialize: (n) => n
        }
      };
    })();
    this.runtime = {
      transformer: {
        serialize: (r) => a.input.serialize(r),
        deserialize: (r) => a.output.deserialize(r)
      },
      combinedTransformer: a
    }, this.links = t.links.map((r) => r(this.runtime));
  }
}
function j8(e) {
  return new Do(e);
}
function Z8(e) {
  return new Do(e);
}
const D8 = {
  query: "query",
  mutate: "mutation",
  subscribe: "subscription"
}, Y0 = (e) => D8[e];
function J0(e) {
  return pf.createFlatProxy((t) => e.hasOwnProperty(t) ? e[t] : pf.createRecursiveProxy(({ path: a, args: r }) => {
    const n = [
      t,
      ...a
    ], s = Y0(n.pop()), c = n.join(".");
    return e[s](c, ...r);
  }));
}
function B8(e) {
  const t = new Do(e);
  return J0(t);
}
function F8(e) {
  if (e)
    return e;
  if (typeof window < "u" && window.TextDecoder)
    return new window.TextDecoder();
  if (typeof globalThis < "u" && globalThis.TextDecoder)
    return new globalThis.TextDecoder();
  throw new Error("No TextDecoder implementation found");
}
async function U8(e) {
  const t = e.parse ?? JSON.parse, a = (r) => {
    if (e.signal?.aborted || !r || r === "}")
      return;
    const n = r.indexOf(":"), s = r.substring(2, n - 1), c = r.substring(n + 1);
    e.onSingle(Number(s), t(c));
  };
  await $8(e.readableStream, a, e.textDecoder);
}
async function $8(e, t, a) {
  let r = "";
  const n = (s) => {
    const c = a.decode(s).split(`
`);
    if (c.length === 1)
      r += c[0];
    else if (c.length > 1) {
      t(r + c[0]);
      for (let i = 1; i < c.length - 1; i++)
        t(c[i]);
      r = c[c.length - 1];
    }
  };
  "getReader" in e ? await M8(e, n) : await z8(e, n), t(r);
}
function z8(e, t) {
  return new Promise((a) => {
    e.on("data", t), e.on("end", a);
  });
}
async function M8(e, t) {
  const a = e.getReader();
  let r = await a.read();
  for (; !r.done; )
    t(r.value), r = await a.read();
}
const H8 = (e, t) => {
  const a = e.AbortController ? new e.AbortController() : null, r = Dr.fetchHTTPResponse({
    ...e,
    contentTypeHeader: "application/json",
    batchModeHeader: "stream",
    getUrl: Dr.getUrl,
    getBody: Dr.getBody
  }, a), n = () => a?.abort(), s = r.then(async (c) => {
    if (!c.body)
      throw new Error("Received response without body");
    const i = {
      response: c
    };
    return U8({
      readableStream: c.body,
      onSingle: t,
      parse: (o) => ({
        json: JSON.parse(o),
        meta: i
      }),
      signal: a?.signal,
      textDecoder: e.textDecoder
    });
  });
  return {
    cancel: n,
    promise: s
  };
}, V8 = (e) => {
  const t = F8(e.opts.textDecoder);
  return (a, r) => {
    const n = a.map((o) => o.path).join(","), s = a.map((o) => o.input), { cancel: c, promise: i } = H8({
      ...e,
      textDecoder: t,
      path: n,
      inputs: s,
      headers() {
        return e.opts.headers ? typeof e.opts.headers == "function" ? e.opts.headers({
          opList: a
        }) : e.opts.headers : {};
      }
    }, (o, d) => r(o, d));
    return {
      /**
      * return an empty array because the batchLoader expects an array of results
      * but we've already called the `unitResolver` for each of them, there's
      * nothing left to do here.
      */
      promise: i.then(() => []),
      cancel: c
    };
  };
}, q8 = W0.createHTTPBatchLink(V8), K8 = (e) => {
  if ("input" in e) {
    if (!(e.input instanceof FormData))
      throw new Error("Input is not FormData");
    return e.input;
  }
}, W8 = (e) => {
  if (e.type !== "mutation")
    throw new Error("We only handle mutations with formdata");
  return Dr.httpRequest({
    ...e,
    getUrl() {
      return `${e.url}/${e.path}`;
    },
    getBody: K8
  });
}, G8 = Zo.httpLinkFactory({
  requester: W8
});
me.splitLink = q0.splitLink;
me.TRPCClientError = K0.TRPCClientError;
me.getFetch = Dr.getFetch;
me.httpBatchLink = W0.httpBatchLink;
me.httpLink = Zo.httpLink;
me.httpLinkFactory = Zo.httpLinkFactory;
me.loggerLink = L8.loggerLink;
me.createWSClient = G0.createWSClient;
me.wsLink = G0.wsLink;
me.clientCallTypeToProcedureType = Y0;
me.createTRPCClient = Z8;
me.createTRPCClientProxy = J0;
me.createTRPCProxyClient = B8;
me.createTRPCUntypedClient = j8;
me.experimental_formDataLink = G8;
me.unstable_httpBatchStreamLink = q8;
var aa = {}, Bo = {};
function Y8(e) {
  return e;
}
function J8(e) {
  return e.length === 0 ? Y8 : e.length === 1 ? e[0] : function(t) {
    return e.reduce((a, r) => r(a), t);
  };
}
function X8(e) {
  return typeof e == "object" && e !== null && "subscribe" in e;
}
function Q8(e) {
  const t = {
    subscribe(a) {
      let r = null, n = !1, s = !1, c = !1;
      function i() {
        if (r === null) {
          c = !0;
          return;
        }
        s || (s = !0, typeof r == "function" ? r() : r && r.unsubscribe());
      }
      return r = e({
        next(o) {
          n || a.next?.(o);
        },
        error(o) {
          n || (n = !0, a.error?.(o), i());
        },
        complete() {
          n || (n = !0, a.complete?.(), i());
        }
      }), c && i(), {
        unsubscribe: i
      };
    },
    pipe(...a) {
      return J8(a)(t);
    }
  };
  return t;
}
Bo.isObservable = X8;
Bo.observable = Q8;
Object.defineProperty(aa, "__esModule", { value: !0 });
var X0 = Bo;
function e7(e) {
  return (t) => {
    let a = 0, r = null;
    const n = [];
    function s() {
      r || (r = t.subscribe({
        next(i) {
          for (const o of n)
            o.next?.(i);
        },
        error(i) {
          for (const o of n)
            o.error?.(i);
        },
        complete() {
          for (const i of n)
            i.complete?.();
        }
      }));
    }
    function c() {
      if (a === 0 && r) {
        const i = r;
        r = null, i.unsubscribe();
      }
    }
    return {
      subscribe(i) {
        return a++, n.push(i), s(), {
          unsubscribe() {
            a--, c();
            const o = n.findIndex((d) => d === i);
            o > -1 && n.splice(o, 1);
          }
        };
      }
    };
  };
}
function t7(e) {
  return (t) => ({
    subscribe(a) {
      let r = 0;
      return t.subscribe({
        next(n) {
          a.next?.(e(n, r++));
        },
        error(n) {
          a.error?.(n);
        },
        complete() {
          a.complete?.();
        }
      });
    }
  });
}
function a7(e) {
  return (t) => ({
    subscribe(a) {
      return t.subscribe({
        next(r) {
          e.next?.(r), a.next?.(r);
        },
        error(r) {
          e.error?.(r), a.error?.(r);
        },
        complete() {
          e.complete?.(), a.complete?.();
        }
      });
    }
  });
}
class Fo extends Error {
  constructor(t) {
    super(t), this.name = "ObservableAbortError", Object.setPrototypeOf(this, Fo.prototype);
  }
}
function r7(e) {
  let t;
  return {
    promise: new Promise((a, r) => {
      let n = !1;
      function s() {
        n || (n = !0, r(new Fo("This operation was aborted.")), c.unsubscribe());
      }
      const c = e.subscribe({
        next(i) {
          n = !0, a(i), s();
        },
        error(i) {
          n = !0, r(i), s();
        },
        complete() {
          n = !0, s();
        }
      });
      t = s;
    }),
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    abort: t
  };
}
aa.isObservable = X0.isObservable;
aa.observable = X0.observable;
aa.map = t7;
aa.observableToPromise = r7;
aa.share = e7;
aa.tap = a7;
var rt = {};
Object.defineProperty(rt, "__esModule", { value: !0 });
rt.isTRPCRequestWithId = rt.isTRPCRequest = rt.isTRPCResponse = rt.isTRPCMessage = void 0;
function mf(e) {
  return typeof e == "object" && e !== null && !Array.isArray(e);
}
function n7(e) {
  return e == null;
}
function Q0(e) {
  return !!(mf(e) && "trpc" in e && mf(e.trpc));
}
rt.isTRPCMessage = Q0;
function Uo(e) {
  return Q0(e) && "id" in e.trpc && !n7(e.trpc.id);
}
function s7(e) {
  return Uo(e) && ("error" in e.trpc || "result" in e.trpc);
}
rt.isTRPCResponse = s7;
function eb(e) {
  return Uo(e) && "method" in e.trpc;
}
rt.isTRPCRequest = eb;
function c7(e) {
  return eb(e) && Uo(e);
}
rt.isTRPCRequestWithId = c7;
Object.defineProperty(yr, "__esModule", { value: !0 });
yr.createBaseLink = void 0;
const Uc = me, i7 = aa, o7 = rt, d7 = (e) => (t) => ({ op: a }) => (0, i7.observable)((r) => {
  const n = [], { id: s, type: c, path: i } = a;
  try {
    const o = t.transformer.serialize(a.input), d = () => {
      r.error(new Uc.TRPCClientError("Port disconnected prematurely"));
    };
    e.addCloseListener(d), n.push(() => e.removeCloseListener(d));
    const f = (u) => {
      if (!(0, o7.isTRPCResponse)(u))
        return;
      const { trpc: l } = u;
      if (s === l.id) {
        if ("error" in l) {
          const b = t.transformer.deserialize(l.error);
          r.error(Uc.TRPCClientError.from(Object.assign(Object.assign({}, l), { error: b })));
          return;
        }
        r.next({
          result: Object.assign(Object.assign({}, l.result), (!l.result.type || l.result.type === "data") && {
            type: "data",
            data: t.transformer.deserialize(l.result.data)
          })
        }), (c !== "subscription" || l.result.type === "stopped") && r.complete();
      }
    };
    e.addMessageListener(f), n.push(() => e.removeMessageListener(f)), e.postMessage({
      trpc: {
        id: s,
        jsonrpc: void 0,
        method: c,
        params: { path: i, input: o }
      }
    });
  } catch (o) {
    r.error(new Uc.TRPCClientError(o instanceof Error ? o.message : "Unknown error"));
  }
  return () => {
    c === "subscription" && e.postMessage({
      trpc: {
        id: s,
        jsonrpc: void 0,
        method: "subscription.stop"
      }
    }), n.forEach((o) => o());
  };
});
yr.createBaseLink = d7;
Object.defineProperty(Xs, "__esModule", { value: !0 });
Xs.chromeLink = void 0;
const f7 = yr, u7 = (e) => (0, f7.createBaseLink)({
  postMessage(t) {
    e.port.postMessage(t);
  },
  addMessageListener(t) {
    e.port.onMessage.addListener(t);
  },
  removeMessageListener(t) {
    e.port.onMessage.removeListener(t);
  },
  addCloseListener(t) {
    e.port.onDisconnect.addListener(t);
  },
  removeCloseListener(t) {
    e.port.onDisconnect.removeListener(t);
  }
});
Xs.chromeLink = u7;
var tc = {};
Object.defineProperty(tc, "__esModule", { value: !0 });
tc.windowLink = void 0;
const l7 = yr, b7 = (e) => {
  var t;
  const a = /* @__PURE__ */ new Map(), r = e.window, n = (t = e.postWindow) !== null && t !== void 0 ? t : r;
  return (0, l7.createBaseLink)({
    postMessage(s) {
      n.postMessage(s, {
        targetOrigin: e.postOrigin
      });
    },
    addMessageListener(s) {
      const c = (i) => {
        s(i.data);
      };
      a.set(s, c), r.addEventListener("message", c);
    },
    removeMessageListener(s) {
      const c = a.get(s);
      c && r.removeEventListener("message", c);
    },
    addCloseListener(s) {
      r.addEventListener("beforeunload", s);
    },
    removeCloseListener(s) {
      r.removeEventListener("beforeunload", s);
    }
  });
};
tc.windowLink = b7;
var ac = {}, rc = {};
Object.defineProperty(rc, "__esModule", { value: !0 });
rc.TRPC_BROWSER_LOADED_EVENT = void 0;
rc.TRPC_BROWSER_LOADED_EVENT = "TRPC_BROWSER::POPUP_LOADED";
Object.defineProperty(ac, "__esModule", { value: !0 });
ac.popupLink = void 0;
const h7 = rc, p7 = yr, m7 = (e) => {
  const t = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Set();
  let r = null;
  async function n(s) {
    if (!r || r.closed) {
      r = e.createPopup(), await Promise.race([
        // wait til window is loaded (same origin)
        new Promise((c) => {
          var i;
          try {
            (i = r?.addEventListener) === null || i === void 0 || i.call(r, "load", c);
          } catch {
          }
        }),
        // this is needed for cross-origin popups as they don't have a load event
        new Promise((c) => {
          s.addEventListener("message", (i) => {
            i.data === h7.TRPC_BROWSER_LOADED_EVENT && c();
          });
        }),
        // expect the popup to load after 15s max, in case non of the above events fire
        new Promise((c) => {
          console.warn("Could not detect if popup loading succeeded after 15s timeout, continuing anyway"), setTimeout(c, 15e3);
        })
      ]);
      try {
        if (!r.addEventListener)
          throw new Error("popupWindow.addEventListener is not a function");
        r.addEventListener("beforeunload", () => {
          r = null;
        });
      } catch {
        const c = setInterval(() => {
          r && r.closed && (r = null, a.forEach((i) => {
            i();
          }), clearInterval(c));
        }, 1e3);
      }
    }
    return r;
  }
  return (0, p7.createBaseLink)({
    async postMessage(s) {
      return (await n(e.listenWindow)).postMessage(s, {
        targetOrigin: e.postOrigin
      });
    },
    addMessageListener(s) {
      const c = (i) => {
        s(i.data);
      };
      t.set(s, c), e.listenWindow.addEventListener("message", c);
    },
    removeMessageListener(s) {
      const c = t.get(s);
      c && e.listenWindow.removeEventListener("message", c);
    },
    addCloseListener(s) {
      e.listenWindow.addEventListener("beforeunload", s), a.add(s);
    },
    removeCloseListener(s) {
      e.listenWindow.removeEventListener("beforeunload", s), a.delete(s);
    }
  });
};
ac.popupLink = m7;
(function(e) {
  var t = Ir && Ir.__createBinding || (Object.create ? function(r, n, s, c) {
    c === void 0 && (c = s);
    var i = Object.getOwnPropertyDescriptor(n, s);
    (!i || ("get" in i ? !n.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
      return n[s];
    } }), Object.defineProperty(r, c, i);
  } : function(r, n, s, c) {
    c === void 0 && (c = s), r[c] = n[s];
  }), a = Ir && Ir.__exportStar || function(r, n) {
    for (var s in r)
      s !== "default" && !Object.prototype.hasOwnProperty.call(n, s) && t(n, r, s);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), a(Xs, e), a(tc, e), a(ac, e);
})(vi);
var te;
(function(e) {
  e.assertEqual = (n) => n;
  function t(n) {
  }
  e.assertIs = t;
  function a(n) {
    throw new Error();
  }
  e.assertNever = a, e.arrayToEnum = (n) => {
    const s = {};
    for (const c of n)
      s[c] = c;
    return s;
  }, e.getValidEnumValues = (n) => {
    const s = e.objectKeys(n).filter((i) => typeof n[n[i]] != "number"), c = {};
    for (const i of s)
      c[i] = n[i];
    return e.objectValues(c);
  }, e.objectValues = (n) => e.objectKeys(n).map(function(s) {
    return n[s];
  }), e.objectKeys = typeof Object.keys == "function" ? (n) => Object.keys(n) : (n) => {
    const s = [];
    for (const c in n)
      Object.prototype.hasOwnProperty.call(n, c) && s.push(c);
    return s;
  }, e.find = (n, s) => {
    for (const c of n)
      if (s(c))
        return c;
  }, e.isInteger = typeof Number.isInteger == "function" ? (n) => Number.isInteger(n) : (n) => typeof n == "number" && isFinite(n) && Math.floor(n) === n;
  function r(n, s = " | ") {
    return n.map((c) => typeof c == "string" ? `'${c}'` : c).join(s);
  }
  e.joinValues = r, e.jsonStringifyReplacer = (n, s) => typeof s == "bigint" ? s.toString() : s;
})(te || (te = {}));
var xi;
(function(e) {
  e.mergeShapes = (t, a) => ({
    ...t,
    ...a
    // second overwrites first
  });
})(xi || (xi = {}));
const R = te.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), jt = (e) => {
  switch (typeof e) {
    case "undefined":
      return R.undefined;
    case "string":
      return R.string;
    case "number":
      return isNaN(e) ? R.nan : R.number;
    case "boolean":
      return R.boolean;
    case "function":
      return R.function;
    case "bigint":
      return R.bigint;
    case "symbol":
      return R.symbol;
    case "object":
      return Array.isArray(e) ? R.array : e === null ? R.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? R.promise : typeof Map < "u" && e instanceof Map ? R.map : typeof Set < "u" && e instanceof Set ? R.set : typeof Date < "u" && e instanceof Date ? R.date : R.object;
    default:
      return R.unknown;
  }
}, x = te.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), y7 = (e) => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:");
class Ke extends Error {
  constructor(t) {
    super(), this.issues = [], this.addIssue = (r) => {
      this.issues = [...this.issues, r];
    }, this.addIssues = (r = []) => {
      this.issues = [...this.issues, ...r];
    };
    const a = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, a) : this.__proto__ = a, this.name = "ZodError", this.issues = t;
  }
  get errors() {
    return this.issues;
  }
  format(t) {
    const a = t || function(s) {
      return s.message;
    }, r = { _errors: [] }, n = (s) => {
      for (const c of s.issues)
        if (c.code === "invalid_union")
          c.unionErrors.map(n);
        else if (c.code === "invalid_return_type")
          n(c.returnTypeError);
        else if (c.code === "invalid_arguments")
          n(c.argumentsError);
        else if (c.path.length === 0)
          r._errors.push(a(c));
        else {
          let i = r, o = 0;
          for (; o < c.path.length; ) {
            const d = c.path[o];
            o === c.path.length - 1 ? (i[d] = i[d] || { _errors: [] }, i[d]._errors.push(a(c))) : i[d] = i[d] || { _errors: [] }, i = i[d], o++;
          }
        }
    };
    return n(this), r;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, te.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (a) => a.message) {
    const a = {}, r = [];
    for (const n of this.issues)
      n.path.length > 0 ? (a[n.path[0]] = a[n.path[0]] || [], a[n.path[0]].push(t(n))) : r.push(t(n));
    return { formErrors: r, fieldErrors: a };
  }
  get formErrors() {
    return this.flatten();
  }
}
Ke.create = (e) => new Ke(e);
const dn = (e, t) => {
  let a;
  switch (e.code) {
    case x.invalid_type:
      e.received === R.undefined ? a = "Required" : a = `Expected ${e.expected}, received ${e.received}`;
      break;
    case x.invalid_literal:
      a = `Invalid literal value, expected ${JSON.stringify(e.expected, te.jsonStringifyReplacer)}`;
      break;
    case x.unrecognized_keys:
      a = `Unrecognized key(s) in object: ${te.joinValues(e.keys, ", ")}`;
      break;
    case x.invalid_union:
      a = "Invalid input";
      break;
    case x.invalid_union_discriminator:
      a = `Invalid discriminator value. Expected ${te.joinValues(e.options)}`;
      break;
    case x.invalid_enum_value:
      a = `Invalid enum value. Expected ${te.joinValues(e.options)}, received '${e.received}'`;
      break;
    case x.invalid_arguments:
      a = "Invalid function arguments";
      break;
    case x.invalid_return_type:
      a = "Invalid function return type";
      break;
    case x.invalid_date:
      a = "Invalid date";
      break;
    case x.invalid_string:
      typeof e.validation == "object" ? "includes" in e.validation ? (a = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (a = `${a} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? a = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? a = `Invalid input: must end with "${e.validation.endsWith}"` : te.assertNever(e.validation) : e.validation !== "regex" ? a = `Invalid ${e.validation}` : a = "Invalid";
      break;
    case x.too_small:
      e.type === "array" ? a = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? a = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? a = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? a = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : a = "Invalid input";
      break;
    case x.too_big:
      e.type === "array" ? a = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? a = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? a = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? a = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? a = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : a = "Invalid input";
      break;
    case x.custom:
      a = "Invalid input";
      break;
    case x.invalid_intersection_types:
      a = "Intersection results could not be merged";
      break;
    case x.not_multiple_of:
      a = `Number must be a multiple of ${e.multipleOf}`;
      break;
    case x.not_finite:
      a = "Number must be finite";
      break;
    default:
      a = t.defaultError, te.assertNever(e);
  }
  return { message: a };
};
let tb = dn;
function g7(e) {
  tb = e;
}
function Es() {
  return tb;
}
const ks = (e) => {
  const { data: t, path: a, errorMaps: r, issueData: n } = e, s = [...a, ...n.path || []], c = {
    ...n,
    path: s
  };
  let i = "";
  const o = r.filter((d) => !!d).slice().reverse();
  for (const d of o)
    i = d(c, { data: t, defaultError: i }).message;
  return {
    ...n,
    path: s,
    message: n.message || i
  };
}, _7 = [];
function L(e, t) {
  const a = ks({
    issueData: t,
    data: e.data,
    path: e.path,
    errorMaps: [
      e.common.contextualErrorMap,
      e.schemaErrorMap,
      Es(),
      dn
      // then global default map
    ].filter((r) => !!r)
  });
  e.common.issues.push(a);
}
class ke {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t, a) {
    const r = [];
    for (const n of a) {
      if (n.status === "aborted")
        return q;
      n.status === "dirty" && t.dirty(), r.push(n.value);
    }
    return { status: t.value, value: r };
  }
  static async mergeObjectAsync(t, a) {
    const r = [];
    for (const n of a)
      r.push({
        key: await n.key,
        value: await n.value
      });
    return ke.mergeObjectSync(t, r);
  }
  static mergeObjectSync(t, a) {
    const r = {};
    for (const n of a) {
      const { key: s, value: c } = n;
      if (s.status === "aborted" || c.status === "aborted")
        return q;
      s.status === "dirty" && t.dirty(), c.status === "dirty" && t.dirty(), (typeof c.value < "u" || n.alwaysSet) && (r[s.value] = c.value);
    }
    return { status: t.value, value: r };
  }
}
const q = Object.freeze({
  status: "aborted"
}), ab = (e) => ({ status: "dirty", value: e }), Ae = (e) => ({ status: "valid", value: e }), Ti = (e) => e.status === "aborted", Si = (e) => e.status === "dirty", xs = (e) => e.status === "valid", Ts = (e) => typeof Promise < "u" && e instanceof Promise;
var U;
(function(e) {
  e.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, e.toString = (t) => typeof t == "string" ? t : t?.message;
})(U || (U = {}));
class ut {
  constructor(t, a, r, n) {
    this._cachedPath = [], this.parent = t, this.data = a, this._path = r, this._key = n;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const yf = (e, t) => {
  if (xs(t))
    return { success: !0, data: t.value };
  if (!e.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const a = new Ke(e.common.issues);
      return this._error = a, this._error;
    }
  };
};
function W(e) {
  if (!e)
    return {};
  const { errorMap: t, invalid_type_error: a, required_error: r, description: n } = e;
  if (t && (a || r))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return t ? { errorMap: t, description: n } : { errorMap: (s, c) => s.code !== "invalid_type" ? { message: c.defaultError } : typeof c.data > "u" ? { message: r ?? c.defaultError } : { message: a ?? c.defaultError }, description: n };
}
class Y {
  constructor(t) {
    this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(t) {
    return jt(t.data);
  }
  _getOrReturnCtx(t, a) {
    return a || {
      common: t.parent.common,
      data: t.data,
      parsedType: jt(t.data),
      schemaErrorMap: this._def.errorMap,
      path: t.path,
      parent: t.parent
    };
  }
  _processInputParams(t) {
    return {
      status: new ke(),
      ctx: {
        common: t.parent.common,
        data: t.data,
        parsedType: jt(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      }
    };
  }
  _parseSync(t) {
    const a = this._parse(t);
    if (Ts(a))
      throw new Error("Synchronous parse encountered promise.");
    return a;
  }
  _parseAsync(t) {
    const a = this._parse(t);
    return Promise.resolve(a);
  }
  parse(t, a) {
    const r = this.safeParse(t, a);
    if (r.success)
      return r.data;
    throw r.error;
  }
  safeParse(t, a) {
    var r;
    const n = {
      common: {
        issues: [],
        async: (r = a?.async) !== null && r !== void 0 ? r : !1,
        contextualErrorMap: a?.errorMap
      },
      path: a?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: jt(t)
    }, s = this._parseSync({ data: t, path: n.path, parent: n });
    return yf(n, s);
  }
  async parseAsync(t, a) {
    const r = await this.safeParseAsync(t, a);
    if (r.success)
      return r.data;
    throw r.error;
  }
  async safeParseAsync(t, a) {
    const r = {
      common: {
        issues: [],
        contextualErrorMap: a?.errorMap,
        async: !0
      },
      path: a?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: jt(t)
    }, n = this._parse({ data: t, path: r.path, parent: r }), s = await (Ts(n) ? n : Promise.resolve(n));
    return yf(r, s);
  }
  refine(t, a) {
    const r = (n) => typeof a == "string" || typeof a > "u" ? { message: a } : typeof a == "function" ? a(n) : a;
    return this._refinement((n, s) => {
      const c = t(n), i = () => s.addIssue({
        code: x.custom,
        ...r(n)
      });
      return typeof Promise < "u" && c instanceof Promise ? c.then((o) => o ? !0 : (i(), !1)) : c ? !0 : (i(), !1);
    });
  }
  refinement(t, a) {
    return this._refinement((r, n) => t(r) ? !0 : (n.addIssue(typeof a == "function" ? a(r, n) : a), !1));
  }
  _refinement(t) {
    return new Je({
      schema: this,
      typeName: M.ZodEffects,
      effect: { type: "refinement", refinement: t }
    });
  }
  superRefine(t) {
    return this._refinement(t);
  }
  optional() {
    return Et.create(this, this._def);
  }
  nullable() {
    return Ca.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return We.create(this, this._def);
  }
  promise() {
    return or.create(this, this._def);
  }
  or(t) {
    return bn.create([this, t], this._def);
  }
  and(t) {
    return hn.create(this, t, this._def);
  }
  transform(t) {
    return new Je({
      ...W(this._def),
      schema: this,
      typeName: M.ZodEffects,
      effect: { type: "transform", transform: t }
    });
  }
  default(t) {
    const a = typeof t == "function" ? t : () => t;
    return new _n({
      ...W(this._def),
      innerType: this,
      defaultValue: a,
      typeName: M.ZodDefault
    });
  }
  brand() {
    return new nb({
      typeName: M.ZodBranded,
      type: this,
      ...W(this._def)
    });
  }
  catch(t) {
    const a = typeof t == "function" ? t : () => t;
    return new Os({
      ...W(this._def),
      innerType: this,
      catchValue: a,
      typeName: M.ZodCatch
    });
  }
  describe(t) {
    const a = this.constructor;
    return new a({
      ...this._def,
      description: t
    });
  }
  pipe(t) {
    return Ln.create(this, t);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const v7 = /^c[^\s-]{8,}$/i, w7 = /^[a-z][a-z0-9]*$/, E7 = /[0-9A-HJKMNP-TV-Z]{26}/, k7 = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i, x7 = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/, T7 = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u, S7 = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, C7 = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, A7 = (e) => e.precision ? e.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}Z$`) : e.precision === 0 ? e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function O7(e, t) {
  return !!((t === "v4" || !t) && S7.test(e) || (t === "v6" || !t) && C7.test(e));
}
class He extends Y {
  constructor() {
    super(...arguments), this._regex = (t, a, r) => this.refinement((n) => t.test(n), {
      validation: a,
      code: x.invalid_string,
      ...U.errToObj(r)
    }), this.nonempty = (t) => this.min(1, U.errToObj(t)), this.trim = () => new He({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    }), this.toLowerCase = () => new He({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    }), this.toUpperCase = () => new He({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  _parse(t) {
    if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== R.string) {
      const n = this._getOrReturnCtx(t);
      return L(
        n,
        {
          code: x.invalid_type,
          expected: R.string,
          received: n.parsedType
        }
        //
      ), q;
    }
    const a = new ke();
    let r;
    for (const n of this._def.checks)
      if (n.kind === "min")
        t.data.length < n.value && (r = this._getOrReturnCtx(t, r), L(r, {
          code: x.too_small,
          minimum: n.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: n.message
        }), a.dirty());
      else if (n.kind === "max")
        t.data.length > n.value && (r = this._getOrReturnCtx(t, r), L(r, {
          code: x.too_big,
          maximum: n.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: n.message
        }), a.dirty());
      else if (n.kind === "length") {
        const s = t.data.length > n.value, c = t.data.length < n.value;
        (s || c) && (r = this._getOrReturnCtx(t, r), s ? L(r, {
          code: x.too_big,
          maximum: n.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: n.message
        }) : c && L(r, {
          code: x.too_small,
          minimum: n.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: n.message
        }), a.dirty());
      } else if (n.kind === "email")
        x7.test(t.data) || (r = this._getOrReturnCtx(t, r), L(r, {
          validation: "email",
          code: x.invalid_string,
          message: n.message
        }), a.dirty());
      else if (n.kind === "emoji")
        T7.test(t.data) || (r = this._getOrReturnCtx(t, r), L(r, {
          validation: "emoji",
          code: x.invalid_string,
          message: n.message
        }), a.dirty());
      else if (n.kind === "uuid")
        k7.test(t.data) || (r = this._getOrReturnCtx(t, r), L(r, {
          validation: "uuid",
          code: x.invalid_string,
          message: n.message
        }), a.dirty());
      else if (n.kind === "cuid")
        v7.test(t.data) || (r = this._getOrReturnCtx(t, r), L(r, {
          validation: "cuid",
          code: x.invalid_string,
          message: n.message
        }), a.dirty());
      else if (n.kind === "cuid2")
        w7.test(t.data) || (r = this._getOrReturnCtx(t, r), L(r, {
          validation: "cuid2",
          code: x.invalid_string,
          message: n.message
        }), a.dirty());
      else if (n.kind === "ulid")
        E7.test(t.data) || (r = this._getOrReturnCtx(t, r), L(r, {
          validation: "ulid",
          code: x.invalid_string,
          message: n.message
        }), a.dirty());
      else if (n.kind === "url")
        try {
          new URL(t.data);
        } catch {
          r = this._getOrReturnCtx(t, r), L(r, {
            validation: "url",
            code: x.invalid_string,
            message: n.message
          }), a.dirty();
        }
      else
        n.kind === "regex" ? (n.regex.lastIndex = 0, n.regex.test(t.data) || (r = this._getOrReturnCtx(t, r), L(r, {
          validation: "regex",
          code: x.invalid_string,
          message: n.message
        }), a.dirty())) : n.kind === "trim" ? t.data = t.data.trim() : n.kind === "includes" ? t.data.includes(n.value, n.position) || (r = this._getOrReturnCtx(t, r), L(r, {
          code: x.invalid_string,
          validation: { includes: n.value, position: n.position },
          message: n.message
        }), a.dirty()) : n.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : n.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : n.kind === "startsWith" ? t.data.startsWith(n.value) || (r = this._getOrReturnCtx(t, r), L(r, {
          code: x.invalid_string,
          validation: { startsWith: n.value },
          message: n.message
        }), a.dirty()) : n.kind === "endsWith" ? t.data.endsWith(n.value) || (r = this._getOrReturnCtx(t, r), L(r, {
          code: x.invalid_string,
          validation: { endsWith: n.value },
          message: n.message
        }), a.dirty()) : n.kind === "datetime" ? A7(n).test(t.data) || (r = this._getOrReturnCtx(t, r), L(r, {
          code: x.invalid_string,
          validation: "datetime",
          message: n.message
        }), a.dirty()) : n.kind === "ip" ? O7(t.data, n.version) || (r = this._getOrReturnCtx(t, r), L(r, {
          validation: "ip",
          code: x.invalid_string,
          message: n.message
        }), a.dirty()) : te.assertNever(n);
    return { status: a.value, value: t.data };
  }
  _addCheck(t) {
    return new He({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  email(t) {
    return this._addCheck({ kind: "email", ...U.errToObj(t) });
  }
  url(t) {
    return this._addCheck({ kind: "url", ...U.errToObj(t) });
  }
  emoji(t) {
    return this._addCheck({ kind: "emoji", ...U.errToObj(t) });
  }
  uuid(t) {
    return this._addCheck({ kind: "uuid", ...U.errToObj(t) });
  }
  cuid(t) {
    return this._addCheck({ kind: "cuid", ...U.errToObj(t) });
  }
  cuid2(t) {
    return this._addCheck({ kind: "cuid2", ...U.errToObj(t) });
  }
  ulid(t) {
    return this._addCheck({ kind: "ulid", ...U.errToObj(t) });
  }
  ip(t) {
    return this._addCheck({ kind: "ip", ...U.errToObj(t) });
  }
  datetime(t) {
    var a;
    return typeof t == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      message: t
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof t?.precision > "u" ? null : t?.precision,
      offset: (a = t?.offset) !== null && a !== void 0 ? a : !1,
      ...U.errToObj(t?.message)
    });
  }
  regex(t, a) {
    return this._addCheck({
      kind: "regex",
      regex: t,
      ...U.errToObj(a)
    });
  }
  includes(t, a) {
    return this._addCheck({
      kind: "includes",
      value: t,
      position: a?.position,
      ...U.errToObj(a?.message)
    });
  }
  startsWith(t, a) {
    return this._addCheck({
      kind: "startsWith",
      value: t,
      ...U.errToObj(a)
    });
  }
  endsWith(t, a) {
    return this._addCheck({
      kind: "endsWith",
      value: t,
      ...U.errToObj(a)
    });
  }
  min(t, a) {
    return this._addCheck({
      kind: "min",
      value: t,
      ...U.errToObj(a)
    });
  }
  max(t, a) {
    return this._addCheck({
      kind: "max",
      value: t,
      ...U.errToObj(a)
    });
  }
  length(t, a) {
    return this._addCheck({
      kind: "length",
      value: t,
      ...U.errToObj(a)
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((t) => t.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((t) => t.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((t) => t.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((t) => t.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((t) => t.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((t) => t.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((t) => t.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((t) => t.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((t) => t.kind === "ip");
  }
  get minLength() {
    let t = null;
    for (const a of this._def.checks)
      a.kind === "min" && (t === null || a.value > t) && (t = a.value);
    return t;
  }
  get maxLength() {
    let t = null;
    for (const a of this._def.checks)
      a.kind === "max" && (t === null || a.value < t) && (t = a.value);
    return t;
  }
}
He.create = (e) => {
  var t;
  return new He({
    checks: [],
    typeName: M.ZodString,
    coerce: (t = e?.coerce) !== null && t !== void 0 ? t : !1,
    ...W(e)
  });
};
function I7(e, t) {
  const a = (e.toString().split(".")[1] || "").length, r = (t.toString().split(".")[1] || "").length, n = a > r ? a : r, s = parseInt(e.toFixed(n).replace(".", "")), c = parseInt(t.toFixed(n).replace(".", ""));
  return s % c / Math.pow(10, n);
}
class Jt extends Y {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== R.number) {
      const n = this._getOrReturnCtx(t);
      return L(n, {
        code: x.invalid_type,
        expected: R.number,
        received: n.parsedType
      }), q;
    }
    let a;
    const r = new ke();
    for (const n of this._def.checks)
      n.kind === "int" ? te.isInteger(t.data) || (a = this._getOrReturnCtx(t, a), L(a, {
        code: x.invalid_type,
        expected: "integer",
        received: "float",
        message: n.message
      }), r.dirty()) : n.kind === "min" ? (n.inclusive ? t.data < n.value : t.data <= n.value) && (a = this._getOrReturnCtx(t, a), L(a, {
        code: x.too_small,
        minimum: n.value,
        type: "number",
        inclusive: n.inclusive,
        exact: !1,
        message: n.message
      }), r.dirty()) : n.kind === "max" ? (n.inclusive ? t.data > n.value : t.data >= n.value) && (a = this._getOrReturnCtx(t, a), L(a, {
        code: x.too_big,
        maximum: n.value,
        type: "number",
        inclusive: n.inclusive,
        exact: !1,
        message: n.message
      }), r.dirty()) : n.kind === "multipleOf" ? I7(t.data, n.value) !== 0 && (a = this._getOrReturnCtx(t, a), L(a, {
        code: x.not_multiple_of,
        multipleOf: n.value,
        message: n.message
      }), r.dirty()) : n.kind === "finite" ? Number.isFinite(t.data) || (a = this._getOrReturnCtx(t, a), L(a, {
        code: x.not_finite,
        message: n.message
      }), r.dirty()) : te.assertNever(n);
    return { status: r.value, value: t.data };
  }
  gte(t, a) {
    return this.setLimit("min", t, !0, U.toString(a));
  }
  gt(t, a) {
    return this.setLimit("min", t, !1, U.toString(a));
  }
  lte(t, a) {
    return this.setLimit("max", t, !0, U.toString(a));
  }
  lt(t, a) {
    return this.setLimit("max", t, !1, U.toString(a));
  }
  setLimit(t, a, r, n) {
    return new Jt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: a,
          inclusive: r,
          message: U.toString(n)
        }
      ]
    });
  }
  _addCheck(t) {
    return new Jt({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  int(t) {
    return this._addCheck({
      kind: "int",
      message: U.toString(t)
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: U.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: U.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: U.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: U.toString(t)
    });
  }
  multipleOf(t, a) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: U.toString(a)
    });
  }
  finite(t) {
    return this._addCheck({
      kind: "finite",
      message: U.toString(t)
    });
  }
  safe(t) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: U.toString(t)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: U.toString(t)
    });
  }
  get minValue() {
    let t = null;
    for (const a of this._def.checks)
      a.kind === "min" && (t === null || a.value > t) && (t = a.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const a of this._def.checks)
      a.kind === "max" && (t === null || a.value < t) && (t = a.value);
    return t;
  }
  get isInt() {
    return !!this._def.checks.find((t) => t.kind === "int" || t.kind === "multipleOf" && te.isInteger(t.value));
  }
  get isFinite() {
    let t = null, a = null;
    for (const r of this._def.checks) {
      if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf")
        return !0;
      r.kind === "min" ? (a === null || r.value > a) && (a = r.value) : r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    }
    return Number.isFinite(a) && Number.isFinite(t);
  }
}
Jt.create = (e) => new Jt({
  checks: [],
  typeName: M.ZodNumber,
  coerce: e?.coerce || !1,
  ...W(e)
});
class Xt extends Y {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = BigInt(t.data)), this._getType(t) !== R.bigint) {
      const n = this._getOrReturnCtx(t);
      return L(n, {
        code: x.invalid_type,
        expected: R.bigint,
        received: n.parsedType
      }), q;
    }
    let a;
    const r = new ke();
    for (const n of this._def.checks)
      n.kind === "min" ? (n.inclusive ? t.data < n.value : t.data <= n.value) && (a = this._getOrReturnCtx(t, a), L(a, {
        code: x.too_small,
        type: "bigint",
        minimum: n.value,
        inclusive: n.inclusive,
        message: n.message
      }), r.dirty()) : n.kind === "max" ? (n.inclusive ? t.data > n.value : t.data >= n.value) && (a = this._getOrReturnCtx(t, a), L(a, {
        code: x.too_big,
        type: "bigint",
        maximum: n.value,
        inclusive: n.inclusive,
        message: n.message
      }), r.dirty()) : n.kind === "multipleOf" ? t.data % n.value !== BigInt(0) && (a = this._getOrReturnCtx(t, a), L(a, {
        code: x.not_multiple_of,
        multipleOf: n.value,
        message: n.message
      }), r.dirty()) : te.assertNever(n);
    return { status: r.value, value: t.data };
  }
  gte(t, a) {
    return this.setLimit("min", t, !0, U.toString(a));
  }
  gt(t, a) {
    return this.setLimit("min", t, !1, U.toString(a));
  }
  lte(t, a) {
    return this.setLimit("max", t, !0, U.toString(a));
  }
  lt(t, a) {
    return this.setLimit("max", t, !1, U.toString(a));
  }
  setLimit(t, a, r, n) {
    return new Xt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: a,
          inclusive: r,
          message: U.toString(n)
        }
      ]
    });
  }
  _addCheck(t) {
    return new Xt({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: U.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: U.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: U.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: U.toString(t)
    });
  }
  multipleOf(t, a) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: U.toString(a)
    });
  }
  get minValue() {
    let t = null;
    for (const a of this._def.checks)
      a.kind === "min" && (t === null || a.value > t) && (t = a.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const a of this._def.checks)
      a.kind === "max" && (t === null || a.value < t) && (t = a.value);
    return t;
  }
}
Xt.create = (e) => {
  var t;
  return new Xt({
    checks: [],
    typeName: M.ZodBigInt,
    coerce: (t = e?.coerce) !== null && t !== void 0 ? t : !1,
    ...W(e)
  });
};
class fn extends Y {
  _parse(t) {
    if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== R.boolean) {
      const a = this._getOrReturnCtx(t);
      return L(a, {
        code: x.invalid_type,
        expected: R.boolean,
        received: a.parsedType
      }), q;
    }
    return Ae(t.data);
  }
}
fn.create = (e) => new fn({
  typeName: M.ZodBoolean,
  coerce: e?.coerce || !1,
  ...W(e)
});
class Ta extends Y {
  _parse(t) {
    if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== R.date) {
      const n = this._getOrReturnCtx(t);
      return L(n, {
        code: x.invalid_type,
        expected: R.date,
        received: n.parsedType
      }), q;
    }
    if (isNaN(t.data.getTime())) {
      const n = this._getOrReturnCtx(t);
      return L(n, {
        code: x.invalid_date
      }), q;
    }
    const a = new ke();
    let r;
    for (const n of this._def.checks)
      n.kind === "min" ? t.data.getTime() < n.value && (r = this._getOrReturnCtx(t, r), L(r, {
        code: x.too_small,
        message: n.message,
        inclusive: !0,
        exact: !1,
        minimum: n.value,
        type: "date"
      }), a.dirty()) : n.kind === "max" ? t.data.getTime() > n.value && (r = this._getOrReturnCtx(t, r), L(r, {
        code: x.too_big,
        message: n.message,
        inclusive: !0,
        exact: !1,
        maximum: n.value,
        type: "date"
      }), a.dirty()) : te.assertNever(n);
    return {
      status: a.value,
      value: new Date(t.data.getTime())
    };
  }
  _addCheck(t) {
    return new Ta({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  min(t, a) {
    return this._addCheck({
      kind: "min",
      value: t.getTime(),
      message: U.toString(a)
    });
  }
  max(t, a) {
    return this._addCheck({
      kind: "max",
      value: t.getTime(),
      message: U.toString(a)
    });
  }
  get minDate() {
    let t = null;
    for (const a of this._def.checks)
      a.kind === "min" && (t === null || a.value > t) && (t = a.value);
    return t != null ? new Date(t) : null;
  }
  get maxDate() {
    let t = null;
    for (const a of this._def.checks)
      a.kind === "max" && (t === null || a.value < t) && (t = a.value);
    return t != null ? new Date(t) : null;
  }
}
Ta.create = (e) => new Ta({
  checks: [],
  coerce: e?.coerce || !1,
  typeName: M.ZodDate,
  ...W(e)
});
class Ss extends Y {
  _parse(t) {
    if (this._getType(t) !== R.symbol) {
      const a = this._getOrReturnCtx(t);
      return L(a, {
        code: x.invalid_type,
        expected: R.symbol,
        received: a.parsedType
      }), q;
    }
    return Ae(t.data);
  }
}
Ss.create = (e) => new Ss({
  typeName: M.ZodSymbol,
  ...W(e)
});
class un extends Y {
  _parse(t) {
    if (this._getType(t) !== R.undefined) {
      const a = this._getOrReturnCtx(t);
      return L(a, {
        code: x.invalid_type,
        expected: R.undefined,
        received: a.parsedType
      }), q;
    }
    return Ae(t.data);
  }
}
un.create = (e) => new un({
  typeName: M.ZodUndefined,
  ...W(e)
});
class ln extends Y {
  _parse(t) {
    if (this._getType(t) !== R.null) {
      const a = this._getOrReturnCtx(t);
      return L(a, {
        code: x.invalid_type,
        expected: R.null,
        received: a.parsedType
      }), q;
    }
    return Ae(t.data);
  }
}
ln.create = (e) => new ln({
  typeName: M.ZodNull,
  ...W(e)
});
class ir extends Y {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(t) {
    return Ae(t.data);
  }
}
ir.create = (e) => new ir({
  typeName: M.ZodAny,
  ...W(e)
});
class pa extends Y {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(t) {
    return Ae(t.data);
  }
}
pa.create = (e) => new pa({
  typeName: M.ZodUnknown,
  ...W(e)
});
class St extends Y {
  _parse(t) {
    const a = this._getOrReturnCtx(t);
    return L(a, {
      code: x.invalid_type,
      expected: R.never,
      received: a.parsedType
    }), q;
  }
}
St.create = (e) => new St({
  typeName: M.ZodNever,
  ...W(e)
});
class Cs extends Y {
  _parse(t) {
    if (this._getType(t) !== R.undefined) {
      const a = this._getOrReturnCtx(t);
      return L(a, {
        code: x.invalid_type,
        expected: R.void,
        received: a.parsedType
      }), q;
    }
    return Ae(t.data);
  }
}
Cs.create = (e) => new Cs({
  typeName: M.ZodVoid,
  ...W(e)
});
class We extends Y {
  _parse(t) {
    const { ctx: a, status: r } = this._processInputParams(t), n = this._def;
    if (a.parsedType !== R.array)
      return L(a, {
        code: x.invalid_type,
        expected: R.array,
        received: a.parsedType
      }), q;
    if (n.exactLength !== null) {
      const c = a.data.length > n.exactLength.value, i = a.data.length < n.exactLength.value;
      (c || i) && (L(a, {
        code: c ? x.too_big : x.too_small,
        minimum: i ? n.exactLength.value : void 0,
        maximum: c ? n.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: n.exactLength.message
      }), r.dirty());
    }
    if (n.minLength !== null && a.data.length < n.minLength.value && (L(a, {
      code: x.too_small,
      minimum: n.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: n.minLength.message
    }), r.dirty()), n.maxLength !== null && a.data.length > n.maxLength.value && (L(a, {
      code: x.too_big,
      maximum: n.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: n.maxLength.message
    }), r.dirty()), a.common.async)
      return Promise.all([...a.data].map((c, i) => n.type._parseAsync(new ut(a, c, a.path, i)))).then((c) => ke.mergeArray(r, c));
    const s = [...a.data].map((c, i) => n.type._parseSync(new ut(a, c, a.path, i)));
    return ke.mergeArray(r, s);
  }
  get element() {
    return this._def.type;
  }
  min(t, a) {
    return new We({
      ...this._def,
      minLength: { value: t, message: U.toString(a) }
    });
  }
  max(t, a) {
    return new We({
      ...this._def,
      maxLength: { value: t, message: U.toString(a) }
    });
  }
  length(t, a) {
    return new We({
      ...this._def,
      exactLength: { value: t, message: U.toString(a) }
    });
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
We.create = (e, t) => new We({
  type: e,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: M.ZodArray,
  ...W(t)
});
function Ua(e) {
  if (e instanceof oe) {
    const t = {};
    for (const a in e.shape) {
      const r = e.shape[a];
      t[a] = Et.create(Ua(r));
    }
    return new oe({
      ...e._def,
      shape: () => t
    });
  } else
    return e instanceof We ? new We({
      ...e._def,
      type: Ua(e.element)
    }) : e instanceof Et ? Et.create(Ua(e.unwrap())) : e instanceof Ca ? Ca.create(Ua(e.unwrap())) : e instanceof lt ? lt.create(e.items.map((t) => Ua(t))) : e;
}
class oe extends Y {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const t = this._def.shape(), a = te.objectKeys(t);
    return this._cached = { shape: t, keys: a };
  }
  _parse(t) {
    if (this._getType(t) !== R.object) {
      const o = this._getOrReturnCtx(t);
      return L(o, {
        code: x.invalid_type,
        expected: R.object,
        received: o.parsedType
      }), q;
    }
    const { status: a, ctx: r } = this._processInputParams(t), { shape: n, keys: s } = this._getCached(), c = [];
    if (!(this._def.catchall instanceof St && this._def.unknownKeys === "strip"))
      for (const o in r.data)
        s.includes(o) || c.push(o);
    const i = [];
    for (const o of s) {
      const d = n[o], f = r.data[o];
      i.push({
        key: { status: "valid", value: o },
        value: d._parse(new ut(r, f, r.path, o)),
        alwaysSet: o in r.data
      });
    }
    if (this._def.catchall instanceof St) {
      const o = this._def.unknownKeys;
      if (o === "passthrough")
        for (const d of c)
          i.push({
            key: { status: "valid", value: d },
            value: { status: "valid", value: r.data[d] }
          });
      else if (o === "strict")
        c.length > 0 && (L(r, {
          code: x.unrecognized_keys,
          keys: c
        }), a.dirty());
      else if (o !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const o = this._def.catchall;
      for (const d of c) {
        const f = r.data[d];
        i.push({
          key: { status: "valid", value: d },
          value: o._parse(
            new ut(r, f, r.path, d)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: d in r.data
        });
      }
    }
    return r.common.async ? Promise.resolve().then(async () => {
      const o = [];
      for (const d of i) {
        const f = await d.key;
        o.push({
          key: f,
          value: await d.value,
          alwaysSet: d.alwaysSet
        });
      }
      return o;
    }).then((o) => ke.mergeObjectSync(a, o)) : ke.mergeObjectSync(a, i);
  }
  get shape() {
    return this._def.shape();
  }
  strict(t) {
    return U.errToObj, new oe({
      ...this._def,
      unknownKeys: "strict",
      ...t !== void 0 ? {
        errorMap: (a, r) => {
          var n, s, c, i;
          const o = (c = (s = (n = this._def).errorMap) === null || s === void 0 ? void 0 : s.call(n, a, r).message) !== null && c !== void 0 ? c : r.defaultError;
          return a.code === "unrecognized_keys" ? {
            message: (i = U.errToObj(t).message) !== null && i !== void 0 ? i : o
          } : {
            message: o
          };
        }
      } : {}
    });
  }
  strip() {
    return new oe({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new oe({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(t) {
    return new oe({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...t
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(t) {
    return new oe({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...t._def.shape()
      }),
      typeName: M.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(t, a) {
    return this.augment({ [t]: a });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(t) {
    return new oe({
      ...this._def,
      catchall: t
    });
  }
  pick(t) {
    const a = {};
    return te.objectKeys(t).forEach((r) => {
      t[r] && this.shape[r] && (a[r] = this.shape[r]);
    }), new oe({
      ...this._def,
      shape: () => a
    });
  }
  omit(t) {
    const a = {};
    return te.objectKeys(this.shape).forEach((r) => {
      t[r] || (a[r] = this.shape[r]);
    }), new oe({
      ...this._def,
      shape: () => a
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return Ua(this);
  }
  partial(t) {
    const a = {};
    return te.objectKeys(this.shape).forEach((r) => {
      const n = this.shape[r];
      t && !t[r] ? a[r] = n : a[r] = n.optional();
    }), new oe({
      ...this._def,
      shape: () => a
    });
  }
  required(t) {
    const a = {};
    return te.objectKeys(this.shape).forEach((r) => {
      if (t && !t[r])
        a[r] = this.shape[r];
      else {
        let n = this.shape[r];
        for (; n instanceof Et; )
          n = n._def.innerType;
        a[r] = n;
      }
    }), new oe({
      ...this._def,
      shape: () => a
    });
  }
  keyof() {
    return rb(te.objectKeys(this.shape));
  }
}
oe.create = (e, t) => new oe({
  shape: () => e,
  unknownKeys: "strip",
  catchall: St.create(),
  typeName: M.ZodObject,
  ...W(t)
});
oe.strictCreate = (e, t) => new oe({
  shape: () => e,
  unknownKeys: "strict",
  catchall: St.create(),
  typeName: M.ZodObject,
  ...W(t)
});
oe.lazycreate = (e, t) => new oe({
  shape: e,
  unknownKeys: "strip",
  catchall: St.create(),
  typeName: M.ZodObject,
  ...W(t)
});
class bn extends Y {
  _parse(t) {
    const { ctx: a } = this._processInputParams(t), r = this._def.options;
    function n(s) {
      for (const i of s)
        if (i.result.status === "valid")
          return i.result;
      for (const i of s)
        if (i.result.status === "dirty")
          return a.common.issues.push(...i.ctx.common.issues), i.result;
      const c = s.map((i) => new Ke(i.ctx.common.issues));
      return L(a, {
        code: x.invalid_union,
        unionErrors: c
      }), q;
    }
    if (a.common.async)
      return Promise.all(r.map(async (s) => {
        const c = {
          ...a,
          common: {
            ...a.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await s._parseAsync({
            data: a.data,
            path: a.path,
            parent: c
          }),
          ctx: c
        };
      })).then(n);
    {
      let s;
      const c = [];
      for (const o of r) {
        const d = {
          ...a,
          common: {
            ...a.common,
            issues: []
          },
          parent: null
        }, f = o._parseSync({
          data: a.data,
          path: a.path,
          parent: d
        });
        if (f.status === "valid")
          return f;
        f.status === "dirty" && !s && (s = { result: f, ctx: d }), d.common.issues.length && c.push(d.common.issues);
      }
      if (s)
        return a.common.issues.push(...s.ctx.common.issues), s.result;
      const i = c.map((o) => new Ke(o));
      return L(a, {
        code: x.invalid_union,
        unionErrors: i
      }), q;
    }
  }
  get options() {
    return this._def.options;
  }
}
bn.create = (e, t) => new bn({
  options: e,
  typeName: M.ZodUnion,
  ...W(t)
});
const es = (e) => e instanceof mn ? es(e.schema) : e instanceof Je ? es(e.innerType()) : e instanceof yn ? [e.value] : e instanceof Qt ? e.options : e instanceof gn ? Object.keys(e.enum) : e instanceof _n ? es(e._def.innerType) : e instanceof un ? [void 0] : e instanceof ln ? [null] : null;
class nc extends Y {
  _parse(t) {
    const { ctx: a } = this._processInputParams(t);
    if (a.parsedType !== R.object)
      return L(a, {
        code: x.invalid_type,
        expected: R.object,
        received: a.parsedType
      }), q;
    const r = this.discriminator, n = a.data[r], s = this.optionsMap.get(n);
    return s ? a.common.async ? s._parseAsync({
      data: a.data,
      path: a.path,
      parent: a
    }) : s._parseSync({
      data: a.data,
      path: a.path,
      parent: a
    }) : (L(a, {
      code: x.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [r]
    }), q);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(t, a, r) {
    const n = /* @__PURE__ */ new Map();
    for (const s of a) {
      const c = es(s.shape[t]);
      if (!c)
        throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
      for (const i of c) {
        if (n.has(i))
          throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(i)}`);
        n.set(i, s);
      }
    }
    return new nc({
      typeName: M.ZodDiscriminatedUnion,
      discriminator: t,
      options: a,
      optionsMap: n,
      ...W(r)
    });
  }
}
function Ci(e, t) {
  const a = jt(e), r = jt(t);
  if (e === t)
    return { valid: !0, data: e };
  if (a === R.object && r === R.object) {
    const n = te.objectKeys(t), s = te.objectKeys(e).filter((i) => n.indexOf(i) !== -1), c = { ...e, ...t };
    for (const i of s) {
      const o = Ci(e[i], t[i]);
      if (!o.valid)
        return { valid: !1 };
      c[i] = o.data;
    }
    return { valid: !0, data: c };
  } else if (a === R.array && r === R.array) {
    if (e.length !== t.length)
      return { valid: !1 };
    const n = [];
    for (let s = 0; s < e.length; s++) {
      const c = e[s], i = t[s], o = Ci(c, i);
      if (!o.valid)
        return { valid: !1 };
      n.push(o.data);
    }
    return { valid: !0, data: n };
  } else
    return a === R.date && r === R.date && +e == +t ? { valid: !0, data: e } : { valid: !1 };
}
class hn extends Y {
  _parse(t) {
    const { status: a, ctx: r } = this._processInputParams(t), n = (s, c) => {
      if (Ti(s) || Ti(c))
        return q;
      const i = Ci(s.value, c.value);
      return i.valid ? ((Si(s) || Si(c)) && a.dirty(), { status: a.value, value: i.data }) : (L(r, {
        code: x.invalid_intersection_types
      }), q);
    };
    return r.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      }),
      this._def.right._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      })
    ]).then(([s, c]) => n(s, c)) : n(this._def.left._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }), this._def.right._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }));
  }
}
hn.create = (e, t, a) => new hn({
  left: e,
  right: t,
  typeName: M.ZodIntersection,
  ...W(a)
});
class lt extends Y {
  _parse(t) {
    const { status: a, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== R.array)
      return L(r, {
        code: x.invalid_type,
        expected: R.array,
        received: r.parsedType
      }), q;
    if (r.data.length < this._def.items.length)
      return L(r, {
        code: x.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), q;
    !this._def.rest && r.data.length > this._def.items.length && (L(r, {
      code: x.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), a.dirty());
    const n = [...r.data].map((s, c) => {
      const i = this._def.items[c] || this._def.rest;
      return i ? i._parse(new ut(r, s, r.path, c)) : null;
    }).filter((s) => !!s);
    return r.common.async ? Promise.all(n).then((s) => ke.mergeArray(a, s)) : ke.mergeArray(a, n);
  }
  get items() {
    return this._def.items;
  }
  rest(t) {
    return new lt({
      ...this._def,
      rest: t
    });
  }
}
lt.create = (e, t) => {
  if (!Array.isArray(e))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new lt({
    items: e,
    typeName: M.ZodTuple,
    rest: null,
    ...W(t)
  });
};
class pn extends Y {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: a, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== R.object)
      return L(r, {
        code: x.invalid_type,
        expected: R.object,
        received: r.parsedType
      }), q;
    const n = [], s = this._def.keyType, c = this._def.valueType;
    for (const i in r.data)
      n.push({
        key: s._parse(new ut(r, i, r.path, i)),
        value: c._parse(new ut(r, r.data[i], r.path, i))
      });
    return r.common.async ? ke.mergeObjectAsync(a, n) : ke.mergeObjectSync(a, n);
  }
  get element() {
    return this._def.valueType;
  }
  static create(t, a, r) {
    return a instanceof Y ? new pn({
      keyType: t,
      valueType: a,
      typeName: M.ZodRecord,
      ...W(r)
    }) : new pn({
      keyType: He.create(),
      valueType: t,
      typeName: M.ZodRecord,
      ...W(a)
    });
  }
}
class As extends Y {
  _parse(t) {
    const { status: a, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== R.map)
      return L(r, {
        code: x.invalid_type,
        expected: R.map,
        received: r.parsedType
      }), q;
    const n = this._def.keyType, s = this._def.valueType, c = [...r.data.entries()].map(([i, o], d) => ({
      key: n._parse(new ut(r, i, r.path, [d, "key"])),
      value: s._parse(new ut(r, o, r.path, [d, "value"]))
    }));
    if (r.common.async) {
      const i = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const o of c) {
          const d = await o.key, f = await o.value;
          if (d.status === "aborted" || f.status === "aborted")
            return q;
          (d.status === "dirty" || f.status === "dirty") && a.dirty(), i.set(d.value, f.value);
        }
        return { status: a.value, value: i };
      });
    } else {
      const i = /* @__PURE__ */ new Map();
      for (const o of c) {
        const d = o.key, f = o.value;
        if (d.status === "aborted" || f.status === "aborted")
          return q;
        (d.status === "dirty" || f.status === "dirty") && a.dirty(), i.set(d.value, f.value);
      }
      return { status: a.value, value: i };
    }
  }
}
As.create = (e, t, a) => new As({
  valueType: t,
  keyType: e,
  typeName: M.ZodMap,
  ...W(a)
});
class Sa extends Y {
  _parse(t) {
    const { status: a, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== R.set)
      return L(r, {
        code: x.invalid_type,
        expected: R.set,
        received: r.parsedType
      }), q;
    const n = this._def;
    n.minSize !== null && r.data.size < n.minSize.value && (L(r, {
      code: x.too_small,
      minimum: n.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: n.minSize.message
    }), a.dirty()), n.maxSize !== null && r.data.size > n.maxSize.value && (L(r, {
      code: x.too_big,
      maximum: n.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: n.maxSize.message
    }), a.dirty());
    const s = this._def.valueType;
    function c(o) {
      const d = /* @__PURE__ */ new Set();
      for (const f of o) {
        if (f.status === "aborted")
          return q;
        f.status === "dirty" && a.dirty(), d.add(f.value);
      }
      return { status: a.value, value: d };
    }
    const i = [...r.data.values()].map((o, d) => s._parse(new ut(r, o, r.path, d)));
    return r.common.async ? Promise.all(i).then((o) => c(o)) : c(i);
  }
  min(t, a) {
    return new Sa({
      ...this._def,
      minSize: { value: t, message: U.toString(a) }
    });
  }
  max(t, a) {
    return new Sa({
      ...this._def,
      maxSize: { value: t, message: U.toString(a) }
    });
  }
  size(t, a) {
    return this.min(t, a).max(t, a);
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
Sa.create = (e, t) => new Sa({
  valueType: e,
  minSize: null,
  maxSize: null,
  typeName: M.ZodSet,
  ...W(t)
});
class Ya extends Y {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(t) {
    const { ctx: a } = this._processInputParams(t);
    if (a.parsedType !== R.function)
      return L(a, {
        code: x.invalid_type,
        expected: R.function,
        received: a.parsedType
      }), q;
    function r(i, o) {
      return ks({
        data: i,
        path: a.path,
        errorMaps: [
          a.common.contextualErrorMap,
          a.schemaErrorMap,
          Es(),
          dn
        ].filter((d) => !!d),
        issueData: {
          code: x.invalid_arguments,
          argumentsError: o
        }
      });
    }
    function n(i, o) {
      return ks({
        data: i,
        path: a.path,
        errorMaps: [
          a.common.contextualErrorMap,
          a.schemaErrorMap,
          Es(),
          dn
        ].filter((d) => !!d),
        issueData: {
          code: x.invalid_return_type,
          returnTypeError: o
        }
      });
    }
    const s = { errorMap: a.common.contextualErrorMap }, c = a.data;
    return this._def.returns instanceof or ? Ae(async (...i) => {
      const o = new Ke([]), d = await this._def.args.parseAsync(i, s).catch((u) => {
        throw o.addIssue(r(i, u)), o;
      }), f = await c(...d);
      return await this._def.returns._def.type.parseAsync(f, s).catch((u) => {
        throw o.addIssue(n(f, u)), o;
      });
    }) : Ae((...i) => {
      const o = this._def.args.safeParse(i, s);
      if (!o.success)
        throw new Ke([r(i, o.error)]);
      const d = c(...o.data), f = this._def.returns.safeParse(d, s);
      if (!f.success)
        throw new Ke([n(d, f.error)]);
      return f.data;
    });
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...t) {
    return new Ya({
      ...this._def,
      args: lt.create(t).rest(pa.create())
    });
  }
  returns(t) {
    return new Ya({
      ...this._def,
      returns: t
    });
  }
  implement(t) {
    return this.parse(t);
  }
  strictImplement(t) {
    return this.parse(t);
  }
  static create(t, a, r) {
    return new Ya({
      args: t || lt.create([]).rest(pa.create()),
      returns: a || pa.create(),
      typeName: M.ZodFunction,
      ...W(r)
    });
  }
}
class mn extends Y {
  get schema() {
    return this._def.getter();
  }
  _parse(t) {
    const { ctx: a } = this._processInputParams(t);
    return this._def.getter()._parse({ data: a.data, path: a.path, parent: a });
  }
}
mn.create = (e, t) => new mn({
  getter: e,
  typeName: M.ZodLazy,
  ...W(t)
});
class yn extends Y {
  _parse(t) {
    if (t.data !== this._def.value) {
      const a = this._getOrReturnCtx(t);
      return L(a, {
        received: a.data,
        code: x.invalid_literal,
        expected: this._def.value
      }), q;
    }
    return { status: "valid", value: t.data };
  }
  get value() {
    return this._def.value;
  }
}
yn.create = (e, t) => new yn({
  value: e,
  typeName: M.ZodLiteral,
  ...W(t)
});
function rb(e, t) {
  return new Qt({
    values: e,
    typeName: M.ZodEnum,
    ...W(t)
  });
}
class Qt extends Y {
  _parse(t) {
    if (typeof t.data != "string") {
      const a = this._getOrReturnCtx(t), r = this._def.values;
      return L(a, {
        expected: te.joinValues(r),
        received: a.parsedType,
        code: x.invalid_type
      }), q;
    }
    if (this._def.values.indexOf(t.data) === -1) {
      const a = this._getOrReturnCtx(t), r = this._def.values;
      return L(a, {
        received: a.data,
        code: x.invalid_enum_value,
        options: r
      }), q;
    }
    return Ae(t.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const t = {};
    for (const a of this._def.values)
      t[a] = a;
    return t;
  }
  get Values() {
    const t = {};
    for (const a of this._def.values)
      t[a] = a;
    return t;
  }
  get Enum() {
    const t = {};
    for (const a of this._def.values)
      t[a] = a;
    return t;
  }
  extract(t) {
    return Qt.create(t);
  }
  exclude(t) {
    return Qt.create(this.options.filter((a) => !t.includes(a)));
  }
}
Qt.create = rb;
class gn extends Y {
  _parse(t) {
    const a = te.getValidEnumValues(this._def.values), r = this._getOrReturnCtx(t);
    if (r.parsedType !== R.string && r.parsedType !== R.number) {
      const n = te.objectValues(a);
      return L(r, {
        expected: te.joinValues(n),
        received: r.parsedType,
        code: x.invalid_type
      }), q;
    }
    if (a.indexOf(t.data) === -1) {
      const n = te.objectValues(a);
      return L(r, {
        received: r.data,
        code: x.invalid_enum_value,
        options: n
      }), q;
    }
    return Ae(t.data);
  }
  get enum() {
    return this._def.values;
  }
}
gn.create = (e, t) => new gn({
  values: e,
  typeName: M.ZodNativeEnum,
  ...W(t)
});
class or extends Y {
  unwrap() {
    return this._def.type;
  }
  _parse(t) {
    const { ctx: a } = this._processInputParams(t);
    if (a.parsedType !== R.promise && a.common.async === !1)
      return L(a, {
        code: x.invalid_type,
        expected: R.promise,
        received: a.parsedType
      }), q;
    const r = a.parsedType === R.promise ? a.data : Promise.resolve(a.data);
    return Ae(r.then((n) => this._def.type.parseAsync(n, {
      path: a.path,
      errorMap: a.common.contextualErrorMap
    })));
  }
}
or.create = (e, t) => new or({
  type: e,
  typeName: M.ZodPromise,
  ...W(t)
});
class Je extends Y {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === M.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(t) {
    const { status: a, ctx: r } = this._processInputParams(t), n = this._def.effect || null;
    if (n.type === "preprocess") {
      const c = n.transform(r.data);
      return r.common.async ? Promise.resolve(c).then((i) => this._def.schema._parseAsync({
        data: i,
        path: r.path,
        parent: r
      })) : this._def.schema._parseSync({
        data: c,
        path: r.path,
        parent: r
      });
    }
    const s = {
      addIssue: (c) => {
        L(r, c), c.fatal ? a.abort() : a.dirty();
      },
      get path() {
        return r.path;
      }
    };
    if (s.addIssue = s.addIssue.bind(s), n.type === "refinement") {
      const c = (i) => {
        const o = n.refinement(i, s);
        if (r.common.async)
          return Promise.resolve(o);
        if (o instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return i;
      };
      if (r.common.async === !1) {
        const i = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return i.status === "aborted" ? q : (i.status === "dirty" && a.dirty(), c(i.value), { status: a.value, value: i.value });
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((i) => i.status === "aborted" ? q : (i.status === "dirty" && a.dirty(), c(i.value).then(() => ({ status: a.value, value: i.value }))));
    }
    if (n.type === "transform")
      if (r.common.async === !1) {
        const c = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        if (!xs(c))
          return c;
        const i = n.transform(c.value, s);
        if (i instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: a.value, value: i };
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((c) => xs(c) ? Promise.resolve(n.transform(c.value, s)).then((i) => ({ status: a.value, value: i })) : c);
    te.assertNever(n);
  }
}
Je.create = (e, t, a) => new Je({
  schema: e,
  typeName: M.ZodEffects,
  effect: t,
  ...W(a)
});
Je.createWithPreprocess = (e, t, a) => new Je({
  schema: t,
  effect: { type: "preprocess", transform: e },
  typeName: M.ZodEffects,
  ...W(a)
});
class Et extends Y {
  _parse(t) {
    return this._getType(t) === R.undefined ? Ae(void 0) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Et.create = (e, t) => new Et({
  innerType: e,
  typeName: M.ZodOptional,
  ...W(t)
});
class Ca extends Y {
  _parse(t) {
    return this._getType(t) === R.null ? Ae(null) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Ca.create = (e, t) => new Ca({
  innerType: e,
  typeName: M.ZodNullable,
  ...W(t)
});
class _n extends Y {
  _parse(t) {
    const { ctx: a } = this._processInputParams(t);
    let r = a.data;
    return a.parsedType === R.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({
      data: r,
      path: a.path,
      parent: a
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
_n.create = (e, t) => new _n({
  innerType: e,
  typeName: M.ZodDefault,
  defaultValue: typeof t.default == "function" ? t.default : () => t.default,
  ...W(t)
});
class Os extends Y {
  _parse(t) {
    const { ctx: a } = this._processInputParams(t), r = {
      ...a,
      common: {
        ...a.common,
        issues: []
      }
    }, n = this._def.innerType._parse({
      data: r.data,
      path: r.path,
      parent: {
        ...r
      }
    });
    return Ts(n) ? n.then((s) => ({
      status: "valid",
      value: s.status === "valid" ? s.value : this._def.catchValue({
        get error() {
          return new Ke(r.common.issues);
        },
        input: r.data
      })
    })) : {
      status: "valid",
      value: n.status === "valid" ? n.value : this._def.catchValue({
        get error() {
          return new Ke(r.common.issues);
        },
        input: r.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
Os.create = (e, t) => new Os({
  innerType: e,
  typeName: M.ZodCatch,
  catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
  ...W(t)
});
class Is extends Y {
  _parse(t) {
    if (this._getType(t) !== R.nan) {
      const a = this._getOrReturnCtx(t);
      return L(a, {
        code: x.invalid_type,
        expected: R.nan,
        received: a.parsedType
      }), q;
    }
    return { status: "valid", value: t.data };
  }
}
Is.create = (e) => new Is({
  typeName: M.ZodNaN,
  ...W(e)
});
const N7 = Symbol("zod_brand");
class nb extends Y {
  _parse(t) {
    const { ctx: a } = this._processInputParams(t), r = a.data;
    return this._def.type._parse({
      data: r,
      path: a.path,
      parent: a
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class Ln extends Y {
  _parse(t) {
    const { status: a, ctx: r } = this._processInputParams(t);
    if (r.common.async)
      return (async () => {
        const n = await this._def.in._parseAsync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return n.status === "aborted" ? q : n.status === "dirty" ? (a.dirty(), ab(n.value)) : this._def.out._parseAsync({
          data: n.value,
          path: r.path,
          parent: r
        });
      })();
    {
      const n = this._def.in._parseSync({
        data: r.data,
        path: r.path,
        parent: r
      });
      return n.status === "aborted" ? q : n.status === "dirty" ? (a.dirty(), {
        status: "dirty",
        value: n.value
      }) : this._def.out._parseSync({
        data: n.value,
        path: r.path,
        parent: r
      });
    }
  }
  static create(t, a) {
    return new Ln({
      in: t,
      out: a,
      typeName: M.ZodPipeline
    });
  }
}
const sb = (e, t = {}, a) => e ? ir.create().superRefine((r, n) => {
  var s, c;
  if (!e(r)) {
    const i = typeof t == "function" ? t(r) : typeof t == "string" ? { message: t } : t, o = (c = (s = i.fatal) !== null && s !== void 0 ? s : a) !== null && c !== void 0 ? c : !0, d = typeof i == "string" ? { message: i } : i;
    n.addIssue({ code: "custom", ...d, fatal: o });
  }
}) : ir.create(), R7 = {
  object: oe.lazycreate
};
var M;
(function(e) {
  e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline";
})(M || (M = {}));
const P7 = (e, t = {
  message: `Input not instance of ${e.name}`
}) => sb((a) => a instanceof e, t), cb = He.create, ib = Jt.create, L7 = Is.create, j7 = Xt.create, ob = fn.create, Z7 = Ta.create, D7 = Ss.create, B7 = un.create, F7 = ln.create, U7 = ir.create, $7 = pa.create, z7 = St.create, M7 = Cs.create, H7 = We.create, V7 = oe.create, q7 = oe.strictCreate, K7 = bn.create, W7 = nc.create, G7 = hn.create, Y7 = lt.create, J7 = pn.create, X7 = As.create, Q7 = Sa.create, em = Ya.create, tm = mn.create, am = yn.create, rm = Qt.create, nm = gn.create, sm = or.create, gf = Je.create, cm = Et.create, im = Ca.create, om = Je.createWithPreprocess, dm = Ln.create, fm = () => cb().optional(), um = () => ib().optional(), lm = () => ob().optional(), bm = {
  string: (e) => He.create({ ...e, coerce: !0 }),
  number: (e) => Jt.create({ ...e, coerce: !0 }),
  boolean: (e) => fn.create({
    ...e,
    coerce: !0
  }),
  bigint: (e) => Xt.create({ ...e, coerce: !0 }),
  date: (e) => Ta.create({ ...e, coerce: !0 })
}, hm = q;
var Rt = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: dn,
  setErrorMap: g7,
  getErrorMap: Es,
  makeIssue: ks,
  EMPTY_PATH: _7,
  addIssueToContext: L,
  ParseStatus: ke,
  INVALID: q,
  DIRTY: ab,
  OK: Ae,
  isAborted: Ti,
  isDirty: Si,
  isValid: xs,
  isAsync: Ts,
  get util() {
    return te;
  },
  get objectUtil() {
    return xi;
  },
  ZodParsedType: R,
  getParsedType: jt,
  ZodType: Y,
  ZodString: He,
  ZodNumber: Jt,
  ZodBigInt: Xt,
  ZodBoolean: fn,
  ZodDate: Ta,
  ZodSymbol: Ss,
  ZodUndefined: un,
  ZodNull: ln,
  ZodAny: ir,
  ZodUnknown: pa,
  ZodNever: St,
  ZodVoid: Cs,
  ZodArray: We,
  ZodObject: oe,
  ZodUnion: bn,
  ZodDiscriminatedUnion: nc,
  ZodIntersection: hn,
  ZodTuple: lt,
  ZodRecord: pn,
  ZodMap: As,
  ZodSet: Sa,
  ZodFunction: Ya,
  ZodLazy: mn,
  ZodLiteral: yn,
  ZodEnum: Qt,
  ZodNativeEnum: gn,
  ZodPromise: or,
  ZodEffects: Je,
  ZodTransformer: Je,
  ZodOptional: Et,
  ZodNullable: Ca,
  ZodDefault: _n,
  ZodCatch: Os,
  ZodNaN: Is,
  BRAND: N7,
  ZodBranded: nb,
  ZodPipeline: Ln,
  custom: sb,
  Schema: Y,
  ZodSchema: Y,
  late: R7,
  get ZodFirstPartyTypeKind() {
    return M;
  },
  coerce: bm,
  any: U7,
  array: H7,
  bigint: j7,
  boolean: ob,
  date: Z7,
  discriminatedUnion: W7,
  effect: gf,
  enum: rm,
  function: em,
  instanceof: P7,
  intersection: G7,
  lazy: tm,
  literal: am,
  map: X7,
  nan: L7,
  nativeEnum: nm,
  never: z7,
  null: F7,
  nullable: im,
  number: ib,
  object: V7,
  oboolean: lm,
  onumber: um,
  optional: cm,
  ostring: fm,
  pipeline: dm,
  preprocess: om,
  promise: sm,
  record: J7,
  set: Q7,
  strictObject: q7,
  string: cb,
  symbol: D7,
  transformer: gf,
  tuple: Y7,
  undefined: B7,
  union: K7,
  unknown: $7,
  void: M7,
  NEVER: hm,
  ZodIssueCode: x,
  quotelessJson: y7,
  ZodError: Ke
});
const $e = f8.create({
  isServer: !1,
  allowOutsideOfServer: !0
});
$e.router({
  authorize: $e.procedure.output(Rt.boolean()).mutation(async () => !0),
  connect: $e.procedure.mutation(async () => ""),
  enable: $e.procedure.output(Rt.string()).mutation(async () => ""),
  execute: $e.procedure.input(rf.execute).output(Rt.string()).mutation(async () => ""),
  signMessage: $e.procedure.input(rf.signMessage).output(Rt.string().array()).mutation(async () => []),
  getLoginStatus: $e.procedure.output(
    Rt.object({
      isLoggedIn: Rt.boolean(),
      hasSession: Rt.boolean().optional(),
      isPreauthorized: Rt.boolean().optional()
    })
  ).mutation(async () => ({
    isLoggedIn: !0
  })),
  addStarknetChain: $e.procedure.mutation((e) => {
    throw Error("not implemented");
  }),
  switchStarknetChain: $e.procedure.mutation((e) => {
    throw Error("not implemented");
  }),
  watchAsset: $e.procedure.mutation((e) => {
    throw Error("not implemented");
  }),
  updateModal: $e.procedure.subscription(async () => {
  })
});
const xm = ({
  iframe: e,
  origin: t
}) => q9({
  links: [
    $9({
      enabled: (a) => process.env.NODE_ENV === "development" && typeof window < "u" || process.env.NODE_ENV === "development" && a.direction === "down" && a.result instanceof Error
    }),
    N9({
      condition(a) {
        if (!e && a.type === "subscription")
          throw new Error(
            "subscription is not supported without an iframe window"
          );
        return !!e;
      },
      true: vi.windowLink({
        window,
        postWindow: e,
        postOrigin: "*"
      }),
      false: vi.popupLink({
        listenWindow: window,
        createPopup: () => {
          const a = window?.outerWidth ?? window?.innerWidth ?? window?.screen.width ?? 0, r = window?.outerHeight ?? window?.innerHeight ?? window?.screen.height ?? 0, n = window?.screenLeft ?? window?.screenX ?? 0, s = (window?.screenTop ?? window?.screenY ?? 0) + r / 2 - 562 / 2, c = n + a / 2 - 886 / 2, i = window.open(
            `${t}/interstitialLogin`,
            "popup",
            `width=886,height=562,top=${s},left=${c},toolbar=no,menubar=no,scrollbars=no,location=no,status=no,popup=1`
          );
          if (!i)
            throw new Error("Could not open popup");
          return i;
        },
        postOrigin: "*"
      })
    })
  ]
}), { NetworkName: pm } = Wu, $a = pm, mm = $a.SN_GOERLI;
function ym(e) {
  try {
    const { origin: t } = new URL(e);
    if (t.includes("localhost") || t.includes("127.0.0.1"))
      return mm;
    if (t.includes("hydrogen"))
      return $a.SN_GOERLI;
    if (t.includes("staging"))
      return $a.SN_MAIN;
    if (t.includes("dev"))
      return $a.SN_GOERLI2;
    if (t.includes("argent.xyz"))
      return $a.SN_MAIN;
  } catch {
    console.warn(
      "Could not determine network from target URL, defaulting to mainnet-alpha"
    );
  }
  return $a.SN_MAIN;
}
const Tm = Oi(
  async (e, t) => {
    const a = typeof window < "u" ? window : void 0;
    if (!a)
      throw new Error("window is not defined");
    const r = ym(e), n = new Ka({ network: r });
    return k4(
      {
        host: a.location.origin,
        id: "argentWebWallet",
        icon: "https://www.argent.xyz/favicon.ico",
        name: "Argent Web Wallet",
        version: "1.0.0"
      },
      n,
      t
    );
  },
  (e) => `${e}`
);
export {
  Tm as getWebWalletStarknetObject,
  xm as trpcProxyClient
};
