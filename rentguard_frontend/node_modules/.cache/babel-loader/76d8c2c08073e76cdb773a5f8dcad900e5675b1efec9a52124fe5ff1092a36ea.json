{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nimport { parseLosslessNumber } from './numberParsers.js';\nimport { revive } from './revive.js';\n/**\n * The LosslessJSON.parse() method parses a string as JSON, optionally transforming\n * the value produced by parsing.\n *\n * The parser is based on the parser of Tan Li Hou shared in\n * https://lihautan.com/json-parser-with-javascript/\n *\n * @param text\n * The string to parse as JSON. See the JSON object for a description of JSON syntax.\n *\n * @param [reviver]\n * If a function, prescribes how the value originally produced by parsing is\n * transformed, before being returned.\n *\n * @param [parseNumber=parseLosslessNumber]\n * Pass a custom number parser. Input is a string, and the output can be unknown\n * numeric value: number, bigint, LosslessNumber, or a custom BigNumber library.\n *\n * @returns Returns the Object corresponding to the given JSON text.\n *\n * @throws Throws a SyntaxError exception if the string to parse is not valid JSON.\n */\nexport function parse(text, reviver) {\n  var parseNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : parseLosslessNumber;\n  var i = 0;\n  var value = parseValue();\n  expectValue(value);\n  expectEndOfInput();\n  return reviver ? revive(value, reviver) : value;\n  function parseObject() {\n    if (text.charCodeAt(i) === codeOpeningBrace) {\n      i++;\n      skipWhitespace();\n      var object = {};\n      var initial = true;\n      while (i < text.length && text.charCodeAt(i) !== codeClosingBrace) {\n        if (!initial) {\n          eatComma();\n          skipWhitespace();\n        } else {\n          initial = false;\n        }\n        var start = i;\n        var key = parseString();\n        if (key === undefined) {\n          throwObjectKeyExpected();\n        }\n        skipWhitespace();\n        eatColon();\n        var _value = parseValue();\n        if (_value === undefined) {\n          throwObjectValueExpected();\n        }\n\n        // TODO: test deep equal instead of strict equal\n        if (Object.prototype.hasOwnProperty.call(object, key) && !isDeepEqual(_value, object[key])) {\n          // Note that we could also test `if(key in object) {...}`\n          // or `if (object[key] !== 'undefined') {...}`, but that is slower.\n          throwDuplicateKey(key, start + 1);\n        }\n        object[key] = _value;\n      }\n      if (text.charCodeAt(i) !== codeClosingBrace) {\n        throwObjectKeyOrEndExpected();\n      }\n      i++;\n      return object;\n    }\n  }\n  function parseArray() {\n    if (text.charCodeAt(i) === codeOpeningBracket) {\n      i++;\n      skipWhitespace();\n      var array = [];\n      var initial = true;\n      while (i < text.length && text.charCodeAt(i) !== codeClosingBracket) {\n        if (!initial) {\n          eatComma();\n        } else {\n          initial = false;\n        }\n        var _value2 = parseValue();\n        expectArrayItem(_value2);\n        array.push(_value2);\n      }\n      if (text.charCodeAt(i) !== codeClosingBracket) {\n        throwArrayItemOrEndExpected();\n      }\n      i++;\n      return array;\n    }\n  }\n  function parseValue() {\n    var _ref, _ref2, _ref3, _ref4, _ref5, _parseString;\n    skipWhitespace();\n    var value = (_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_parseString = parseString()) !== null && _parseString !== void 0 ? _parseString : parseNumeric()) !== null && _ref5 !== void 0 ? _ref5 : parseObject()) !== null && _ref4 !== void 0 ? _ref4 : parseArray()) !== null && _ref3 !== void 0 ? _ref3 : parseKeyword('true', true)) !== null && _ref2 !== void 0 ? _ref2 : parseKeyword('false', false)) !== null && _ref !== void 0 ? _ref : parseKeyword('null', null);\n    skipWhitespace();\n    return value;\n  }\n  function parseKeyword(name, value) {\n    if (text.slice(i, i + name.length) === name) {\n      i += name.length;\n      return value;\n    }\n  }\n  function skipWhitespace() {\n    while (isWhitespace(text.charCodeAt(i))) {\n      i++;\n    }\n  }\n  function parseString() {\n    if (text.charCodeAt(i) === codeDoubleQuote) {\n      i++;\n      var result = '';\n      while (i < text.length && text.charCodeAt(i) !== codeDoubleQuote) {\n        if (text.charCodeAt(i) === codeBackslash) {\n          var char = text[i + 1];\n          var escapeChar = escapeCharacters[char];\n          if (escapeChar !== undefined) {\n            result += escapeChar;\n            i++;\n          } else if (char === 'u') {\n            if (isHex(text.charCodeAt(i + 2)) && isHex(text.charCodeAt(i + 3)) && isHex(text.charCodeAt(i + 4)) && isHex(text.charCodeAt(i + 5))) {\n              result += String.fromCharCode(parseInt(text.slice(i + 2, i + 6), 16));\n              i += 5;\n            } else {\n              throwInvalidUnicodeCharacter(i);\n            }\n          } else {\n            throwInvalidEscapeCharacter(i);\n          }\n        } else {\n          if (isValidStringCharacter(text.charCodeAt(i))) {\n            result += text[i];\n          } else {\n            throwInvalidCharacter(text[i]);\n          }\n        }\n        i++;\n      }\n      expectEndOfString();\n      i++;\n      return result;\n    }\n  }\n  function parseNumeric() {\n    var start = i;\n    if (text.charCodeAt(i) === codeMinus) {\n      i++;\n      expectDigit(start);\n    }\n    if (text.charCodeAt(i) === codeZero) {\n      i++;\n    } else if (isNonZeroDigit(text.charCodeAt(i))) {\n      i++;\n      while (isDigit(text.charCodeAt(i))) {\n        i++;\n      }\n    }\n    if (text.charCodeAt(i) === codeDot) {\n      i++;\n      expectDigit(start);\n      while (isDigit(text.charCodeAt(i))) {\n        i++;\n      }\n    }\n    if (text.charCodeAt(i) === codeLowercaseE || text.charCodeAt(i) === codeUppercaseE) {\n      i++;\n      if (text.charCodeAt(i) === codeMinus || text.charCodeAt(i) === codePlus) {\n        i++;\n      }\n      expectDigit(start);\n      while (isDigit(text.charCodeAt(i))) {\n        i++;\n      }\n    }\n    if (i > start) {\n      return parseNumber(text.slice(start, i));\n    }\n  }\n  function eatComma() {\n    if (text.charCodeAt(i) !== codeComma) {\n      throw new SyntaxError(\"Comma ',' expected after value \".concat(gotAt()));\n    }\n    i++;\n  }\n  function eatColon() {\n    if (text.charCodeAt(i) !== codeColon) {\n      throw new SyntaxError(\"Colon ':' expected after property name \".concat(gotAt()));\n    }\n    i++;\n  }\n  function expectValue(value) {\n    if (value === undefined) {\n      throw new SyntaxError(\"JSON value expected \".concat(gotAt()));\n    }\n  }\n  function expectArrayItem(value) {\n    if (value === undefined) {\n      throw new SyntaxError(\"Array item expected \".concat(gotAt()));\n    }\n  }\n  function expectEndOfInput() {\n    if (i < text.length) {\n      throw new SyntaxError(\"Expected end of input \".concat(gotAt()));\n    }\n  }\n  function expectDigit(start) {\n    if (!isDigit(text.charCodeAt(i))) {\n      var numSoFar = text.slice(start, i);\n      throw new SyntaxError(\"Invalid number '\".concat(numSoFar, \"', expecting a digit \").concat(gotAt()));\n    }\n  }\n  function expectEndOfString() {\n    if (text.charCodeAt(i) !== codeDoubleQuote) {\n      throw new SyntaxError(\"End of string '\\\"' expected \".concat(gotAt()));\n    }\n  }\n  function throwObjectKeyExpected() {\n    throw new SyntaxError(\"Quoted object key expected \".concat(gotAt()));\n  }\n  function throwDuplicateKey(key, pos) {\n    throw new SyntaxError(\"Duplicate key '\".concat(key, \"' encountered at position \").concat(pos));\n  }\n  function throwObjectKeyOrEndExpected() {\n    throw new SyntaxError(\"Quoted object key or end of object '}' expected \".concat(gotAt()));\n  }\n  function throwArrayItemOrEndExpected() {\n    throw new SyntaxError(\"Array item or end of array ']' expected \".concat(gotAt()));\n  }\n  function throwInvalidCharacter(char) {\n    throw new SyntaxError(\"Invalid character '\".concat(char, \"' \").concat(pos()));\n  }\n  function throwInvalidEscapeCharacter(start) {\n    var chars = text.slice(start, start + 2);\n    throw new SyntaxError(\"Invalid escape character '\".concat(chars, \"' \").concat(pos()));\n  }\n  function throwObjectValueExpected() {\n    throw new SyntaxError(\"Object value expected after ':' \".concat(pos()));\n  }\n  function throwInvalidUnicodeCharacter(start) {\n    var end = start + 2;\n    while (/\\w/.test(text[end])) {\n      end++;\n    }\n    var chars = text.slice(start, end);\n    throw new SyntaxError(\"Invalid unicode character '\".concat(chars, \"' \").concat(pos()));\n  }\n\n  // zero based character position\n  function pos() {\n    return \"at position \".concat(i);\n  }\n  function got() {\n    return i < text.length ? \"but got '\".concat(text[i], \"'\") : 'but reached end of input';\n  }\n  function gotAt() {\n    return got() + ' ' + pos();\n  }\n}\nfunction isWhitespace(code) {\n  return code === codeSpace || code === codeNewline || code === codeTab || code === codeReturn;\n}\nfunction isHex(code) {\n  return code >= codeZero && code <= codeNine || code >= codeUppercaseA && code <= codeUppercaseF || code >= codeLowercaseA && code <= codeLowercaseF;\n}\nfunction isDigit(code) {\n  return code >= codeZero && code <= codeNine;\n}\nfunction isNonZeroDigit(code) {\n  return code >= codeOne && code <= codeNine;\n}\nexport function isValidStringCharacter(code) {\n  return code >= 0x20 && code <= 0x10ffff;\n}\nexport function isDeepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.length === b.length && a.every(function (item, index) {\n      return isDeepEqual(item, b[index]);\n    });\n  }\n  if (isObject(a) && isObject(b)) {\n    var keys = _toConsumableArray(new Set([].concat(_toConsumableArray(Object.keys(a)), _toConsumableArray(Object.keys(b)))));\n    return keys.every(function (key) {\n      return isDeepEqual(a[key], b[key]);\n    });\n  }\n  return false;\n}\nfunction isObject(value) {\n  return _typeof(value) === 'object' && value !== null;\n}\n\n// map with all escape characters\nvar escapeCharacters = {\n  '\"': '\"',\n  '\\\\': '\\\\',\n  '/': '/',\n  b: '\\b',\n  f: '\\f',\n  n: '\\n',\n  r: '\\r',\n  t: '\\t'\n  // note that \\u is handled separately in parseString()\n};\nvar codeBackslash = 0x5c; // \"\\\"\nvar codeOpeningBrace = 0x7b; // \"{\"\nvar codeClosingBrace = 0x7d; // \"}\"\nvar codeOpeningBracket = 0x5b; // \"[\"\nvar codeClosingBracket = 0x5d; // \"]\"\nvar codeSpace = 0x20; // \" \"\nvar codeNewline = 0xa; // \"\\n\"\nvar codeTab = 0x9; // \"\\t\"\nvar codeReturn = 0xd; // \"\\r\"\nvar codeDoubleQuote = 0x0022; // \"\nvar codePlus = 0x2b; // \"+\"\nvar codeMinus = 0x2d; // \"-\"\nvar codeZero = 0x30;\nvar codeOne = 0x31;\nvar codeNine = 0x39;\nvar codeComma = 0x2c; // \",\"\nvar codeDot = 0x2e; // \".\" (dot, period)\nvar codeColon = 0x3a; // \":\"\nexport var codeUppercaseA = 0x41; // \"A\"\nexport var codeLowercaseA = 0x61; // \"a\"\nexport var codeUppercaseE = 0x45; // \"E\"\nexport var codeLowercaseE = 0x65; // \"e\"\nexport var codeUppercaseF = 0x46; // \"F\"\nexport var codeLowercaseF = 0x66; // \"f\"","map":{"version":3,"names":["parseLosslessNumber","revive","parse","text","reviver","parseNumber","arguments","length","undefined","i","value","parseValue","expectValue","expectEndOfInput","parseObject","charCodeAt","codeOpeningBrace","skipWhitespace","object","initial","codeClosingBrace","eatComma","start","key","parseString","throwObjectKeyExpected","eatColon","_value","throwObjectValueExpected","Object","prototype","hasOwnProperty","call","isDeepEqual","throwDuplicateKey","throwObjectKeyOrEndExpected","parseArray","codeOpeningBracket","array","codeClosingBracket","_value2","expectArrayItem","push","throwArrayItemOrEndExpected","_ref","_ref2","_ref3","_ref4","_ref5","_parseString","parseNumeric","parseKeyword","name","slice","isWhitespace","codeDoubleQuote","result","codeBackslash","char","escapeChar","escapeCharacters","isHex","String","fromCharCode","parseInt","throwInvalidUnicodeCharacter","throwInvalidEscapeCharacter","isValidStringCharacter","throwInvalidCharacter","expectEndOfString","codeMinus","expectDigit","codeZero","isNonZeroDigit","isDigit","codeDot","codeLowercaseE","codeUppercaseE","codePlus","codeComma","SyntaxError","concat","gotAt","codeColon","numSoFar","pos","chars","end","test","got","code","codeSpace","codeNewline","codeTab","codeReturn","codeNine","codeUppercaseA","codeUppercaseF","codeLowercaseA","codeLowercaseF","codeOne","a","b","Array","isArray","every","item","index","isObject","keys","_toConsumableArray","Set","_typeof","f","n","r","t"],"sources":["/Users/sean/Desktop/BinanceSimulator/mern-exercise-tracker/node_modules/lossless-json/src/parse.ts"],"sourcesContent":["import { parseLosslessNumber } from './numberParsers.js'\nimport { revive } from './revive.js'\nimport type { NumberParser, Reviver } from './types'\nimport { GenericObject, JavaScriptValue } from './types'\n\n/**\n * The LosslessJSON.parse() method parses a string as JSON, optionally transforming\n * the value produced by parsing.\n *\n * The parser is based on the parser of Tan Li Hou shared in\n * https://lihautan.com/json-parser-with-javascript/\n *\n * @param text\n * The string to parse as JSON. See the JSON object for a description of JSON syntax.\n *\n * @param [reviver]\n * If a function, prescribes how the value originally produced by parsing is\n * transformed, before being returned.\n *\n * @param [parseNumber=parseLosslessNumber]\n * Pass a custom number parser. Input is a string, and the output can be unknown\n * numeric value: number, bigint, LosslessNumber, or a custom BigNumber library.\n *\n * @returns Returns the Object corresponding to the given JSON text.\n *\n * @throws Throws a SyntaxError exception if the string to parse is not valid JSON.\n */\nexport function parse(\n  text: string,\n  reviver?: Reviver,\n  parseNumber: NumberParser = parseLosslessNumber\n): JavaScriptValue {\n  let i = 0\n  const value = parseValue()\n  expectValue(value)\n  expectEndOfInput()\n\n  return reviver ? revive(value, reviver) : value\n\n  function parseObject(): GenericObject<unknown> | undefined {\n    if (text.charCodeAt(i) === codeOpeningBrace) {\n      i++\n      skipWhitespace()\n\n      const object: GenericObject<unknown> = {}\n      let initial = true\n      while (i < text.length && text.charCodeAt(i) !== codeClosingBrace) {\n        if (!initial) {\n          eatComma()\n          skipWhitespace()\n        } else {\n          initial = false\n        }\n\n        const start = i\n\n        const key = parseString()\n        if (key === undefined) {\n          throwObjectKeyExpected()\n        }\n\n        skipWhitespace()\n        eatColon()\n        const value = parseValue()\n\n        if (value === undefined) {\n          throwObjectValueExpected()\n        }\n\n        // TODO: test deep equal instead of strict equal\n        if (Object.prototype.hasOwnProperty.call(object, key) && !isDeepEqual(value, object[key])) {\n          // Note that we could also test `if(key in object) {...}`\n          // or `if (object[key] !== 'undefined') {...}`, but that is slower.\n          throwDuplicateKey(key, start + 1)\n        }\n\n        object[key] = value\n      }\n\n      if (text.charCodeAt(i) !== codeClosingBrace) {\n        throwObjectKeyOrEndExpected()\n      }\n      i++\n\n      return object\n    }\n  }\n\n  function parseArray(): Array<unknown> | unknown {\n    if (text.charCodeAt(i) === codeOpeningBracket) {\n      i++\n      skipWhitespace()\n\n      const array = []\n      let initial = true\n      while (i < text.length && text.charCodeAt(i) !== codeClosingBracket) {\n        if (!initial) {\n          eatComma()\n        } else {\n          initial = false\n        }\n\n        const value = parseValue()\n        expectArrayItem(value)\n        array.push(value)\n      }\n\n      if (text.charCodeAt(i) !== codeClosingBracket) {\n        throwArrayItemOrEndExpected()\n      }\n      i++\n\n      return array\n    }\n  }\n\n  function parseValue(): unknown {\n    skipWhitespace()\n\n    const value =\n      parseString() ??\n      parseNumeric() ??\n      parseObject() ??\n      parseArray() ??\n      parseKeyword('true', true) ??\n      parseKeyword('false', false) ??\n      parseKeyword('null', null)\n\n    skipWhitespace()\n\n    return value\n  }\n\n  function parseKeyword(name: string, value: unknown): unknown | undefined {\n    if (text.slice(i, i + name.length) === name) {\n      i += name.length\n      return value\n    }\n  }\n\n  function skipWhitespace() {\n    while (isWhitespace(text.charCodeAt(i))) {\n      i++\n    }\n  }\n\n  function parseString() {\n    if (text.charCodeAt(i) === codeDoubleQuote) {\n      i++\n      let result = ''\n      while (i < text.length && text.charCodeAt(i) !== codeDoubleQuote) {\n        if (text.charCodeAt(i) === codeBackslash) {\n          const char = text[i + 1]\n          const escapeChar = escapeCharacters[char]\n          if (escapeChar !== undefined) {\n            result += escapeChar\n            i++\n          } else if (char === 'u') {\n            if (\n              isHex(text.charCodeAt(i + 2)) &&\n              isHex(text.charCodeAt(i + 3)) &&\n              isHex(text.charCodeAt(i + 4)) &&\n              isHex(text.charCodeAt(i + 5))\n            ) {\n              result += String.fromCharCode(parseInt(text.slice(i + 2, i + 6), 16))\n              i += 5\n            } else {\n              throwInvalidUnicodeCharacter(i)\n            }\n          } else {\n            throwInvalidEscapeCharacter(i)\n          }\n        } else {\n          if (isValidStringCharacter(text.charCodeAt(i))) {\n            result += text[i]\n          } else {\n            throwInvalidCharacter(text[i])\n          }\n        }\n        i++\n      }\n      expectEndOfString()\n      i++\n      return result\n    }\n  }\n\n  function parseNumeric() {\n    const start = i\n    if (text.charCodeAt(i) === codeMinus) {\n      i++\n      expectDigit(start)\n    }\n\n    if (text.charCodeAt(i) === codeZero) {\n      i++\n    } else if (isNonZeroDigit(text.charCodeAt(i))) {\n      i++\n      while (isDigit(text.charCodeAt(i))) {\n        i++\n      }\n    }\n\n    if (text.charCodeAt(i) === codeDot) {\n      i++\n      expectDigit(start)\n      while (isDigit(text.charCodeAt(i))) {\n        i++\n      }\n    }\n\n    if (text.charCodeAt(i) === codeLowercaseE || text.charCodeAt(i) === codeUppercaseE) {\n      i++\n      if (text.charCodeAt(i) === codeMinus || text.charCodeAt(i) === codePlus) {\n        i++\n      }\n      expectDigit(start)\n      while (isDigit(text.charCodeAt(i))) {\n        i++\n      }\n    }\n\n    if (i > start) {\n      return parseNumber(text.slice(start, i))\n    }\n  }\n\n  function eatComma() {\n    if (text.charCodeAt(i) !== codeComma) {\n      throw new SyntaxError(`Comma ',' expected after value ${gotAt()}`)\n    }\n    i++\n  }\n\n  function eatColon() {\n    if (text.charCodeAt(i) !== codeColon) {\n      throw new SyntaxError(`Colon ':' expected after property name ${gotAt()}`)\n    }\n    i++\n  }\n\n  function expectValue(value: unknown) {\n    if (value === undefined) {\n      throw new SyntaxError(`JSON value expected ${gotAt()}`)\n    }\n  }\n\n  function expectArrayItem(value: unknown) {\n    if (value === undefined) {\n      throw new SyntaxError(`Array item expected ${gotAt()}`)\n    }\n  }\n\n  function expectEndOfInput() {\n    if (i < text.length) {\n      throw new SyntaxError(`Expected end of input ${gotAt()}`)\n    }\n  }\n\n  function expectDigit(start: number) {\n    if (!isDigit(text.charCodeAt(i))) {\n      const numSoFar = text.slice(start, i)\n      throw new SyntaxError(`Invalid number '${numSoFar}', expecting a digit ${gotAt()}`)\n    }\n  }\n\n  function expectEndOfString() {\n    if (text.charCodeAt(i) !== codeDoubleQuote) {\n      throw new SyntaxError(`End of string '\"' expected ${gotAt()}`)\n    }\n  }\n\n  function throwObjectKeyExpected() {\n    throw new SyntaxError(`Quoted object key expected ${gotAt()}`)\n  }\n\n  function throwDuplicateKey(key: string, pos: number) {\n    throw new SyntaxError(`Duplicate key '${key}' encountered at position ${pos}`)\n  }\n\n  function throwObjectKeyOrEndExpected() {\n    throw new SyntaxError(`Quoted object key or end of object '}' expected ${gotAt()}`)\n  }\n\n  function throwArrayItemOrEndExpected() {\n    throw new SyntaxError(`Array item or end of array ']' expected ${gotAt()}`)\n  }\n\n  function throwInvalidCharacter(char: string) {\n    throw new SyntaxError(`Invalid character '${char}' ${pos()}`)\n  }\n\n  function throwInvalidEscapeCharacter(start: number) {\n    const chars = text.slice(start, start + 2)\n    throw new SyntaxError(`Invalid escape character '${chars}' ${pos()}`)\n  }\n\n  function throwObjectValueExpected() {\n    throw new SyntaxError(`Object value expected after ':' ${pos()}`)\n  }\n\n  function throwInvalidUnicodeCharacter(start: number) {\n    let end = start + 2\n    while (/\\w/.test(text[end])) {\n      end++\n    }\n    const chars = text.slice(start, end)\n    throw new SyntaxError(`Invalid unicode character '${chars}' ${pos()}`)\n  }\n\n  // zero based character position\n  function pos(): string {\n    return `at position ${i}`\n  }\n\n  function got(): string {\n    return i < text.length ? `but got '${text[i]}'` : 'but reached end of input'\n  }\n\n  function gotAt(): string {\n    return got() + ' ' + pos()\n  }\n}\n\nfunction isWhitespace(code: number): boolean {\n  return code === codeSpace || code === codeNewline || code === codeTab || code === codeReturn\n}\n\nfunction isHex(code: number): boolean {\n  return (\n    (code >= codeZero && code <= codeNine) ||\n    (code >= codeUppercaseA && code <= codeUppercaseF) ||\n    (code >= codeLowercaseA && code <= codeLowercaseF)\n  )\n}\n\nfunction isDigit(code: number): boolean {\n  return code >= codeZero && code <= codeNine\n}\n\nfunction isNonZeroDigit(code: number): boolean {\n  return code >= codeOne && code <= codeNine\n}\n\nexport function isValidStringCharacter(code: number): boolean {\n  return code >= 0x20 && code <= 0x10ffff\n}\n\nexport function isDeepEqual(a: unknown, b: unknown): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.length === b.length && a.every((item, index) => isDeepEqual(item, b[index]))\n  }\n\n  if (isObject(a) && isObject(b)) {\n    const keys = [...new Set([...Object.keys(a), ...Object.keys(b)])]\n    return keys.every((key) => isDeepEqual(a[key], b[key]))\n  }\n\n  return false\n}\n\nfunction isObject(value: unknown): value is Record<string, unknown> {\n  return typeof value === 'object' && value !== null\n}\n\n// map with all escape characters\nconst escapeCharacters: GenericObject<string> = {\n  '\"': '\"',\n  '\\\\': '\\\\',\n  '/': '/',\n  b: '\\b',\n  f: '\\f',\n  n: '\\n',\n  r: '\\r',\n  t: '\\t'\n  // note that \\u is handled separately in parseString()\n}\n\nconst codeBackslash = 0x5c // \"\\\"\nconst codeOpeningBrace = 0x7b // \"{\"\nconst codeClosingBrace = 0x7d // \"}\"\nconst codeOpeningBracket = 0x5b // \"[\"\nconst codeClosingBracket = 0x5d // \"]\"\nconst codeSpace = 0x20 // \" \"\nconst codeNewline = 0xa // \"\\n\"\nconst codeTab = 0x9 // \"\\t\"\nconst codeReturn = 0xd // \"\\r\"\nconst codeDoubleQuote = 0x0022 // \"\nconst codePlus = 0x2b // \"+\"\nconst codeMinus = 0x2d // \"-\"\nconst codeZero = 0x30\nconst codeOne = 0x31\nconst codeNine = 0x39\nconst codeComma = 0x2c // \",\"\nconst codeDot = 0x2e // \".\" (dot, period)\nconst codeColon = 0x3a // \":\"\nexport const codeUppercaseA = 0x41 // \"A\"\nexport const codeLowercaseA = 0x61 // \"a\"\nexport const codeUppercaseE = 0x45 // \"E\"\nexport const codeLowercaseE = 0x65 // \"e\"\nexport const codeUppercaseF = 0x46 // \"F\"\nexport const codeLowercaseF = 0x66 // \"f\"\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}