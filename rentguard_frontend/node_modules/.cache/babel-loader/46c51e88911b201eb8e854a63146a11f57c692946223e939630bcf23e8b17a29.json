{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nimport { extractSignificantDigits, getUnsafeNumberReason, isInteger, isNumber, UnsafeNumberReason } from './utils.js';\n\n/**\n * A lossless number. Stores its numeric value as string\n */\nexport var LosslessNumber = /*#__PURE__*/function () {\n  function LosslessNumber(value) {\n    _classCallCheck(this, LosslessNumber);\n    // numeric value as string\n    // type information\n    _defineProperty(this, \"isLosslessNumber\", true);\n    if (!isNumber(value)) {\n      throw new Error('Invalid number (value: \"' + value + '\")');\n    }\n    this.value = value;\n  }\n\n  /**\n   * Get the value of the LosslessNumber as number or bigint.\n   *\n   * - a number is returned for safe numbers and decimal values that only lose some insignificant digits\n   * - a bigint is returned for big integer numbers\n   * - an Error is thrown for values that will overflow or underflow\n   *\n   * Note that you can implement your own strategy for conversion by just getting the value as string\n   * via .toString(), and using util functions like isInteger, isSafeNumber, getUnsafeNumberReason,\n   * and toSafeNumberOrThrow to convert it to a numeric value.\n   */\n  _createClass(LosslessNumber, [{\n    key: \"valueOf\",\n    value: function valueOf() {\n      var unsafeReason = getUnsafeNumberReason(this.value);\n\n      // safe or truncate_float\n      if (unsafeReason === undefined || unsafeReason === UnsafeNumberReason.truncate_float) {\n        return parseFloat(this.value);\n      }\n\n      // truncate_integer\n      if (isInteger(this.value)) {\n        return BigInt(this.value);\n      }\n\n      // overflow or underflow\n      throw new Error('Cannot safely convert to number: ' + \"the value '\".concat(this.value, \"' would \").concat(unsafeReason, \" and become \").concat(parseFloat(this.value)));\n    }\n\n    /**\n     * Get the value of the LosslessNumber as string.\n     */\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.value;\n    }\n\n    // Note: we do NOT implement a .toJSON() method, and you should not implement\n    // or use that, it cannot safely turn the numeric value in the string into\n    // stringified JSON since it has to be parsed into a number first.\n  }]);\n  return LosslessNumber;\n}();\n\n/**\n * Test whether a value is a LosslessNumber\n */\nexport function isLosslessNumber(value) {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return value && _typeof(value) === 'object' && value.isLosslessNumber === true || false;\n}\n\n/**\n * Convert a number into a LosslessNumber if this is possible in a safe way\n * If the value has too many digits, or is NaN or Infinity, an error will be thrown\n */\nexport function toLosslessNumber(value) {\n  if (extractSignificantDigits(value + '').length > 15) {\n    throw new Error('Invalid number: contains more than 15 digits and is most likely truncated and unsafe by itself ' + \"(value: \".concat(value, \")\"));\n  }\n  if (isNaN(value)) {\n    throw new Error('Invalid number: NaN');\n  }\n  if (!isFinite(value)) {\n    throw new Error('Invalid number: ' + value);\n  }\n  return new LosslessNumber(String(value));\n}","map":{"version":3,"names":["extractSignificantDigits","getUnsafeNumberReason","isInteger","isNumber","UnsafeNumberReason","LosslessNumber","value","_classCallCheck","_defineProperty","Error","_createClass","key","valueOf","unsafeReason","undefined","truncate_float","parseFloat","BigInt","concat","toString","isLosslessNumber","_typeof","toLosslessNumber","length","isNaN","isFinite","String"],"sources":["/Users/sean/Desktop/BinanceSimulator/mern-exercise-tracker/node_modules/lossless-json/src/LosslessNumber.ts"],"sourcesContent":["import {\n  extractSignificantDigits,\n  getUnsafeNumberReason,\n  isInteger,\n  isNumber,\n  UnsafeNumberReason\n} from './utils.js'\n\n/**\n * A lossless number. Stores its numeric value as string\n */\nexport class LosslessNumber {\n  // numeric value as string\n  value: string\n\n  // type information\n  isLosslessNumber = true\n\n  constructor(value: string) {\n    if (!isNumber(value)) {\n      throw new Error('Invalid number (value: \"' + value + '\")')\n    }\n\n    this.value = value\n  }\n\n  /**\n   * Get the value of the LosslessNumber as number or bigint.\n   *\n   * - a number is returned for safe numbers and decimal values that only lose some insignificant digits\n   * - a bigint is returned for big integer numbers\n   * - an Error is thrown for values that will overflow or underflow\n   *\n   * Note that you can implement your own strategy for conversion by just getting the value as string\n   * via .toString(), and using util functions like isInteger, isSafeNumber, getUnsafeNumberReason,\n   * and toSafeNumberOrThrow to convert it to a numeric value.\n   */\n  valueOf(): number | bigint {\n    const unsafeReason = getUnsafeNumberReason(this.value)\n\n    // safe or truncate_float\n    if (unsafeReason === undefined || unsafeReason === UnsafeNumberReason.truncate_float) {\n      return parseFloat(this.value)\n    }\n\n    // truncate_integer\n    if (isInteger(this.value)) {\n      return BigInt(this.value)\n    }\n\n    // overflow or underflow\n    throw new Error(\n      'Cannot safely convert to number: ' +\n        `the value '${this.value}' would ${unsafeReason} and become ${parseFloat(this.value)}`\n    )\n  }\n\n  /**\n   * Get the value of the LosslessNumber as string.\n   */\n  toString(): string {\n    return this.value\n  }\n\n  // Note: we do NOT implement a .toJSON() method, and you should not implement\n  // or use that, it cannot safely turn the numeric value in the string into\n  // stringified JSON since it has to be parsed into a number first.\n}\n\n/**\n * Test whether a value is a LosslessNumber\n */\nexport function isLosslessNumber(value: unknown): value is LosslessNumber {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return (value && typeof value === 'object' && value.isLosslessNumber === true) || false\n}\n\n/**\n * Convert a number into a LosslessNumber if this is possible in a safe way\n * If the value has too many digits, or is NaN or Infinity, an error will be thrown\n */\nexport function toLosslessNumber(value: number): LosslessNumber {\n  if (extractSignificantDigits(value + '').length > 15) {\n    throw new Error(\n      'Invalid number: contains more than 15 digits and is most likely truncated and unsafe by itself ' +\n        `(value: ${value})`\n    )\n  }\n\n  if (isNaN(value)) {\n    throw new Error('Invalid number: NaN')\n  }\n\n  if (!isFinite(value)) {\n    throw new Error('Invalid number: ' + value)\n  }\n\n  return new LosslessNumber(String(value))\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SACEA,wBAAwB,EACxBC,qBAAqB,EACrBC,SAAS,EACTC,QAAQ,EACRC,kBAAkB,QACb,YAAY;;AAEnB;AACA;AACA;AACA,WAAaC,cAAc;EAOzB,SAAAA,eAAYC,KAAa,EAAE;IAAAC,eAAA,OAAAF,cAAA;IAN3B;IAGA;IAAAG,eAAA,2BACmB,IAAI;IAGrB,IAAI,CAACL,QAAQ,CAACG,KAAK,CAAC,EAAE;MACpB,MAAM,IAAIG,KAAK,CAAC,0BAA0B,GAAGH,KAAK,GAAG,IAAI,CAAC;IAC5D;IAEA,IAAI,CAACA,KAAK,GAAGA,KAAK;EACpB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAVEI,YAAA,CAAAL,cAAA;IAAAM,GAAA;IAAAL,KAAA,EAWA,SAAAM,QAAA,EAA2B;MACzB,IAAMC,YAAY,GAAGZ,qBAAqB,CAAC,IAAI,CAACK,KAAK,CAAC;;MAEtD;MACA,IAAIO,YAAY,KAAKC,SAAS,IAAID,YAAY,KAAKT,kBAAkB,CAACW,cAAc,EAAE;QACpF,OAAOC,UAAU,CAAC,IAAI,CAACV,KAAK,CAAC;MAC/B;;MAEA;MACA,IAAIJ,SAAS,CAAC,IAAI,CAACI,KAAK,CAAC,EAAE;QACzB,OAAOW,MAAM,CAAC,IAAI,CAACX,KAAK,CAAC;MAC3B;;MAEA;MACA,MAAM,IAAIG,KAAK,CACb,mCAAmC,iBAAAS,MAAA,CACnB,IAAI,CAACZ,KAAK,cAAAY,MAAA,CAAWL,YAAY,kBAAAK,MAAA,CAAeF,UAAU,CAAC,IAAI,CAACV,KAAK,CAAC,CACxF,CAAC;IACH;;IAEA;AACF;AACA;EAFE;IAAAK,GAAA;IAAAL,KAAA,EAGA,SAAAa,SAAA,EAAmB;MACjB,OAAO,IAAI,CAACb,KAAK;IACnB;;IAEA;IACA;IACA;EAAA;EAAA,OAAAD,cAAA;AAAA;;AAGF;AACA;AACA;AACA,OAAO,SAASe,gBAAgBA,CAACd,KAAc,EAA2B;EACxE;EACA;EACA,OAAQA,KAAK,IAAIe,OAAA,CAAOf,KAAK,MAAK,QAAQ,IAAIA,KAAK,CAACc,gBAAgB,KAAK,IAAI,IAAK,KAAK;AACzF;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASE,gBAAgBA,CAAChB,KAAa,EAAkB;EAC9D,IAAIN,wBAAwB,CAACM,KAAK,GAAG,EAAE,CAAC,CAACiB,MAAM,GAAG,EAAE,EAAE;IACpD,MAAM,IAAId,KAAK,CACb,iGAAiG,cAAAS,MAAA,CACpFZ,KAAK,MACpB,CAAC;EACH;EAEA,IAAIkB,KAAK,CAAClB,KAAK,CAAC,EAAE;IAChB,MAAM,IAAIG,KAAK,CAAC,qBAAqB,CAAC;EACxC;EAEA,IAAI,CAACgB,QAAQ,CAACnB,KAAK,CAAC,EAAE;IACpB,MAAM,IAAIG,KAAK,CAAC,kBAAkB,GAAGH,KAAK,CAAC;EAC7C;EAEA,OAAO,IAAID,cAAc,CAACqB,MAAM,CAACpB,KAAK,CAAC,CAAC;AAC1C"},"metadata":{},"sourceType":"module","externalDependencies":[]}