{"ast":null,"code":"import { keccak_256 } from '@noble/hashes/sha3';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { utf8ToBytes } from '@noble/hashes/utils';\nimport { Field, mod, validateField, invert } from '@noble/curves/abstract/modular';\nimport { poseidon } from '@noble/curves/abstract/poseidon';\nimport { weierstrass, DER } from '@noble/curves/abstract/weierstrass';\nimport * as u from '@noble/curves/abstract/utils';\nimport { getHash } from '@noble/curves/_shortw_utils';\nconst CURVE_ORDER = BigInt('3618502788666131213697322783095070105526743751716087489154079457884512865583');\nexport const MAX_VALUE = BigInt('0x800000000000000000000000000000000000000000000000000000000000000');\nconst nBitLength = 252;\nfunction bits2int(bytes) {\n  while (bytes[0] === 0) bytes = bytes.subarray(1);\n  const delta = bytes.length * 8 - nBitLength;\n  const num = u.bytesToNumberBE(bytes);\n  return delta > 0 ? num >> BigInt(delta) : num;\n}\nfunction hex0xToBytes(hex) {\n  if (typeof hex === 'string') {\n    hex = strip0x(hex);\n    if (hex.length & 1) hex = '0' + hex;\n  }\n  return u.hexToBytes(hex);\n}\nconst curve = weierstrass({\n  a: BigInt(1),\n  b: BigInt('3141592653589793238462643383279502884197169399375105820974944592307816406665'),\n  Fp: Field(BigInt('0x800000000000011000000000000000000000000000000000000000000000001')),\n  n: CURVE_ORDER,\n  nBitLength,\n  Gx: BigInt('874739451078007766457464989774322083649278607533249481151382481072868806602'),\n  Gy: BigInt('152666792071518830868575557812948353041420400780739481342941381225525861407'),\n  h: BigInt(1),\n  lowS: false,\n  ...getHash(sha256),\n  bits2int,\n  bits2int_modN: bytes => {\n    const hex = u.bytesToNumberBE(bytes).toString(16);\n    if (hex.length === 63) bytes = hex0xToBytes(hex + '0');\n    return mod(bits2int(bytes), CURVE_ORDER);\n  }\n});\nexport const _starkCurve = curve;\nfunction ensureBytes(hex) {\n  return u.ensureBytes('', typeof hex === 'string' ? hex0xToBytes(hex) : hex);\n}\nfunction normPrivKey(privKey) {\n  return u.bytesToHex(ensureBytes(privKey)).padStart(64, '0');\n}\nexport function getPublicKey(privKey, isCompressed = false) {\n  return curve.getPublicKey(normPrivKey(privKey), isCompressed);\n}\nexport function getSharedSecret(privKeyA, pubKeyB) {\n  return curve.getSharedSecret(normPrivKey(privKeyA), pubKeyB);\n}\nfunction checkSignature(signature) {\n  const {\n    r,\n    s\n  } = signature;\n  if (r < 0n || r >= MAX_VALUE) throw new Error(`Signature.r should be [1, ${MAX_VALUE})`);\n  const w = invert(s, CURVE_ORDER);\n  if (w < 0n || w >= MAX_VALUE) throw new Error(`inv(Signature.s) should be [1, ${MAX_VALUE})`);\n}\nfunction checkMessage(msgHash) {\n  const bytes = ensureBytes(msgHash);\n  const num = u.bytesToNumberBE(bytes);\n  if (num >= MAX_VALUE) throw new Error(`msgHash should be [0, ${MAX_VALUE})`);\n  return bytes;\n}\nexport function sign(msgHash, privKey, opts) {\n  const sig = curve.sign(checkMessage(msgHash), normPrivKey(privKey), opts);\n  checkSignature(sig);\n  return sig;\n}\nexport function verify(signature, msgHash, pubKey) {\n  if (!(signature instanceof Signature)) {\n    const bytes = ensureBytes(signature);\n    try {\n      signature = Signature.fromDER(bytes);\n    } catch (derError) {\n      if (!(derError instanceof DER.Err)) throw derError;\n      signature = Signature.fromCompact(bytes);\n    }\n  }\n  checkSignature(signature);\n  return curve.verify(signature, checkMessage(msgHash), ensureBytes(pubKey));\n}\nconst {\n  CURVE,\n  ProjectivePoint,\n  Signature,\n  utils\n} = curve;\nexport { CURVE, ProjectivePoint, Signature, utils };\nfunction extractX(bytes) {\n  const hex = u.bytesToHex(bytes.subarray(1));\n  const stripped = hex.replace(/^0+/gm, '');\n  return `0x${stripped}`;\n}\nfunction strip0x(hex) {\n  return hex.replace(/^0x/i, '');\n}\nexport function grindKey(seed) {\n  const _seed = ensureBytes(seed);\n  const sha256mask = 2n ** 256n;\n  const limit = sha256mask - mod(sha256mask, CURVE_ORDER);\n  for (let i = 0;; i++) {\n    const key = sha256Num(u.concatBytes(_seed, u.numberToVarBytesBE(BigInt(i))));\n    if (key < limit) return mod(key, CURVE_ORDER).toString(16);\n    if (i === 100000) throw new Error('grindKey is broken: tried 100k vals');\n  }\n}\nexport function getStarkKey(privateKey) {\n  return extractX(getPublicKey(privateKey, true));\n}\nexport function ethSigToPrivate(signature) {\n  signature = strip0x(signature);\n  if (signature.length !== 130) throw new Error('Wrong ethereum signature');\n  return grindKey(signature.substring(0, 64));\n}\nconst MASK_31 = 2n ** 31n - 1n;\nconst int31 = n => Number(n & MASK_31);\nexport function getAccountPath(layer, application, ethereumAddress, index) {\n  const layerNum = int31(sha256Num(layer));\n  const applicationNum = int31(sha256Num(application));\n  const eth = u.hexToNumber(strip0x(ethereumAddress));\n  return `m/2645'/${layerNum}'/${applicationNum}'/${int31(eth)}'/${int31(eth >> 31n)}'/${index}`;\n}\nconst PEDERSEN_POINTS = [new ProjectivePoint(2089986280348253421170679821480865132823066470938446095505822317253594081284n, 1713931329540660377023406109199410414810705867260802078187082345529207694986n, 1n), new ProjectivePoint(996781205833008774514500082376783249102396023663454813447423147977397232763n, 1668503676786377725805489344771023921079126552019160156920634619255970485781n, 1n), new ProjectivePoint(2251563274489750535117886426533222435294046428347329203627021249169616184184n, 1798716007562728905295480679789526322175868328062420237419143593021674992973n, 1n), new ProjectivePoint(2138414695194151160943305727036575959195309218611738193261179310511854807447n, 113410276730064486255102093846540133784865286929052426931474106396135072156n, 1n), new ProjectivePoint(2379962749567351885752724891227938183011949129833673362440656643086021394946n, 776496453633298175483985398648758586525933812536653089401905292063708816422n, 1n)];\nfunction pedersenPrecompute(p1, p2) {\n  const out = [];\n  let p = p1;\n  for (let i = 0; i < 248; i++) {\n    out.push(p);\n    p = p.double();\n  }\n  p = p2;\n  for (let i = 0; i < 4; i++) {\n    out.push(p);\n    p = p.double();\n  }\n  return out;\n}\nconst PEDERSEN_POINTS1 = pedersenPrecompute(PEDERSEN_POINTS[1], PEDERSEN_POINTS[2]);\nconst PEDERSEN_POINTS2 = pedersenPrecompute(PEDERSEN_POINTS[3], PEDERSEN_POINTS[4]);\nfunction pedersenArg(arg) {\n  let value;\n  if (typeof arg === 'bigint') {\n    value = arg;\n  } else if (typeof arg === 'number') {\n    if (!Number.isSafeInteger(arg)) throw new Error(`Invalid pedersenArg: ${arg}`);\n    value = BigInt(arg);\n  } else {\n    value = u.bytesToNumberBE(ensureBytes(arg));\n  }\n  if (!(0n <= value && value < curve.CURVE.Fp.ORDER)) throw new Error(`PedersenArg should be 0 <= value < CURVE.P: ${value}`);\n  return value;\n}\nfunction pedersenSingle(point, value, constants) {\n  let x = pedersenArg(value);\n  for (let j = 0; j < 252; j++) {\n    const pt = constants[j];\n    if (pt.equals(point)) throw new Error('Same point');\n    if ((x & 1n) !== 0n) point = point.add(pt);\n    x >>= 1n;\n  }\n  return point;\n}\nexport function pedersen(x, y) {\n  let point = PEDERSEN_POINTS[0];\n  point = pedersenSingle(point, x, PEDERSEN_POINTS1);\n  point = pedersenSingle(point, y, PEDERSEN_POINTS2);\n  return extractX(point.toRawBytes(true));\n}\nexport const computeHashOnElements = (data, fn = pedersen) => [0, ...data, data.length].reduce((x, y) => fn(x, y));\nconst MASK_250 = u.bitMask(250);\nexport const keccak = data => u.bytesToNumberBE(keccak_256(data)) & MASK_250;\nconst sha256Num = data => u.bytesToNumberBE(sha256(data));\nexport const Fp251 = Field(BigInt('3618502788666131213697322783095070105623107215331596699973092056135872020481'));\nfunction poseidonRoundConstant(Fp, name, idx) {\n  const val = Fp.fromBytes(sha256(utf8ToBytes(`${name}${idx}`)));\n  return Fp.create(val);\n}\nexport function _poseidonMDS(Fp, name, m, attempt = 0) {\n  const x_values = [];\n  const y_values = [];\n  for (let i = 0; i < m; i++) {\n    x_values.push(poseidonRoundConstant(Fp, `${name}x`, attempt * m + i));\n    y_values.push(poseidonRoundConstant(Fp, `${name}y`, attempt * m + i));\n  }\n  if (new Set([...x_values, ...y_values]).size !== 2 * m) throw new Error('X and Y values are not distinct');\n  return x_values.map(x => y_values.map(y => Fp.inv(Fp.sub(x, y))));\n}\nconst MDS_SMALL = [[3, 1, 1], [1, -1, 1], [1, 1, -2]].map(i => i.map(BigInt));\nexport function poseidonBasic(opts, mds) {\n  validateField(opts.Fp);\n  if (!Number.isSafeInteger(opts.rate) || !Number.isSafeInteger(opts.capacity)) throw new Error(`Wrong poseidon opts: ${opts}`);\n  const m = opts.rate + opts.capacity;\n  const rounds = opts.roundsFull + opts.roundsPartial;\n  const roundConstants = [];\n  for (let i = 0; i < rounds; i++) {\n    const row = [];\n    for (let j = 0; j < m; j++) row.push(poseidonRoundConstant(opts.Fp, 'Hades', m * i + j));\n    roundConstants.push(row);\n  }\n  const res = poseidon({\n    ...opts,\n    t: m,\n    sboxPower: 3,\n    reversePartialPowIdx: true,\n    mds,\n    roundConstants\n  });\n  res.m = m;\n  res.rate = opts.rate;\n  res.capacity = opts.capacity;\n  return res;\n}\nexport function poseidonCreate(opts, mdsAttempt = 0) {\n  const m = opts.rate + opts.capacity;\n  if (!Number.isSafeInteger(mdsAttempt)) throw new Error(`Wrong mdsAttempt=${mdsAttempt}`);\n  return poseidonBasic(opts, _poseidonMDS(opts.Fp, 'HadesMDS', m, mdsAttempt));\n}\nexport const poseidonSmall = poseidonBasic({\n  Fp: Fp251,\n  rate: 2,\n  capacity: 1,\n  roundsFull: 8,\n  roundsPartial: 83\n}, MDS_SMALL);\nexport function poseidonHash(x, y, fn = poseidonSmall) {\n  return fn([x, y, 2n])[0];\n}\nexport function poseidonHashFunc(x, y, fn = poseidonSmall) {\n  return u.numberToVarBytesBE(poseidonHash(u.bytesToNumberBE(x), u.bytesToNumberBE(y), fn));\n}\nexport function poseidonHashSingle(x, fn = poseidonSmall) {\n  return fn([x, 0n, 1n])[0];\n}\nexport function poseidonHashMany(values, fn = poseidonSmall) {\n  const {\n    m,\n    rate\n  } = fn;\n  if (!Array.isArray(values)) throw new Error('bigint array expected in values');\n  const padded = Array.from(values);\n  padded.push(1n);\n  while (padded.length % rate !== 0) padded.push(0n);\n  let state = new Array(m).fill(0n);\n  for (let i = 0; i < padded.length; i += rate) {\n    for (let j = 0; j < rate; j++) state[j] += padded[i + j];\n    state = fn(state);\n  }\n  return state[0];\n}","map":{"version":3,"names":["keccak_256","sha256","utf8ToBytes","Field","mod","validateField","invert","poseidon","weierstrass","DER","u","getHash","CURVE_ORDER","BigInt","MAX_VALUE","nBitLength","bits2int","bytes","subarray","delta","length","num","bytesToNumberBE","hex0xToBytes","hex","strip0x","hexToBytes","curve","a","b","Fp","n","Gx","Gy","h","lowS","bits2int_modN","toString","_starkCurve","ensureBytes","normPrivKey","privKey","bytesToHex","padStart","getPublicKey","isCompressed","getSharedSecret","privKeyA","pubKeyB","checkSignature","signature","r","s","Error","w","checkMessage","msgHash","sign","opts","sig","verify","pubKey","Signature","fromDER","derError","Err","fromCompact","CURVE","ProjectivePoint","utils","extractX","stripped","replace","grindKey","seed","_seed","sha256mask","limit","i","key","sha256Num","concatBytes","numberToVarBytesBE","getStarkKey","privateKey","ethSigToPrivate","substring","MASK_31","int31","Number","getAccountPath","layer","application","ethereumAddress","index","layerNum","applicationNum","eth","hexToNumber","PEDERSEN_POINTS","pedersenPrecompute","p1","p2","out","p","push","double","PEDERSEN_POINTS1","PEDERSEN_POINTS2","pedersenArg","arg","value","isSafeInteger","ORDER","pedersenSingle","point","constants","x","j","pt","equals","add","pedersen","y","toRawBytes","computeHashOnElements","data","fn","reduce","MASK_250","bitMask","keccak","Fp251","poseidonRoundConstant","name","idx","val","fromBytes","create","_poseidonMDS","m","attempt","x_values","y_values","Set","size","map","inv","sub","MDS_SMALL","poseidonBasic","mds","rate","capacity","rounds","roundsFull","roundsPartial","roundConstants","row","res","t","sboxPower","reversePartialPowIdx","poseidonCreate","mdsAttempt","poseidonSmall","poseidonHash","poseidonHashFunc","poseidonHashSingle","poseidonHashMany","values","Array","isArray","padded","from","state","fill"],"sources":["/Users/sean/Desktop/BinanceSimulator/mern-exercise-tracker/node_modules/@scure/starknet/lib/esm/index.js"],"sourcesContent":["import { keccak_256 } from '@noble/hashes/sha3';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { utf8ToBytes } from '@noble/hashes/utils';\nimport { Field, mod, validateField, invert } from '@noble/curves/abstract/modular';\nimport { poseidon } from '@noble/curves/abstract/poseidon';\nimport { weierstrass, DER } from '@noble/curves/abstract/weierstrass';\nimport * as u from '@noble/curves/abstract/utils';\nimport { getHash } from '@noble/curves/_shortw_utils';\nconst CURVE_ORDER = BigInt('3618502788666131213697322783095070105526743751716087489154079457884512865583');\nexport const MAX_VALUE = BigInt('0x800000000000000000000000000000000000000000000000000000000000000');\nconst nBitLength = 252;\nfunction bits2int(bytes) {\n    while (bytes[0] === 0)\n        bytes = bytes.subarray(1);\n    const delta = bytes.length * 8 - nBitLength;\n    const num = u.bytesToNumberBE(bytes);\n    return delta > 0 ? num >> BigInt(delta) : num;\n}\nfunction hex0xToBytes(hex) {\n    if (typeof hex === 'string') {\n        hex = strip0x(hex);\n        if (hex.length & 1)\n            hex = '0' + hex;\n    }\n    return u.hexToBytes(hex);\n}\nconst curve = weierstrass({\n    a: BigInt(1),\n    b: BigInt('3141592653589793238462643383279502884197169399375105820974944592307816406665'),\n    Fp: Field(BigInt('0x800000000000011000000000000000000000000000000000000000000000001')),\n    n: CURVE_ORDER,\n    nBitLength,\n    Gx: BigInt('874739451078007766457464989774322083649278607533249481151382481072868806602'),\n    Gy: BigInt('152666792071518830868575557812948353041420400780739481342941381225525861407'),\n    h: BigInt(1),\n    lowS: false,\n    ...getHash(sha256),\n    bits2int,\n    bits2int_modN: (bytes) => {\n        const hex = u.bytesToNumberBE(bytes).toString(16);\n        if (hex.length === 63)\n            bytes = hex0xToBytes(hex + '0');\n        return mod(bits2int(bytes), CURVE_ORDER);\n    },\n});\nexport const _starkCurve = curve;\nfunction ensureBytes(hex) {\n    return u.ensureBytes('', typeof hex === 'string' ? hex0xToBytes(hex) : hex);\n}\nfunction normPrivKey(privKey) {\n    return u.bytesToHex(ensureBytes(privKey)).padStart(64, '0');\n}\nexport function getPublicKey(privKey, isCompressed = false) {\n    return curve.getPublicKey(normPrivKey(privKey), isCompressed);\n}\nexport function getSharedSecret(privKeyA, pubKeyB) {\n    return curve.getSharedSecret(normPrivKey(privKeyA), pubKeyB);\n}\nfunction checkSignature(signature) {\n    const { r, s } = signature;\n    if (r < 0n || r >= MAX_VALUE)\n        throw new Error(`Signature.r should be [1, ${MAX_VALUE})`);\n    const w = invert(s, CURVE_ORDER);\n    if (w < 0n || w >= MAX_VALUE)\n        throw new Error(`inv(Signature.s) should be [1, ${MAX_VALUE})`);\n}\nfunction checkMessage(msgHash) {\n    const bytes = ensureBytes(msgHash);\n    const num = u.bytesToNumberBE(bytes);\n    if (num >= MAX_VALUE)\n        throw new Error(`msgHash should be [0, ${MAX_VALUE})`);\n    return bytes;\n}\nexport function sign(msgHash, privKey, opts) {\n    const sig = curve.sign(checkMessage(msgHash), normPrivKey(privKey), opts);\n    checkSignature(sig);\n    return sig;\n}\nexport function verify(signature, msgHash, pubKey) {\n    if (!(signature instanceof Signature)) {\n        const bytes = ensureBytes(signature);\n        try {\n            signature = Signature.fromDER(bytes);\n        }\n        catch (derError) {\n            if (!(derError instanceof DER.Err))\n                throw derError;\n            signature = Signature.fromCompact(bytes);\n        }\n    }\n    checkSignature(signature);\n    return curve.verify(signature, checkMessage(msgHash), ensureBytes(pubKey));\n}\nconst { CURVE, ProjectivePoint, Signature, utils } = curve;\nexport { CURVE, ProjectivePoint, Signature, utils };\nfunction extractX(bytes) {\n    const hex = u.bytesToHex(bytes.subarray(1));\n    const stripped = hex.replace(/^0+/gm, '');\n    return `0x${stripped}`;\n}\nfunction strip0x(hex) {\n    return hex.replace(/^0x/i, '');\n}\nexport function grindKey(seed) {\n    const _seed = ensureBytes(seed);\n    const sha256mask = 2n ** 256n;\n    const limit = sha256mask - mod(sha256mask, CURVE_ORDER);\n    for (let i = 0;; i++) {\n        const key = sha256Num(u.concatBytes(_seed, u.numberToVarBytesBE(BigInt(i))));\n        if (key < limit)\n            return mod(key, CURVE_ORDER).toString(16);\n        if (i === 100000)\n            throw new Error('grindKey is broken: tried 100k vals');\n    }\n}\nexport function getStarkKey(privateKey) {\n    return extractX(getPublicKey(privateKey, true));\n}\nexport function ethSigToPrivate(signature) {\n    signature = strip0x(signature);\n    if (signature.length !== 130)\n        throw new Error('Wrong ethereum signature');\n    return grindKey(signature.substring(0, 64));\n}\nconst MASK_31 = 2n ** 31n - 1n;\nconst int31 = (n) => Number(n & MASK_31);\nexport function getAccountPath(layer, application, ethereumAddress, index) {\n    const layerNum = int31(sha256Num(layer));\n    const applicationNum = int31(sha256Num(application));\n    const eth = u.hexToNumber(strip0x(ethereumAddress));\n    return `m/2645'/${layerNum}'/${applicationNum}'/${int31(eth)}'/${int31(eth >> 31n)}'/${index}`;\n}\nconst PEDERSEN_POINTS = [\n    new ProjectivePoint(2089986280348253421170679821480865132823066470938446095505822317253594081284n, 1713931329540660377023406109199410414810705867260802078187082345529207694986n, 1n),\n    new ProjectivePoint(996781205833008774514500082376783249102396023663454813447423147977397232763n, 1668503676786377725805489344771023921079126552019160156920634619255970485781n, 1n),\n    new ProjectivePoint(2251563274489750535117886426533222435294046428347329203627021249169616184184n, 1798716007562728905295480679789526322175868328062420237419143593021674992973n, 1n),\n    new ProjectivePoint(2138414695194151160943305727036575959195309218611738193261179310511854807447n, 113410276730064486255102093846540133784865286929052426931474106396135072156n, 1n),\n    new ProjectivePoint(2379962749567351885752724891227938183011949129833673362440656643086021394946n, 776496453633298175483985398648758586525933812536653089401905292063708816422n, 1n),\n];\nfunction pedersenPrecompute(p1, p2) {\n    const out = [];\n    let p = p1;\n    for (let i = 0; i < 248; i++) {\n        out.push(p);\n        p = p.double();\n    }\n    p = p2;\n    for (let i = 0; i < 4; i++) {\n        out.push(p);\n        p = p.double();\n    }\n    return out;\n}\nconst PEDERSEN_POINTS1 = pedersenPrecompute(PEDERSEN_POINTS[1], PEDERSEN_POINTS[2]);\nconst PEDERSEN_POINTS2 = pedersenPrecompute(PEDERSEN_POINTS[3], PEDERSEN_POINTS[4]);\nfunction pedersenArg(arg) {\n    let value;\n    if (typeof arg === 'bigint') {\n        value = arg;\n    }\n    else if (typeof arg === 'number') {\n        if (!Number.isSafeInteger(arg))\n            throw new Error(`Invalid pedersenArg: ${arg}`);\n        value = BigInt(arg);\n    }\n    else {\n        value = u.bytesToNumberBE(ensureBytes(arg));\n    }\n    if (!(0n <= value && value < curve.CURVE.Fp.ORDER))\n        throw new Error(`PedersenArg should be 0 <= value < CURVE.P: ${value}`);\n    return value;\n}\nfunction pedersenSingle(point, value, constants) {\n    let x = pedersenArg(value);\n    for (let j = 0; j < 252; j++) {\n        const pt = constants[j];\n        if (pt.equals(point))\n            throw new Error('Same point');\n        if ((x & 1n) !== 0n)\n            point = point.add(pt);\n        x >>= 1n;\n    }\n    return point;\n}\nexport function pedersen(x, y) {\n    let point = PEDERSEN_POINTS[0];\n    point = pedersenSingle(point, x, PEDERSEN_POINTS1);\n    point = pedersenSingle(point, y, PEDERSEN_POINTS2);\n    return extractX(point.toRawBytes(true));\n}\nexport const computeHashOnElements = (data, fn = pedersen) => [0, ...data, data.length].reduce((x, y) => fn(x, y));\nconst MASK_250 = u.bitMask(250);\nexport const keccak = (data) => u.bytesToNumberBE(keccak_256(data)) & MASK_250;\nconst sha256Num = (data) => u.bytesToNumberBE(sha256(data));\nexport const Fp251 = Field(BigInt('3618502788666131213697322783095070105623107215331596699973092056135872020481'));\nfunction poseidonRoundConstant(Fp, name, idx) {\n    const val = Fp.fromBytes(sha256(utf8ToBytes(`${name}${idx}`)));\n    return Fp.create(val);\n}\nexport function _poseidonMDS(Fp, name, m, attempt = 0) {\n    const x_values = [];\n    const y_values = [];\n    for (let i = 0; i < m; i++) {\n        x_values.push(poseidonRoundConstant(Fp, `${name}x`, attempt * m + i));\n        y_values.push(poseidonRoundConstant(Fp, `${name}y`, attempt * m + i));\n    }\n    if (new Set([...x_values, ...y_values]).size !== 2 * m)\n        throw new Error('X and Y values are not distinct');\n    return x_values.map((x) => y_values.map((y) => Fp.inv(Fp.sub(x, y))));\n}\nconst MDS_SMALL = [\n    [3, 1, 1],\n    [1, -1, 1],\n    [1, 1, -2],\n].map((i) => i.map(BigInt));\nexport function poseidonBasic(opts, mds) {\n    validateField(opts.Fp);\n    if (!Number.isSafeInteger(opts.rate) || !Number.isSafeInteger(opts.capacity))\n        throw new Error(`Wrong poseidon opts: ${opts}`);\n    const m = opts.rate + opts.capacity;\n    const rounds = opts.roundsFull + opts.roundsPartial;\n    const roundConstants = [];\n    for (let i = 0; i < rounds; i++) {\n        const row = [];\n        for (let j = 0; j < m; j++)\n            row.push(poseidonRoundConstant(opts.Fp, 'Hades', m * i + j));\n        roundConstants.push(row);\n    }\n    const res = poseidon({\n        ...opts,\n        t: m,\n        sboxPower: 3,\n        reversePartialPowIdx: true,\n        mds,\n        roundConstants,\n    });\n    res.m = m;\n    res.rate = opts.rate;\n    res.capacity = opts.capacity;\n    return res;\n}\nexport function poseidonCreate(opts, mdsAttempt = 0) {\n    const m = opts.rate + opts.capacity;\n    if (!Number.isSafeInteger(mdsAttempt))\n        throw new Error(`Wrong mdsAttempt=${mdsAttempt}`);\n    return poseidonBasic(opts, _poseidonMDS(opts.Fp, 'HadesMDS', m, mdsAttempt));\n}\nexport const poseidonSmall = poseidonBasic({ Fp: Fp251, rate: 2, capacity: 1, roundsFull: 8, roundsPartial: 83 }, MDS_SMALL);\nexport function poseidonHash(x, y, fn = poseidonSmall) {\n    return fn([x, y, 2n])[0];\n}\nexport function poseidonHashFunc(x, y, fn = poseidonSmall) {\n    return u.numberToVarBytesBE(poseidonHash(u.bytesToNumberBE(x), u.bytesToNumberBE(y), fn));\n}\nexport function poseidonHashSingle(x, fn = poseidonSmall) {\n    return fn([x, 0n, 1n])[0];\n}\nexport function poseidonHashMany(values, fn = poseidonSmall) {\n    const { m, rate } = fn;\n    if (!Array.isArray(values))\n        throw new Error('bigint array expected in values');\n    const padded = Array.from(values);\n    padded.push(1n);\n    while (padded.length % rate !== 0)\n        padded.push(0n);\n    let state = new Array(m).fill(0n);\n    for (let i = 0; i < padded.length; i += rate) {\n        for (let j = 0; j < rate; j++)\n            state[j] += padded[i + j];\n        state = fn(state);\n    }\n    return state[0];\n}\n"],"mappings":"AAAA,SAASA,UAAU,QAAQ,oBAAoB;AAC/C,SAASC,MAAM,QAAQ,sBAAsB;AAC7C,SAASC,WAAW,QAAQ,qBAAqB;AACjD,SAASC,KAAK,EAAEC,GAAG,EAAEC,aAAa,EAAEC,MAAM,QAAQ,gCAAgC;AAClF,SAASC,QAAQ,QAAQ,iCAAiC;AAC1D,SAASC,WAAW,EAAEC,GAAG,QAAQ,oCAAoC;AACrE,OAAO,KAAKC,CAAC,MAAM,8BAA8B;AACjD,SAASC,OAAO,QAAQ,6BAA6B;AACrD,MAAMC,WAAW,GAAGC,MAAM,CAAC,8EAA8E,CAAC;AAC1G,OAAO,MAAMC,SAAS,GAAGD,MAAM,CAAC,mEAAmE,CAAC;AACpG,MAAME,UAAU,GAAG,GAAG;AACtB,SAASC,QAAQA,CAACC,KAAK,EAAE;EACrB,OAAOA,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,EACjBA,KAAK,GAAGA,KAAK,CAACC,QAAQ,CAAC,CAAC,CAAC;EAC7B,MAAMC,KAAK,GAAGF,KAAK,CAACG,MAAM,GAAG,CAAC,GAAGL,UAAU;EAC3C,MAAMM,GAAG,GAAGX,CAAC,CAACY,eAAe,CAACL,KAAK,CAAC;EACpC,OAAOE,KAAK,GAAG,CAAC,GAAGE,GAAG,IAAIR,MAAM,CAACM,KAAK,CAAC,GAAGE,GAAG;AACjD;AACA,SAASE,YAAYA,CAACC,GAAG,EAAE;EACvB,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;IACzBA,GAAG,GAAGC,OAAO,CAACD,GAAG,CAAC;IAClB,IAAIA,GAAG,CAACJ,MAAM,GAAG,CAAC,EACdI,GAAG,GAAG,GAAG,GAAGA,GAAG;EACvB;EACA,OAAOd,CAAC,CAACgB,UAAU,CAACF,GAAG,CAAC;AAC5B;AACA,MAAMG,KAAK,GAAGnB,WAAW,CAAC;EACtBoB,CAAC,EAAEf,MAAM,CAAC,CAAC,CAAC;EACZgB,CAAC,EAAEhB,MAAM,CAAC,8EAA8E,CAAC;EACzFiB,EAAE,EAAE3B,KAAK,CAACU,MAAM,CAAC,mEAAmE,CAAC,CAAC;EACtFkB,CAAC,EAAEnB,WAAW;EACdG,UAAU;EACViB,EAAE,EAAEnB,MAAM,CAAC,6EAA6E,CAAC;EACzFoB,EAAE,EAAEpB,MAAM,CAAC,6EAA6E,CAAC;EACzFqB,CAAC,EAAErB,MAAM,CAAC,CAAC,CAAC;EACZsB,IAAI,EAAE,KAAK;EACX,GAAGxB,OAAO,CAACV,MAAM,CAAC;EAClBe,QAAQ;EACRoB,aAAa,EAAGnB,KAAK,IAAK;IACtB,MAAMO,GAAG,GAAGd,CAAC,CAACY,eAAe,CAACL,KAAK,CAAC,CAACoB,QAAQ,CAAC,EAAE,CAAC;IACjD,IAAIb,GAAG,CAACJ,MAAM,KAAK,EAAE,EACjBH,KAAK,GAAGM,YAAY,CAACC,GAAG,GAAG,GAAG,CAAC;IACnC,OAAOpB,GAAG,CAACY,QAAQ,CAACC,KAAK,CAAC,EAAEL,WAAW,CAAC;EAC5C;AACJ,CAAC,CAAC;AACF,OAAO,MAAM0B,WAAW,GAAGX,KAAK;AAChC,SAASY,WAAWA,CAACf,GAAG,EAAE;EACtB,OAAOd,CAAC,CAAC6B,WAAW,CAAC,EAAE,EAAE,OAAOf,GAAG,KAAK,QAAQ,GAAGD,YAAY,CAACC,GAAG,CAAC,GAAGA,GAAG,CAAC;AAC/E;AACA,SAASgB,WAAWA,CAACC,OAAO,EAAE;EAC1B,OAAO/B,CAAC,CAACgC,UAAU,CAACH,WAAW,CAACE,OAAO,CAAC,CAAC,CAACE,QAAQ,CAAC,EAAE,EAAE,GAAG,CAAC;AAC/D;AACA,OAAO,SAASC,YAAYA,CAACH,OAAO,EAAEI,YAAY,GAAG,KAAK,EAAE;EACxD,OAAOlB,KAAK,CAACiB,YAAY,CAACJ,WAAW,CAACC,OAAO,CAAC,EAAEI,YAAY,CAAC;AACjE;AACA,OAAO,SAASC,eAAeA,CAACC,QAAQ,EAAEC,OAAO,EAAE;EAC/C,OAAOrB,KAAK,CAACmB,eAAe,CAACN,WAAW,CAACO,QAAQ,CAAC,EAAEC,OAAO,CAAC;AAChE;AACA,SAASC,cAAcA,CAACC,SAAS,EAAE;EAC/B,MAAM;IAAEC,CAAC;IAAEC;EAAE,CAAC,GAAGF,SAAS;EAC1B,IAAIC,CAAC,GAAG,EAAE,IAAIA,CAAC,IAAIrC,SAAS,EACxB,MAAM,IAAIuC,KAAK,CAAE,6BAA4BvC,SAAU,GAAE,CAAC;EAC9D,MAAMwC,CAAC,GAAGhD,MAAM,CAAC8C,CAAC,EAAExC,WAAW,CAAC;EAChC,IAAI0C,CAAC,GAAG,EAAE,IAAIA,CAAC,IAAIxC,SAAS,EACxB,MAAM,IAAIuC,KAAK,CAAE,kCAAiCvC,SAAU,GAAE,CAAC;AACvE;AACA,SAASyC,YAAYA,CAACC,OAAO,EAAE;EAC3B,MAAMvC,KAAK,GAAGsB,WAAW,CAACiB,OAAO,CAAC;EAClC,MAAMnC,GAAG,GAAGX,CAAC,CAACY,eAAe,CAACL,KAAK,CAAC;EACpC,IAAII,GAAG,IAAIP,SAAS,EAChB,MAAM,IAAIuC,KAAK,CAAE,yBAAwBvC,SAAU,GAAE,CAAC;EAC1D,OAAOG,KAAK;AAChB;AACA,OAAO,SAASwC,IAAIA,CAACD,OAAO,EAAEf,OAAO,EAAEiB,IAAI,EAAE;EACzC,MAAMC,GAAG,GAAGhC,KAAK,CAAC8B,IAAI,CAACF,YAAY,CAACC,OAAO,CAAC,EAAEhB,WAAW,CAACC,OAAO,CAAC,EAAEiB,IAAI,CAAC;EACzET,cAAc,CAACU,GAAG,CAAC;EACnB,OAAOA,GAAG;AACd;AACA,OAAO,SAASC,MAAMA,CAACV,SAAS,EAAEM,OAAO,EAAEK,MAAM,EAAE;EAC/C,IAAI,EAAEX,SAAS,YAAYY,SAAS,CAAC,EAAE;IACnC,MAAM7C,KAAK,GAAGsB,WAAW,CAACW,SAAS,CAAC;IACpC,IAAI;MACAA,SAAS,GAAGY,SAAS,CAACC,OAAO,CAAC9C,KAAK,CAAC;IACxC,CAAC,CACD,OAAO+C,QAAQ,EAAE;MACb,IAAI,EAAEA,QAAQ,YAAYvD,GAAG,CAACwD,GAAG,CAAC,EAC9B,MAAMD,QAAQ;MAClBd,SAAS,GAAGY,SAAS,CAACI,WAAW,CAACjD,KAAK,CAAC;IAC5C;EACJ;EACAgC,cAAc,CAACC,SAAS,CAAC;EACzB,OAAOvB,KAAK,CAACiC,MAAM,CAACV,SAAS,EAAEK,YAAY,CAACC,OAAO,CAAC,EAAEjB,WAAW,CAACsB,MAAM,CAAC,CAAC;AAC9E;AACA,MAAM;EAAEM,KAAK;EAAEC,eAAe;EAAEN,SAAS;EAAEO;AAAM,CAAC,GAAG1C,KAAK;AAC1D,SAASwC,KAAK,EAAEC,eAAe,EAAEN,SAAS,EAAEO,KAAK;AACjD,SAASC,QAAQA,CAACrD,KAAK,EAAE;EACrB,MAAMO,GAAG,GAAGd,CAAC,CAACgC,UAAU,CAACzB,KAAK,CAACC,QAAQ,CAAC,CAAC,CAAC,CAAC;EAC3C,MAAMqD,QAAQ,GAAG/C,GAAG,CAACgD,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC;EACzC,OAAQ,KAAID,QAAS,EAAC;AAC1B;AACA,SAAS9C,OAAOA,CAACD,GAAG,EAAE;EAClB,OAAOA,GAAG,CAACgD,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC;AAClC;AACA,OAAO,SAASC,QAAQA,CAACC,IAAI,EAAE;EAC3B,MAAMC,KAAK,GAAGpC,WAAW,CAACmC,IAAI,CAAC;EAC/B,MAAME,UAAU,GAAG,EAAE,IAAI,IAAI;EAC7B,MAAMC,KAAK,GAAGD,UAAU,GAAGxE,GAAG,CAACwE,UAAU,EAAEhE,WAAW,CAAC;EACvD,KAAK,IAAIkE,CAAC,GAAG,CAAC,GAAGA,CAAC,EAAE,EAAE;IAClB,MAAMC,GAAG,GAAGC,SAAS,CAACtE,CAAC,CAACuE,WAAW,CAACN,KAAK,EAAEjE,CAAC,CAACwE,kBAAkB,CAACrE,MAAM,CAACiE,CAAC,CAAC,CAAC,CAAC,CAAC;IAC5E,IAAIC,GAAG,GAAGF,KAAK,EACX,OAAOzE,GAAG,CAAC2E,GAAG,EAAEnE,WAAW,CAAC,CAACyB,QAAQ,CAAC,EAAE,CAAC;IAC7C,IAAIyC,CAAC,KAAK,MAAM,EACZ,MAAM,IAAIzB,KAAK,CAAC,qCAAqC,CAAC;EAC9D;AACJ;AACA,OAAO,SAAS8B,WAAWA,CAACC,UAAU,EAAE;EACpC,OAAOd,QAAQ,CAAC1B,YAAY,CAACwC,UAAU,EAAE,IAAI,CAAC,CAAC;AACnD;AACA,OAAO,SAASC,eAAeA,CAACnC,SAAS,EAAE;EACvCA,SAAS,GAAGzB,OAAO,CAACyB,SAAS,CAAC;EAC9B,IAAIA,SAAS,CAAC9B,MAAM,KAAK,GAAG,EACxB,MAAM,IAAIiC,KAAK,CAAC,0BAA0B,CAAC;EAC/C,OAAOoB,QAAQ,CAACvB,SAAS,CAACoC,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;AAC/C;AACA,MAAMC,OAAO,GAAG,EAAE,IAAI,GAAG,GAAG,EAAE;AAC9B,MAAMC,KAAK,GAAIzD,CAAC,IAAK0D,MAAM,CAAC1D,CAAC,GAAGwD,OAAO,CAAC;AACxC,OAAO,SAASG,cAAcA,CAACC,KAAK,EAAEC,WAAW,EAAEC,eAAe,EAAEC,KAAK,EAAE;EACvE,MAAMC,QAAQ,GAAGP,KAAK,CAACR,SAAS,CAACW,KAAK,CAAC,CAAC;EACxC,MAAMK,cAAc,GAAGR,KAAK,CAACR,SAAS,CAACY,WAAW,CAAC,CAAC;EACpD,MAAMK,GAAG,GAAGvF,CAAC,CAACwF,WAAW,CAACzE,OAAO,CAACoE,eAAe,CAAC,CAAC;EACnD,OAAQ,WAAUE,QAAS,KAAIC,cAAe,KAAIR,KAAK,CAACS,GAAG,CAAE,KAAIT,KAAK,CAACS,GAAG,IAAI,GAAG,CAAE,KAAIH,KAAM,EAAC;AAClG;AACA,MAAMK,eAAe,GAAG,CACpB,IAAI/B,eAAe,CAAC,6EAA6E,EAAE,6EAA6E,EAAE,EAAE,CAAC,EACrL,IAAIA,eAAe,CAAC,4EAA4E,EAAE,6EAA6E,EAAE,EAAE,CAAC,EACpL,IAAIA,eAAe,CAAC,6EAA6E,EAAE,6EAA6E,EAAE,EAAE,CAAC,EACrL,IAAIA,eAAe,CAAC,6EAA6E,EAAE,4EAA4E,EAAE,EAAE,CAAC,EACpL,IAAIA,eAAe,CAAC,6EAA6E,EAAE,4EAA4E,EAAE,EAAE,CAAC,CACvL;AACD,SAASgC,kBAAkBA,CAACC,EAAE,EAAEC,EAAE,EAAE;EAChC,MAAMC,GAAG,GAAG,EAAE;EACd,IAAIC,CAAC,GAAGH,EAAE;EACV,KAAK,IAAIvB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,GAAG,EAAEA,CAAC,EAAE,EAAE;IAC1ByB,GAAG,CAACE,IAAI,CAACD,CAAC,CAAC;IACXA,CAAC,GAAGA,CAAC,CAACE,MAAM,CAAC,CAAC;EAClB;EACAF,CAAC,GAAGF,EAAE;EACN,KAAK,IAAIxB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;IACxByB,GAAG,CAACE,IAAI,CAACD,CAAC,CAAC;IACXA,CAAC,GAAGA,CAAC,CAACE,MAAM,CAAC,CAAC;EAClB;EACA,OAAOH,GAAG;AACd;AACA,MAAMI,gBAAgB,GAAGP,kBAAkB,CAACD,eAAe,CAAC,CAAC,CAAC,EAAEA,eAAe,CAAC,CAAC,CAAC,CAAC;AACnF,MAAMS,gBAAgB,GAAGR,kBAAkB,CAACD,eAAe,CAAC,CAAC,CAAC,EAAEA,eAAe,CAAC,CAAC,CAAC,CAAC;AACnF,SAASU,WAAWA,CAACC,GAAG,EAAE;EACtB,IAAIC,KAAK;EACT,IAAI,OAAOD,GAAG,KAAK,QAAQ,EAAE;IACzBC,KAAK,GAAGD,GAAG;EACf,CAAC,MACI,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;IAC9B,IAAI,CAACrB,MAAM,CAACuB,aAAa,CAACF,GAAG,CAAC,EAC1B,MAAM,IAAIzD,KAAK,CAAE,wBAAuByD,GAAI,EAAC,CAAC;IAClDC,KAAK,GAAGlG,MAAM,CAACiG,GAAG,CAAC;EACvB,CAAC,MACI;IACDC,KAAK,GAAGrG,CAAC,CAACY,eAAe,CAACiB,WAAW,CAACuE,GAAG,CAAC,CAAC;EAC/C;EACA,IAAI,EAAE,EAAE,IAAIC,KAAK,IAAIA,KAAK,GAAGpF,KAAK,CAACwC,KAAK,CAACrC,EAAE,CAACmF,KAAK,CAAC,EAC9C,MAAM,IAAI5D,KAAK,CAAE,+CAA8C0D,KAAM,EAAC,CAAC;EAC3E,OAAOA,KAAK;AAChB;AACA,SAASG,cAAcA,CAACC,KAAK,EAAEJ,KAAK,EAAEK,SAAS,EAAE;EAC7C,IAAIC,CAAC,GAAGR,WAAW,CAACE,KAAK,CAAC;EAC1B,KAAK,IAAIO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,GAAG,EAAEA,CAAC,EAAE,EAAE;IAC1B,MAAMC,EAAE,GAAGH,SAAS,CAACE,CAAC,CAAC;IACvB,IAAIC,EAAE,CAACC,MAAM,CAACL,KAAK,CAAC,EAChB,MAAM,IAAI9D,KAAK,CAAC,YAAY,CAAC;IACjC,IAAI,CAACgE,CAAC,GAAG,EAAE,MAAM,EAAE,EACfF,KAAK,GAAGA,KAAK,CAACM,GAAG,CAACF,EAAE,CAAC;IACzBF,CAAC,KAAK,EAAE;EACZ;EACA,OAAOF,KAAK;AAChB;AACA,OAAO,SAASO,QAAQA,CAACL,CAAC,EAAEM,CAAC,EAAE;EAC3B,IAAIR,KAAK,GAAGhB,eAAe,CAAC,CAAC,CAAC;EAC9BgB,KAAK,GAAGD,cAAc,CAACC,KAAK,EAAEE,CAAC,EAAEV,gBAAgB,CAAC;EAClDQ,KAAK,GAAGD,cAAc,CAACC,KAAK,EAAEQ,CAAC,EAAEf,gBAAgB,CAAC;EAClD,OAAOtC,QAAQ,CAAC6C,KAAK,CAACS,UAAU,CAAC,IAAI,CAAC,CAAC;AAC3C;AACA,OAAO,MAAMC,qBAAqB,GAAGA,CAACC,IAAI,EAAEC,EAAE,GAAGL,QAAQ,KAAK,CAAC,CAAC,EAAE,GAAGI,IAAI,EAAEA,IAAI,CAAC1G,MAAM,CAAC,CAAC4G,MAAM,CAAC,CAACX,CAAC,EAAEM,CAAC,KAAKI,EAAE,CAACV,CAAC,EAAEM,CAAC,CAAC,CAAC;AAClH,MAAMM,QAAQ,GAAGvH,CAAC,CAACwH,OAAO,CAAC,GAAG,CAAC;AAC/B,OAAO,MAAMC,MAAM,GAAIL,IAAI,IAAKpH,CAAC,CAACY,eAAe,CAACtB,UAAU,CAAC8H,IAAI,CAAC,CAAC,GAAGG,QAAQ;AAC9E,MAAMjD,SAAS,GAAI8C,IAAI,IAAKpH,CAAC,CAACY,eAAe,CAACrB,MAAM,CAAC6H,IAAI,CAAC,CAAC;AAC3D,OAAO,MAAMM,KAAK,GAAGjI,KAAK,CAACU,MAAM,CAAC,8EAA8E,CAAC,CAAC;AAClH,SAASwH,qBAAqBA,CAACvG,EAAE,EAAEwG,IAAI,EAAEC,GAAG,EAAE;EAC1C,MAAMC,GAAG,GAAG1G,EAAE,CAAC2G,SAAS,CAACxI,MAAM,CAACC,WAAW,CAAE,GAAEoI,IAAK,GAAEC,GAAI,EAAC,CAAC,CAAC,CAAC;EAC9D,OAAOzG,EAAE,CAAC4G,MAAM,CAACF,GAAG,CAAC;AACzB;AACA,OAAO,SAASG,YAAYA,CAAC7G,EAAE,EAAEwG,IAAI,EAAEM,CAAC,EAAEC,OAAO,GAAG,CAAC,EAAE;EACnD,MAAMC,QAAQ,GAAG,EAAE;EACnB,MAAMC,QAAQ,GAAG,EAAE;EACnB,KAAK,IAAIjE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8D,CAAC,EAAE9D,CAAC,EAAE,EAAE;IACxBgE,QAAQ,CAACrC,IAAI,CAAC4B,qBAAqB,CAACvG,EAAE,EAAG,GAAEwG,IAAK,GAAE,EAAEO,OAAO,GAAGD,CAAC,GAAG9D,CAAC,CAAC,CAAC;IACrEiE,QAAQ,CAACtC,IAAI,CAAC4B,qBAAqB,CAACvG,EAAE,EAAG,GAAEwG,IAAK,GAAE,EAAEO,OAAO,GAAGD,CAAC,GAAG9D,CAAC,CAAC,CAAC;EACzE;EACA,IAAI,IAAIkE,GAAG,CAAC,CAAC,GAAGF,QAAQ,EAAE,GAAGC,QAAQ,CAAC,CAAC,CAACE,IAAI,KAAK,CAAC,GAAGL,CAAC,EAClD,MAAM,IAAIvF,KAAK,CAAC,iCAAiC,CAAC;EACtD,OAAOyF,QAAQ,CAACI,GAAG,CAAE7B,CAAC,IAAK0B,QAAQ,CAACG,GAAG,CAAEvB,CAAC,IAAK7F,EAAE,CAACqH,GAAG,CAACrH,EAAE,CAACsH,GAAG,CAAC/B,CAAC,EAAEM,CAAC,CAAC,CAAC,CAAC,CAAC;AACzE;AACA,MAAM0B,SAAS,GAAG,CACd,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACT,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EACV,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CACb,CAACH,GAAG,CAAEpE,CAAC,IAAKA,CAAC,CAACoE,GAAG,CAACrI,MAAM,CAAC,CAAC;AAC3B,OAAO,SAASyI,aAAaA,CAAC5F,IAAI,EAAE6F,GAAG,EAAE;EACrClJ,aAAa,CAACqD,IAAI,CAAC5B,EAAE,CAAC;EACtB,IAAI,CAAC2D,MAAM,CAACuB,aAAa,CAACtD,IAAI,CAAC8F,IAAI,CAAC,IAAI,CAAC/D,MAAM,CAACuB,aAAa,CAACtD,IAAI,CAAC+F,QAAQ,CAAC,EACxE,MAAM,IAAIpG,KAAK,CAAE,wBAAuBK,IAAK,EAAC,CAAC;EACnD,MAAMkF,CAAC,GAAGlF,IAAI,CAAC8F,IAAI,GAAG9F,IAAI,CAAC+F,QAAQ;EACnC,MAAMC,MAAM,GAAGhG,IAAI,CAACiG,UAAU,GAAGjG,IAAI,CAACkG,aAAa;EACnD,MAAMC,cAAc,GAAG,EAAE;EACzB,KAAK,IAAI/E,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4E,MAAM,EAAE5E,CAAC,EAAE,EAAE;IAC7B,MAAMgF,GAAG,GAAG,EAAE;IACd,KAAK,IAAIxC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsB,CAAC,EAAEtB,CAAC,EAAE,EACtBwC,GAAG,CAACrD,IAAI,CAAC4B,qBAAqB,CAAC3E,IAAI,CAAC5B,EAAE,EAAE,OAAO,EAAE8G,CAAC,GAAG9D,CAAC,GAAGwC,CAAC,CAAC,CAAC;IAChEuC,cAAc,CAACpD,IAAI,CAACqD,GAAG,CAAC;EAC5B;EACA,MAAMC,GAAG,GAAGxJ,QAAQ,CAAC;IACjB,GAAGmD,IAAI;IACPsG,CAAC,EAAEpB,CAAC;IACJqB,SAAS,EAAE,CAAC;IACZC,oBAAoB,EAAE,IAAI;IAC1BX,GAAG;IACHM;EACJ,CAAC,CAAC;EACFE,GAAG,CAACnB,CAAC,GAAGA,CAAC;EACTmB,GAAG,CAACP,IAAI,GAAG9F,IAAI,CAAC8F,IAAI;EACpBO,GAAG,CAACN,QAAQ,GAAG/F,IAAI,CAAC+F,QAAQ;EAC5B,OAAOM,GAAG;AACd;AACA,OAAO,SAASI,cAAcA,CAACzG,IAAI,EAAE0G,UAAU,GAAG,CAAC,EAAE;EACjD,MAAMxB,CAAC,GAAGlF,IAAI,CAAC8F,IAAI,GAAG9F,IAAI,CAAC+F,QAAQ;EACnC,IAAI,CAAChE,MAAM,CAACuB,aAAa,CAACoD,UAAU,CAAC,EACjC,MAAM,IAAI/G,KAAK,CAAE,oBAAmB+G,UAAW,EAAC,CAAC;EACrD,OAAOd,aAAa,CAAC5F,IAAI,EAAEiF,YAAY,CAACjF,IAAI,CAAC5B,EAAE,EAAE,UAAU,EAAE8G,CAAC,EAAEwB,UAAU,CAAC,CAAC;AAChF;AACA,OAAO,MAAMC,aAAa,GAAGf,aAAa,CAAC;EAAExH,EAAE,EAAEsG,KAAK;EAAEoB,IAAI,EAAE,CAAC;EAAEC,QAAQ,EAAE,CAAC;EAAEE,UAAU,EAAE,CAAC;EAAEC,aAAa,EAAE;AAAG,CAAC,EAAEP,SAAS,CAAC;AAC5H,OAAO,SAASiB,YAAYA,CAACjD,CAAC,EAAEM,CAAC,EAAEI,EAAE,GAAGsC,aAAa,EAAE;EACnD,OAAOtC,EAAE,CAAC,CAACV,CAAC,EAAEM,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5B;AACA,OAAO,SAAS4C,gBAAgBA,CAAClD,CAAC,EAAEM,CAAC,EAAEI,EAAE,GAAGsC,aAAa,EAAE;EACvD,OAAO3J,CAAC,CAACwE,kBAAkB,CAACoF,YAAY,CAAC5J,CAAC,CAACY,eAAe,CAAC+F,CAAC,CAAC,EAAE3G,CAAC,CAACY,eAAe,CAACqG,CAAC,CAAC,EAAEI,EAAE,CAAC,CAAC;AAC7F;AACA,OAAO,SAASyC,kBAAkBA,CAACnD,CAAC,EAAEU,EAAE,GAAGsC,aAAa,EAAE;EACtD,OAAOtC,EAAE,CAAC,CAACV,CAAC,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7B;AACA,OAAO,SAASoD,gBAAgBA,CAACC,MAAM,EAAE3C,EAAE,GAAGsC,aAAa,EAAE;EACzD,MAAM;IAAEzB,CAAC;IAAEY;EAAK,CAAC,GAAGzB,EAAE;EACtB,IAAI,CAAC4C,KAAK,CAACC,OAAO,CAACF,MAAM,CAAC,EACtB,MAAM,IAAIrH,KAAK,CAAC,iCAAiC,CAAC;EACtD,MAAMwH,MAAM,GAAGF,KAAK,CAACG,IAAI,CAACJ,MAAM,CAAC;EACjCG,MAAM,CAACpE,IAAI,CAAC,EAAE,CAAC;EACf,OAAOoE,MAAM,CAACzJ,MAAM,GAAGoI,IAAI,KAAK,CAAC,EAC7BqB,MAAM,CAACpE,IAAI,CAAC,EAAE,CAAC;EACnB,IAAIsE,KAAK,GAAG,IAAIJ,KAAK,CAAC/B,CAAC,CAAC,CAACoC,IAAI,CAAC,EAAE,CAAC;EACjC,KAAK,IAAIlG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+F,MAAM,CAACzJ,MAAM,EAAE0D,CAAC,IAAI0E,IAAI,EAAE;IAC1C,KAAK,IAAIlC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkC,IAAI,EAAElC,CAAC,EAAE,EACzByD,KAAK,CAACzD,CAAC,CAAC,IAAIuD,MAAM,CAAC/F,CAAC,GAAGwC,CAAC,CAAC;IAC7ByD,KAAK,GAAGhD,EAAE,CAACgD,KAAK,CAAC;EACrB;EACA,OAAOA,KAAK,CAAC,CAAC,CAAC;AACnB"},"metadata":{},"sourceType":"module","externalDependencies":[]}